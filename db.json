{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"c49e2c63bd383b6eb7d6d7b46623b26bf26b5ab6","modified":1476674955000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1476674939000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1476674939000},{"_id":"themes/next/.git","hash":"042ff34da0707513a5681580b37513c890c671ef","modified":1476674939000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1476674939000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1476674939000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1476674939000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1476674939000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1476674939000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1476674939000},{"_id":"themes/next/_config.yml","hash":"c09b4278d68b7d39cbc37c8a33b444258f282822","modified":1476501011000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1476674939000},{"_id":"themes/next/gulpfile.coffee","hash":"d267332ec1461042fb16a9cb0737e1555fb4b79e","modified":1476674939000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1476674939000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1476674050000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1476529038000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1476674939000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1476674939000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1476674939000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1476674939000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1476674939000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1476674939000},{"_id":"themes/next/languages/ko.yml","hash":"ce8b047c89daae77c03482fc76f16ffec6bdbf2d","modified":1476674939000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1476674939000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1476674939000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1476674939000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1476674939000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1476674939000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1476674939000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1476674939000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1476674939000},{"_id":"themes/next/layout/_layout.swig","hash":"cfb04083ccde8c0a7749c1a4ac39327f69c84863","modified":1476674939000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1476674939000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1476674939000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1476674939000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1476674939000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1476674939000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1476674939000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1476674939000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1476674939000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1476674939000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1476674939000},{"_id":"source/images/avatar.png","hash":"fe5cd294e709c42ac76edd5421cb0b2603557484","modified":1476675042000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"bc311e9f4333188da5c9c721ae467ba14410d5b2","modified":1476674939000},{"_id":"themes/next/layout/_macro/post.swig","hash":"ea40d388ae190e2228cbe54f054be621e3fa061c","modified":1476674939000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1476674939000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1476674939000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"084867c289c95c5ebc18435a3b2092091bb8e2ba","modified":1476674939000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1476674939000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1476674939000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1476674939000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"58fd826ca75b0cbc48b61a58da4b841e2fa34403","modified":1476674939000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1476674939000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1476674939000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1476674939000},{"_id":"themes/next/layout/_partials/head.swig","hash":"06b6604176367af52587312e2575b52ecf53c3d9","modified":1476674939000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1476674939000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1476674939000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1476674939000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1476674939000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1476674939000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1476674939000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1476674939000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1476674939000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1476674939000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1476674939000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1476674939000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1476674939000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1476674939000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1476674939000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1476674939000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1476674939000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"60a51a33416e2b86ac9fbefc86b80f2f5f60e1c0","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1476674939000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1476674939000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1476674939000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1476674939000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1476674939000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1476674939000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1476674939000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1476674939000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"9a13073ae239ac0c8a35c5d8cf77b706c10f58c2","modified":1476674939000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1476674939000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1476674939000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1476674939000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1476674939000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1476674939000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1476674939000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1476674939000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1476674939000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1476674939000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1476674939000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e533b70f281275357fce083422e5d26bbf69d543","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1476674939000}],"Category":[{"name":"Apple Development","_id":"ciudifej40003fc04p97w3d3r"},{"name":"iOS开发笔记","parent":"ciudifej40003fc04p97w3d3r","_id":"ciudifejh0008fc04qegbs24u"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-10-17T03:14:10.000Z","updated":"2016-10-17T03:14:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudicwg40000fc04nlh930w3","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"iOS引导页的镂空效果","date":"2016-04-29T14:06:55.000Z","_content":"\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","source":"_posts/iOS引导页的镂空效果.md","raw":"---\ntitle: iOS引导页的镂空效果\ndate: 2016-04-29 22:06:55\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","slug":"iOS引导页的镂空效果","published":1,"updated":"2016-10-15T11:29:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifeiy0001fc047fixxiz1","content":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n"},{"title":"iOS中的MAX(A,B)，需要注意的点","date":"2016-04-19T03:22:30.000Z","_content":"\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","source":"_posts/iOS中的MAX-A-B-，需要注意的点.md","raw":"---\ntitle: iOS中的MAX(A,B)，需要注意的点\ndate: 2016-04-19 11:22:30\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","slug":"iOS中的MAX-A-B-，需要注意的点","published":1,"updated":"2016-10-15T11:24:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifej10002fc04hg63bc4h","content":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n"},{"title":"Thrift的二进制数据编解码--以OC为例","date":"2016-04-16T14:56:14.000Z","_content":"\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","source":"_posts/Thrift的二进制数据编解码-以OC为例.md","raw":"---\ntitle: Thrift的二进制数据编解码--以OC为例\ndate: 2016-04-16 22:56:14\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","slug":"Thrift的二进制数据编解码-以OC为例","published":1,"updated":"2016-10-15T12:17:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifej60004fc04q7ld6mj8","content":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\" target=\"_blank\" rel=\"external\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n"},{"title":"iOS支持懒加载的PageViewController","date":"2016-09-01T16:12:18.000Z","_content":"\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","source":"_posts/iOS支持懒加载的PageViewController.md","raw":"---\ntitle: iOS支持懒加载的PageViewController\ndate: 2016-09-02 00:12:18\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","slug":"iOS支持懒加载的PageViewController","published":1,"updated":"2016-10-15T12:13:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifejb0005fc04nd857ijl","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n"},{"_content":"# iOS签名\n\n标签（空格分隔）： iOS 安全\n\n---\n[TOC]\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","source":"_posts/iOS签名.md","raw":"# iOS签名\n\n标签（空格分隔）： iOS 安全\n\n---\n[TOC]\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","slug":"iOS签名","published":1,"date":"2016-08-30T02:01:06.000Z","updated":"2016-08-30T02:01:06.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifejv000kfc042gva3l9z","content":"<h1 id=\"iOS签名\"><a href=\"#iOS签名\" class=\"headerlink\" title=\"iOS签名\"></a>iOS签名</h1><p>标签（空格分隔）： iOS 安全</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\" target=\"_blank\" rel=\"external\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\" target=\"_blank\" rel=\"external\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\" target=\"_blank\" rel=\"external\">iOS Code Signing 学习笔记</a></p>\n","excerpt":"","more":"<h1 id=\"iOS签名\"><a href=\"#iOS签名\" class=\"headerlink\" title=\"iOS签名\"></a>iOS签名</h1><p>标签（空格分隔）： iOS 安全</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\">iOS Code Signing 学习笔记</a></p>\n"},{"_content":"# KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\n\n标签（空格分隔）： iOS 开发\n\n---\n[TOC]\n\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n##KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","source":"_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","raw":"# KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\n\n标签（空格分隔）： iOS 开发\n\n---\n[TOC]\n\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n##KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","slug":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","published":1,"date":"2016-08-30T02:00:57.000Z","updated":"2016-08-30T02:00:57.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifejx000lfc04g9pweu4y","content":"<h1 id=\"KVO后-obj-class-与object-getClass-id-obj-的结果竟会不一致？\"><a href=\"#KVO后-obj-class-与object-getClass-id-obj-的结果竟会不一致？\" class=\"headerlink\" title=\"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\"></a>KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？</h1><p>标签（空格分隔）： iOS 开发</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<p>##KVO是元凶</p>\n<ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"KVO后-obj-class-与object-getClass-id-obj-的结果竟会不一致？\"><a href=\"#KVO后-obj-class-与object-getClass-id-obj-的结果竟会不一致？\" class=\"headerlink\" title=\"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\"></a>KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？</h1><p>标签（空格分隔）： iOS 开发</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<p>##KVO是元凶</p>\n<ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n"},{"_content":"# 创建pod库的步骤\n\n标签（空格分隔）： 开发 iOS\n---\n##注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n##验证邮箱\n```\npod trunk me\n```\n##push源码到git仓库\n##创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n##编辑podspec文件\n##检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n##使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n##成功后`pod setup`\n##验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","source":"_posts/创建pod库的步骤.md","raw":"# 创建pod库的步骤\n\n标签（空格分隔）： 开发 iOS\n---\n##注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n##验证邮箱\n```\npod trunk me\n```\n##push源码到git仓库\n##创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n##编辑podspec文件\n##检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n##使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n##成功后`pod setup`\n##验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","slug":"创建pod库的步骤","published":1,"date":"2016-08-30T02:02:32.000Z","updated":"2016-08-30T02:02:32.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifejz000mfc0408jwyop0","content":"<h1 id=\"创建pod库的步骤\"><a href=\"#创建pod库的步骤\" class=\"headerlink\" title=\"创建pod库的步骤\"></a>创建pod库的步骤</h1><h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><p>##注册Trunk<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure></p>\n<p>##验证邮箱<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure></p>\n<p>##push源码到git仓库</p>\n<p>##创建podspec文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure></p>\n<p>##编辑podspec文件</p>\n<p>##检查podspec文件格式是否符合规则<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure></p>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<p>##使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure></p>\n<p>##成功后<code>pod setup</code></p>\n<p>##验证是否成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h1 id=\"创建pod库的步骤\"><a href=\"#创建pod库的步骤\" class=\"headerlink\" title=\"创建pod库的步骤\"></a>创建pod库的步骤</h1><h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><p>##注册Trunk<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure></p>\n<p>##验证邮箱<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure></p>\n<p>##push源码到git仓库</p>\n<p>##创建podspec文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure></p>\n<p>##编辑podspec文件</p>\n<p>##检查podspec文件格式是否符合规则<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure></p>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<p>##使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure></p>\n<p>##成功后<code>pod setup</code></p>\n<p>##验证是否成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure></p>\n"},{"title":"简约的iOS音乐播放UI控件","date":"2016-05-24T10:46:59.000Z","_content":"\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","source":"_posts/简约的iOS音乐播放UI控件.md","raw":"---\ntitle: 简约的iOS音乐播放UI控件\ndate: 2016-05-24 18:46:59\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","slug":"简约的iOS音乐播放UI控件","published":1,"updated":"2016-10-15T11:35:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudifek2000nfc04ndhyzzlb","content":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n"},{"_content":"# 读书笔记之《如何阅读一本书》\n\n标签（空格分隔）： 读书笔记 方法论\n\n---\n[TOC]\n##阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n##基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n##检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","source":"_posts/读书笔记之《如何阅读一本书》.md","raw":"# 读书笔记之《如何阅读一本书》\n\n标签（空格分隔）： 读书笔记 方法论\n\n---\n[TOC]\n##阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n##基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n##检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","slug":"读书笔记之《如何阅读一本书》","published":1,"date":"2016-08-30T01:57:32.000Z","updated":"2016-08-30T01:57:32.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudiftx8000qfc047nb11bbo","content":"<h1 id=\"读书笔记之《如何阅读一本书》\"><a href=\"#读书笔记之《如何阅读一本书》\" class=\"headerlink\" title=\"读书笔记之《如何阅读一本书》\"></a>读书笔记之《如何阅读一本书》</h1><p>标签（空格分隔）： 读书笔记 方法论</p>\n<hr>\n<p>[TOC]</p>\n<p>##阅读的四个层次</p>\n<ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<p>##基础阅读（四个阶段）</p>\n<ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<p>##检视阅读（如何做）</p>\n<ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"读书笔记之《如何阅读一本书》\"><a href=\"#读书笔记之《如何阅读一本书》\" class=\"headerlink\" title=\"读书笔记之《如何阅读一本书》\"></a>读书笔记之《如何阅读一本书》</h1><p>标签（空格分隔）： 读书笔记 方法论</p>\n<hr>\n<p>[TOC]</p>\n<p>##阅读的四个层次</p>\n<ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<p>##基础阅读（四个阶段）</p>\n<ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<p>##检视阅读（如何做）</p>\n<ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n"},{"_content":"# React Native笔记\n\n## 要点记录\n### 本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\nreturn dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n// Call long-running code on background thread\n...\n// You can invoke callback from any thread/queue\ncallback(@[...]);\n});\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\nNSString *eventName = notification.userInfo[@\"name\"];\n[self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n'EventReminder',\n(reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n## 本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\nRCTMap *map = [RCTMap new];\nmap.delegate = self;\nreturn map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n[view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\nrender() {\nreturn <RCTMap {...this.props} />;\n}\n}\n\nMapView.propTypes = {\n/**\n* When this property is set to `true` and a valid camera is associated\n* with the map, the camera’s pitch angle is used to tilt the plane\n* of the map. When this property is set to `false`, the camera’s pitch\n* angle is ignored and the map is always displayed as if the user\n* is looking straight down onto it.\n*/\npitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n## FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_fb.png?raw=true)\n- 网友眼中的MVC\n![网友眼中的MVC](https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_other.png?raw=true)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/flux_flow.png?raw=true0)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n## ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n## 遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","source":"_posts/H5的体验优化.md","raw":"# React Native笔记\n\n## 要点记录\n### 本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\nreturn dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n// Call long-running code on background thread\n...\n// You can invoke callback from any thread/queue\ncallback(@[...]);\n});\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\nNSString *eventName = notification.userInfo[@\"name\"];\n[self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n'EventReminder',\n(reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n## 本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\nRCTMap *map = [RCTMap new];\nmap.delegate = self;\nreturn map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n[view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\nrender() {\nreturn <RCTMap {...this.props} />;\n}\n}\n\nMapView.propTypes = {\n/**\n* When this property is set to `true` and a valid camera is associated\n* with the map, the camera’s pitch angle is used to tilt the plane\n* of the map. When this property is set to `false`, the camera’s pitch\n* angle is ignored and the map is always displayed as if the user\n* is looking straight down onto it.\n*/\npitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n## FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_fb.png?raw=true)\n- 网友眼中的MVC\n![网友眼中的MVC](https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_other.png?raw=true)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/flux_flow.png?raw=true0)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n## ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n## 遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","slug":"H5的体验优化","published":1,"date":"2016-08-30T02:04:48.000Z","updated":"2016-10-15T10:22:06.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudigd83000rfc04cjxkc19j","content":"<h1 id=\"React-Native笔记\"><a href=\"#React-Native笔记\" class=\"headerlink\" title=\"React Native笔记\"></a>React Native笔记</h1><h2 id=\"要点记录\"><a href=\"#要点记录\" class=\"headerlink\" title=\"要点记录\"></a>要点记录</h2><h3 id=\"本地模块（Native-Modules）\"><a href=\"#本地模块（Native-Modules）\" class=\"headerlink\" title=\"本地模块（Native Modules）\"></a>本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\" target=\"_blank\" rel=\"external\">Native Modules</a>）</h3><ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\"><span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">callback(@[...]);</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">[<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\"><span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">(reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地UI组件（Native-UI-Components\"><a href=\"#本地UI组件（Native-UI-Components\" class=\"headerlink\" title=\"本地UI组件（Native UI Components)\"></a>本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\" target=\"_blank\" rel=\"external\">Native UI Components</a>)</h2><ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">RCTMap *map = [RCTMap new];</div><div class=\"line\">map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">[view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">render() &#123;</div><div class=\"line\"><span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">/**</div><div class=\"line\">* When this property is set to `true` and a valid camera is associated</div><div class=\"line\">* with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">* of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">* angle is ignored and the map is always displayed as if the user</div><div class=\"line\">* is looking straight down onto it.</div><div class=\"line\">*/</div><div class=\"line\">pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<h2 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_fb.png?raw=true\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_other.png?raw=true\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/flux_flow.png?raw=true0\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<h2 id=\"ES6语法相关\"><a href=\"#ES6语法相关\" class=\"headerlink\" title=\"ES6语法相关\"></a>ES6语法相关</h2><ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\" target=\"_blank\" rel=\"external\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n","excerpt":"","more":"<h1 id=\"React-Native笔记\"><a href=\"#React-Native笔记\" class=\"headerlink\" title=\"React Native笔记\"></a>React Native笔记</h1><h2 id=\"要点记录\"><a href=\"#要点记录\" class=\"headerlink\" title=\"要点记录\"></a>要点记录</h2><h3 id=\"本地模块（Native-Modules）\"><a href=\"#本地模块（Native-Modules）\" class=\"headerlink\" title=\"本地模块（Native Modules）\"></a>本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\">Native Modules</a>）</h3><ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\"><span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">callback(@[...]);</div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">[<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\"><span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">(reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地UI组件（Native-UI-Components\"><a href=\"#本地UI组件（Native-UI-Components\" class=\"headerlink\" title=\"本地UI组件（Native UI Components)\"></a>本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\">Native UI Components</a>)</h2><ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">RCTMap *map = [RCTMap new];</div><div class=\"line\">map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">[view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">render() &#123;</div><div class=\"line\"><span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">/**</div><div class=\"line\">* When this property is set to `true` and a valid camera is associated</div><div class=\"line\">* with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">* of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">* angle is ignored and the map is always displayed as if the user</div><div class=\"line\">* is looking straight down onto it.</div><div class=\"line\">*/</div><div class=\"line\">pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<h2 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_fb.png?raw=true\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/mvc_by_other.png?raw=true\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Web/HTML5/images/flux_flow.png?raw=true0\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<h2 id=\"ES6语法相关\"><a href=\"#ES6语法相关\" class=\"headerlink\" title=\"ES6语法相关\"></a>ES6语法相关</h2><ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n"},{"_content":"# Mach-O格式文件(用户态下的进程加载)\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n[TOC]\n___\n\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mach-O格式文件(用户态下的进程加载).md","raw":"# Mach-O格式文件(用户态下的进程加载)\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n[TOC]\n___\n\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mach-O格式文件(用户态下的进程加载)","published":1,"date":"2016-09-16T03:07:52.000Z","updated":"2016-09-16T03:07:52.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudih998000sfc04ukmr3gzk","content":"<h1 id=\"Mach-O格式文件-用户态下的进程加载\"><a href=\"#Mach-O格式文件-用户态下的进程加载\" class=\"headerlink\" title=\"Mach-O格式文件(用户态下的进程加载)\"></a>Mach-O格式文件(用户态下的进程加载)</h1><p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>[TOC]</p>\n<hr>\n<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"Mach-O格式文件-用户态下的进程加载\"><a href=\"#Mach-O格式文件-用户态下的进程加载\" class=\"headerlink\" title=\"Mach-O格式文件(用户态下的进程加载)\"></a>Mach-O格式文件(用户态下的进程加载)</h1><p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>[TOC]</p>\n<hr>\n<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n"},{"_content":"#读书笔记之Mach调度\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n\n##线程\n线程是个结构体\n##任务（task）\n线程的容器，是以线程为元素的数组\n##优先级\n##运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n##续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n##抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n##异步软件陷阱（AST）\n\n##定时器中断\n软件定时器：\n硬件定时器：\n##异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","source":"_posts/Mach调度.md","raw":"#读书笔记之Mach调度\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n\n##线程\n线程是个结构体\n##任务（task）\n线程的容器，是以线程为元素的数组\n##优先级\n##运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n##续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n##抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n##异步软件陷阱（AST）\n\n##定时器中断\n软件定时器：\n硬件定时器：\n##异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","slug":"Mach调度","published":1,"date":"2016-08-30T02:12:09.000Z","updated":"2016-08-30T02:12:09.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudih99v000tfc04yso1z04u","content":"<p>#读书笔记之Mach调度</p>\n<p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>##线程<br>线程是个结构体</p>\n<p>##任务（task）<br>线程的容器，是以线程为元素的数组</p>\n<p>##优先级</p>\n<p>##运行队列<br>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<p>##续体<br>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<p>##抢占模式</p>\n<ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<br>##异步软件陷阱（AST）</li>\n</ul>\n<p>##定时器中断<br>软件定时器：<br>硬件定时器：</p>\n<p>##异常</p>\n<ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n","excerpt":"","more":"<p>#读书笔记之Mach调度</p>\n<p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>##线程<br>线程是个结构体</p>\n<p>##任务（task）<br>线程的容器，是以线程为元素的数组</p>\n<p>##优先级</p>\n<p>##运行队列<br>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<p>##续体<br>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<p>##抢占模式</p>\n<ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<br>##异步软件陷阱（AST）</li>\n</ul>\n<p>##定时器中断<br>软件定时器：<br>硬件定时器：</p>\n<p>##异常</p>\n<ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n"},{"_content":"# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","source":"_posts/内核架构.md","raw":"# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","slug":"内核架构","published":1,"date":"2016-09-04T14:42:35.000Z","updated":"2016-09-07T12:38:44.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudih99y000ufc047ee42v5b","content":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>","excerpt":"","more":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>"},{"_content":"# 引导过程：EFI和iBoot\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n[TOC]\n\n##什么是引导过程\n引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：\n\n1. 刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。\n2. 接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到`操作系统加载器`。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。\n3. 由操作系统加载器加载操作系统代码。\n\n## EFI（Extensible Firmware Interface，可扩展固件接口）\n\n### BIOS的局限性\n- BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。\n- 只允许4个可引导分区（或称为主分区）。\n\n### EFI的概念\n正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。\n> EFI自下而上的架构大概是：硬件->固件（包含：EFI引导服务和EFI运行时服务）->EFI二进制文件（EFI引导加载器）->软件\n\n### EFI提供的服务\n\n#### EFI引导服务\n当系统仍然在EFI环境中，并且没有调用`ExitBootServices()`这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了`ExitBootServices()`,引导服务就无法访问了。\n\n对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：\n\n- **控制台协议**（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）\n- **媒介访问**（和文件系统打交道）\n- **杂项协议**（）\n\n#### EFI运行时服务\n跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：\n\n- 时间管理\n- 闹钟\n- 固件变量\n- 其他杂项\n\n## OS X的boot.efi\n1. 调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。\n2. 引导内核，EFI引导服务退出。\n3. 内核回调EFI运行时服务。\n\n## iOS的iBoot\niOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：\n\n- **普通引导、恢复模式引导**\n- **DFU模式引导**\n\n![图1][1]\n\n整个引导过程大概是这样的：\n\n1. 首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)\n2. 接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。\n3. 普通引导或恢复模式引导：\n\t- 加载LLB（Low level Bootloader，底层引导加载器。\n\t- 加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 \n4. DFU模式引导，使用了两个镜像iBSS和iBEC。\n\t- iBSS：负责底层初始化以及iBEC的加载。\n\t- iBEC：负责iTunes通过USB升级的过程。\n\n### 普通引导或恢复模式引导\n#### LLB\n它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。\n#### iBoot\niBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：\n\n- **“main”线程**，负责苹果的logo，以及系统的引导。\n- **“uart reader”线程**，这个线程用户调试用。\n\n正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入**恢复模式**，main线程会派生几下几个任务：\n\n- **idleoff任务**，当用户不操作时，关闭设备。\n- **poweroff任务**，当电量不足的时候，关闭设备。\n- **usb-req任务**，处理iTunes的USB请求。\n- **usb-high-current和usb-no-current任务**，响应USB充电。（当设备充电或者断开充电，修改电池图标）\n- **command任务**,启动命令行接口，即通过串口操作的控制台。\n\n#### 恢复模式引导与普通引导的区别\n恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。\n\n### DFU模式引导\n再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。\n\n## OS X的安装过程\n### 步骤1：installXXX.app\n安装包包含的文件如下图所示：\n![图2][2]\n运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作`根文件系统`的镜像--BaseSystem.dmg，然后通过`bless`命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。\n\n### 步骤2：OSInstaller\n引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。\n### 步骤3：安装.pkg文件\n最后就是安装各种各样的软件包了。\n\n## iOS文件系统镜像（.ipsw文件）\n将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。\n![图3][3]\n\n> 可以使用工具[wpwntool][4]解密文件，使用[vfdecrypt][4]解密系统镜像。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/ipsw.png?raw=true\n[4]: http://theiphonewiki.com/\n\n\n\n\n\n\n\n","source":"_posts/引导过程：EFI和iBoot.md","raw":"# 引导过程：EFI和iBoot\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n[TOC]\n\n##什么是引导过程\n引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：\n\n1. 刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。\n2. 接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到`操作系统加载器`。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。\n3. 由操作系统加载器加载操作系统代码。\n\n## EFI（Extensible Firmware Interface，可扩展固件接口）\n\n### BIOS的局限性\n- BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。\n- 只允许4个可引导分区（或称为主分区）。\n\n### EFI的概念\n正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。\n> EFI自下而上的架构大概是：硬件->固件（包含：EFI引导服务和EFI运行时服务）->EFI二进制文件（EFI引导加载器）->软件\n\n### EFI提供的服务\n\n#### EFI引导服务\n当系统仍然在EFI环境中，并且没有调用`ExitBootServices()`这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了`ExitBootServices()`,引导服务就无法访问了。\n\n对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：\n\n- **控制台协议**（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）\n- **媒介访问**（和文件系统打交道）\n- **杂项协议**（）\n\n#### EFI运行时服务\n跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：\n\n- 时间管理\n- 闹钟\n- 固件变量\n- 其他杂项\n\n## OS X的boot.efi\n1. 调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。\n2. 引导内核，EFI引导服务退出。\n3. 内核回调EFI运行时服务。\n\n## iOS的iBoot\niOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：\n\n- **普通引导、恢复模式引导**\n- **DFU模式引导**\n\n![图1][1]\n\n整个引导过程大概是这样的：\n\n1. 首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)\n2. 接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。\n3. 普通引导或恢复模式引导：\n\t- 加载LLB（Low level Bootloader，底层引导加载器。\n\t- 加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 \n4. DFU模式引导，使用了两个镜像iBSS和iBEC。\n\t- iBSS：负责底层初始化以及iBEC的加载。\n\t- iBEC：负责iTunes通过USB升级的过程。\n\n### 普通引导或恢复模式引导\n#### LLB\n它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。\n#### iBoot\niBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：\n\n- **“main”线程**，负责苹果的logo，以及系统的引导。\n- **“uart reader”线程**，这个线程用户调试用。\n\n正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入**恢复模式**，main线程会派生几下几个任务：\n\n- **idleoff任务**，当用户不操作时，关闭设备。\n- **poweroff任务**，当电量不足的时候，关闭设备。\n- **usb-req任务**，处理iTunes的USB请求。\n- **usb-high-current和usb-no-current任务**，响应USB充电。（当设备充电或者断开充电，修改电池图标）\n- **command任务**,启动命令行接口，即通过串口操作的控制台。\n\n#### 恢复模式引导与普通引导的区别\n恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。\n\n### DFU模式引导\n再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。\n\n## OS X的安装过程\n### 步骤1：installXXX.app\n安装包包含的文件如下图所示：\n![图2][2]\n运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作`根文件系统`的镜像--BaseSystem.dmg，然后通过`bless`命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。\n\n### 步骤2：OSInstaller\n引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。\n### 步骤3：安装.pkg文件\n最后就是安装各种各样的软件包了。\n\n## iOS文件系统镜像（.ipsw文件）\n将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。\n![图3][3]\n\n> 可以使用工具[wpwntool][4]解密文件，使用[vfdecrypt][4]解密系统镜像。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/ipsw.png?raw=true\n[4]: http://theiphonewiki.com/\n\n\n\n\n\n\n\n","slug":"引导过程：EFI和iBoot","published":1,"date":"2016-09-01T01:17:21.000Z","updated":"2016-09-01T14:45:58.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudih9a0000vfc04sb2xaq2n","content":"<h1 id=\"引导过程：EFI和iBoot\"><a href=\"#引导过程：EFI和iBoot\" class=\"headerlink\" title=\"引导过程：EFI和iBoot\"></a>引导过程：EFI和iBoot</h1><p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>[TOC]</p>\n<p>##什么是引导过程<br>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>\n<ol>\n<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>\n<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>\n<li>由操作系统加载器加载操作系统代码。</li>\n</ol>\n<h2 id=\"EFI（Extensible-Firmware-Interface，可扩展固件接口）\"><a href=\"#EFI（Extensible-Firmware-Interface，可扩展固件接口）\" class=\"headerlink\" title=\"EFI（Extensible Firmware Interface，可扩展固件接口）\"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id=\"BIOS的局限性\"><a href=\"#BIOS的局限性\" class=\"headerlink\" title=\"BIOS的局限性\"></a>BIOS的局限性</h3><ul>\n<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>\n<li>只允许4个可引导分区（或称为主分区）。</li>\n</ul>\n<h3 id=\"EFI的概念\"><a href=\"#EFI的概念\" class=\"headerlink\" title=\"EFI的概念\"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>\n<blockquote>\n<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>\n</blockquote>\n<h3 id=\"EFI提供的服务\"><a href=\"#EFI提供的服务\" class=\"headerlink\" title=\"EFI提供的服务\"></a>EFI提供的服务</h3><h4 id=\"EFI引导服务\"><a href=\"#EFI引导服务\" class=\"headerlink\" title=\"EFI引导服务\"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>\n<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>\n<ul>\n<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>\n<li><strong>媒介访问</strong>（和文件系统打交道）</li>\n<li><strong>杂项协议</strong>（）</li>\n</ul>\n<h4 id=\"EFI运行时服务\"><a href=\"#EFI运行时服务\" class=\"headerlink\" title=\"EFI运行时服务\"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>\n<ul>\n<li>时间管理</li>\n<li>闹钟</li>\n<li>固件变量</li>\n<li>其他杂项</li>\n</ul>\n<h2 id=\"OS-X的boot-efi\"><a href=\"#OS-X的boot-efi\" class=\"headerlink\" title=\"OS X的boot.efi\"></a>OS X的boot.efi</h2><ol>\n<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>\n<li>引导内核，EFI引导服务退出。</li>\n<li>内核回调EFI运行时服务。</li>\n</ol>\n<h2 id=\"iOS的iBoot\"><a href=\"#iOS的iBoot\" class=\"headerlink\" title=\"iOS的iBoot\"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>\n<ul>\n<li><strong>普通引导、恢复模式引导</strong></li>\n<li><strong>DFU模式引导</strong></li>\n</ul>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\" alt=\"图1\"></p>\n<p>整个引导过程大概是这样的：</p>\n<ol>\n<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>\n<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>\n<li>普通引导或恢复模式引导：<ul>\n<li>加载LLB（Low level Bootloader，底层引导加载器。</li>\n<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>\n</ul>\n</li>\n<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>\n<li>iBSS：负责底层初始化以及iBEC的加载。</li>\n<li>iBEC：负责iTunes通过USB升级的过程。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"普通引导或恢复模式引导\"><a href=\"#普通引导或恢复模式引导\" class=\"headerlink\" title=\"普通引导或恢复模式引导\"></a>普通引导或恢复模式引导</h3><h4 id=\"LLB\"><a href=\"#LLB\" class=\"headerlink\" title=\"LLB\"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>\n<h4 id=\"iBoot\"><a href=\"#iBoot\" class=\"headerlink\" title=\"iBoot\"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>\n<ul>\n<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>\n<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>\n</ul>\n<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>\n<ul>\n<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>\n<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>\n<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>\n<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>\n<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>\n</ul>\n<h4 id=\"恢复模式引导与普通引导的区别\"><a href=\"#恢复模式引导与普通引导的区别\" class=\"headerlink\" title=\"恢复模式引导与普通引导的区别\"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>\n<h3 id=\"DFU模式引导\"><a href=\"#DFU模式引导\" class=\"headerlink\" title=\"DFU模式引导\"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>\n<h2 id=\"OS-X的安装过程\"><a href=\"#OS-X的安装过程\" class=\"headerlink\" title=\"OS X的安装过程\"></a>OS X的安装过程</h2><h3 id=\"步骤1：installXXX-app\"><a href=\"#步骤1：installXXX-app\" class=\"headerlink\" title=\"步骤1：installXXX.app\"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\" alt=\"图2\"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>\n<h3 id=\"步骤2：OSInstaller\"><a href=\"#步骤2：OSInstaller\" class=\"headerlink\" title=\"步骤2：OSInstaller\"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>\n<h3 id=\"步骤3：安装-pkg文件\"><a href=\"#步骤3：安装-pkg文件\" class=\"headerlink\" title=\"步骤3：安装.pkg文件\"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>\n<h2 id=\"iOS文件系统镜像（-ipsw文件）\"><a href=\"#iOS文件系统镜像（-ipsw文件）\" class=\"headerlink\" title=\"iOS文件系统镜像（.ipsw文件）\"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true\" alt=\"图3\"></p>\n<blockquote>\n<p>可以使用工具<a href=\"http://theiphonewiki.com/\" target=\"_blank\" rel=\"external\">wpwntool</a>解密文件，使用<a href=\"http://theiphonewiki.com/\" target=\"_blank\" rel=\"external\">vfdecrypt</a>解密系统镜像。</p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h1 id=\"引导过程：EFI和iBoot\"><a href=\"#引导过程：EFI和iBoot\" class=\"headerlink\" title=\"引导过程：EFI和iBoot\"></a>引导过程：EFI和iBoot</h1><p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>[TOC]</p>\n<p>##什么是引导过程<br>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>\n<ol>\n<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>\n<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>\n<li>由操作系统加载器加载操作系统代码。</li>\n</ol>\n<h2 id=\"EFI（Extensible-Firmware-Interface，可扩展固件接口）\"><a href=\"#EFI（Extensible-Firmware-Interface，可扩展固件接口）\" class=\"headerlink\" title=\"EFI（Extensible Firmware Interface，可扩展固件接口）\"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id=\"BIOS的局限性\"><a href=\"#BIOS的局限性\" class=\"headerlink\" title=\"BIOS的局限性\"></a>BIOS的局限性</h3><ul>\n<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>\n<li>只允许4个可引导分区（或称为主分区）。</li>\n</ul>\n<h3 id=\"EFI的概念\"><a href=\"#EFI的概念\" class=\"headerlink\" title=\"EFI的概念\"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>\n<blockquote>\n<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>\n</blockquote>\n<h3 id=\"EFI提供的服务\"><a href=\"#EFI提供的服务\" class=\"headerlink\" title=\"EFI提供的服务\"></a>EFI提供的服务</h3><h4 id=\"EFI引导服务\"><a href=\"#EFI引导服务\" class=\"headerlink\" title=\"EFI引导服务\"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>\n<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>\n<ul>\n<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>\n<li><strong>媒介访问</strong>（和文件系统打交道）</li>\n<li><strong>杂项协议</strong>（）</li>\n</ul>\n<h4 id=\"EFI运行时服务\"><a href=\"#EFI运行时服务\" class=\"headerlink\" title=\"EFI运行时服务\"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>\n<ul>\n<li>时间管理</li>\n<li>闹钟</li>\n<li>固件变量</li>\n<li>其他杂项</li>\n</ul>\n<h2 id=\"OS-X的boot-efi\"><a href=\"#OS-X的boot-efi\" class=\"headerlink\" title=\"OS X的boot.efi\"></a>OS X的boot.efi</h2><ol>\n<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>\n<li>引导内核，EFI引导服务退出。</li>\n<li>内核回调EFI运行时服务。</li>\n</ol>\n<h2 id=\"iOS的iBoot\"><a href=\"#iOS的iBoot\" class=\"headerlink\" title=\"iOS的iBoot\"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>\n<ul>\n<li><strong>普通引导、恢复模式引导</strong></li>\n<li><strong>DFU模式引导</strong></li>\n</ul>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\" alt=\"图1\"></p>\n<p>整个引导过程大概是这样的：</p>\n<ol>\n<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>\n<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>\n<li>普通引导或恢复模式引导：<ul>\n<li>加载LLB（Low level Bootloader，底层引导加载器。</li>\n<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>\n</ul>\n</li>\n<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>\n<li>iBSS：负责底层初始化以及iBEC的加载。</li>\n<li>iBEC：负责iTunes通过USB升级的过程。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"普通引导或恢复模式引导\"><a href=\"#普通引导或恢复模式引导\" class=\"headerlink\" title=\"普通引导或恢复模式引导\"></a>普通引导或恢复模式引导</h3><h4 id=\"LLB\"><a href=\"#LLB\" class=\"headerlink\" title=\"LLB\"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>\n<h4 id=\"iBoot\"><a href=\"#iBoot\" class=\"headerlink\" title=\"iBoot\"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>\n<ul>\n<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>\n<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>\n</ul>\n<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>\n<ul>\n<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>\n<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>\n<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>\n<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>\n<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>\n</ul>\n<h4 id=\"恢复模式引导与普通引导的区别\"><a href=\"#恢复模式引导与普通引导的区别\" class=\"headerlink\" title=\"恢复模式引导与普通引导的区别\"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>\n<h3 id=\"DFU模式引导\"><a href=\"#DFU模式引导\" class=\"headerlink\" title=\"DFU模式引导\"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>\n<h2 id=\"OS-X的安装过程\"><a href=\"#OS-X的安装过程\" class=\"headerlink\" title=\"OS X的安装过程\"></a>OS X的安装过程</h2><h3 id=\"步骤1：installXXX-app\"><a href=\"#步骤1：installXXX-app\" class=\"headerlink\" title=\"步骤1：installXXX.app\"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\" alt=\"图2\"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>\n<h3 id=\"步骤2：OSInstaller\"><a href=\"#步骤2：OSInstaller\" class=\"headerlink\" title=\"步骤2：OSInstaller\"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>\n<h3 id=\"步骤3：安装-pkg文件\"><a href=\"#步骤3：安装-pkg文件\" class=\"headerlink\" title=\"步骤3：安装.pkg文件\"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>\n<h2 id=\"iOS文件系统镜像（-ipsw文件）\"><a href=\"#iOS文件系统镜像（-ipsw文件）\" class=\"headerlink\" title=\"iOS文件系统镜像（.ipsw文件）\"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true\" alt=\"图3\"></p>\n<blockquote>\n<p>可以使用工具<a href=\"http://theiphonewiki.com/\">wpwntool</a>解密文件，使用<a href=\"http://theiphonewiki.com/\">vfdecrypt</a>解密系统镜像。</p>\n</blockquote>\n<hr>\n"},{"_content":"# 网络七层协议（结合操作系统来了解）\n\n标签（空格分隔）： 开发 网络\n\n---\n[TOC]\n\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n##硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","source":"_posts/网络七层协议（结合操作系统来了解）.md","raw":"# 网络七层协议（结合操作系统来了解）\n\n标签（空格分隔）： 开发 网络\n\n---\n[TOC]\n\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n##硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","slug":"网络七层协议（结合操作系统来了解）","published":1,"date":"2016-08-30T02:09:57.000Z","updated":"2016-08-30T02:09:57.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudih9a7000wfc04136t34cl","content":"<h1 id=\"网络七层协议（结合操作系统来了解）\"><a href=\"#网络七层协议（结合操作系统来了解）\" class=\"headerlink\" title=\"网络七层协议（结合操作系统来了解）\"></a>网络七层协议（结合操作系统来了解）</h1><p>标签（空格分隔）： 开发 网络</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<p>##硬件</p>\n<h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n","excerpt":"","more":"<h1 id=\"网络七层协议（结合操作系统来了解）\"><a href=\"#网络七层协议（结合操作系统来了解）\" class=\"headerlink\" title=\"网络七层协议（结合操作系统来了解）\"></a>网络七层协议（结合操作系统来了解）</h1><p>标签（空格分隔）： 开发 网络</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<p>##硬件</p>\n<h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n"},{"_content":"# 文件系统和虚拟文件系统交换（VFS）\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n##硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","source":"_posts/文件系统和虚拟文件系统交换（VFS）.md","raw":"# 文件系统和虚拟文件系统交换（VFS）\n\n标签（空格分隔）： 《OSX&iOS内核》 读书笔记\n\n---\n##硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","slug":"文件系统和虚拟文件系统交换（VFS）","published":1,"date":"2016-08-30T02:11:37.000Z","updated":"2016-08-30T02:11:37.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudih9ae000xfc04xx01ibn0","content":"<h1 id=\"文件系统和虚拟文件系统交换（VFS）\"><a href=\"#文件系统和虚拟文件系统交换（VFS）\" class=\"headerlink\" title=\"文件系统和虚拟文件系统交换（VFS）\"></a>文件系统和虚拟文件系统交换（VFS）</h1><p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>##硬盘分区</p>\n<h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"文件系统和虚拟文件系统交换（VFS）\"><a href=\"#文件系统和虚拟文件系统交换（VFS）\" class=\"headerlink\" title=\"文件系统和虚拟文件系统交换（VFS）\"></a>文件系统和虚拟文件系统交换（VFS）</h1><p>标签（空格分隔）： 《OSX&amp;iOS内核》 读书笔记</p>\n<hr>\n<p>##硬盘分区</p>\n<h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciudifejb0005fc04nd857ijl","category_id":"ciudifej40003fc04p97w3d3r","_id":"ciudifejl000afc048l6m61c0"},{"post_id":"ciudifejb0005fc04nd857ijl","category_id":"ciudifejh0008fc04qegbs24u","_id":"ciudifejo000cfc04qpzp6l11"},{"post_id":"ciudifeiy0001fc047fixxiz1","category_id":"ciudifej40003fc04p97w3d3r","_id":"ciudifejp000dfc04qsh2qbk0"},{"post_id":"ciudifeiy0001fc047fixxiz1","category_id":"ciudifejh0008fc04qegbs24u","_id":"ciudifejr000ffc043gr5n2wg"},{"post_id":"ciudifej10002fc04hg63bc4h","category_id":"ciudifej40003fc04p97w3d3r","_id":"ciudifejr000gfc04arfnz1dz"},{"post_id":"ciudifej10002fc04hg63bc4h","category_id":"ciudifejh0008fc04qegbs24u","_id":"ciudifejs000hfc04cr0pzfvh"},{"post_id":"ciudifej60004fc04q7ld6mj8","category_id":"ciudifej40003fc04p97w3d3r","_id":"ciudifejs000ifc04122xvacd"},{"post_id":"ciudifej60004fc04q7ld6mj8","category_id":"ciudifejh0008fc04qegbs24u","_id":"ciudifejs000jfc04igyg0hh9"},{"post_id":"ciudifek2000nfc04ndhyzzlb","category_id":"ciudifej40003fc04p97w3d3r","_id":"ciudifek5000ofc04efxomgqw"},{"post_id":"ciudifek2000nfc04ndhyzzlb","category_id":"ciudifejh0008fc04qegbs24u","_id":"ciudifek6000pfc0493twropb"}],"PostTag":[],"Tag":[]}}