{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"e8fb451e951e21d510910b4588a987c40290e2d7","modified":1476675545000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1476674939000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1476674939000},{"_id":"themes/next/.git","hash":"042ff34da0707513a5681580b37513c890c671ef","modified":1476674939000},{"_id":"themes/next/.gitignore","hash":"c8d6a73b9e17f0f8a3716e4ada6960d3180425a6","modified":1476674939000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1476674939000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1476674939000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1476674939000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1476674939000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1476674939000},{"_id":"themes/next/_config.yml","hash":"c09b4278d68b7d39cbc37c8a33b444258f282822","modified":1476501011000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1476674939000},{"_id":"themes/next/gulpfile.coffee","hash":"d267332ec1461042fb16a9cb0737e1555fb4b79e","modified":1476674939000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1476674939000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1476529038000},{"_id":"source/_posts/Building xnu for OS X 10.11 El Capitan.md","hash":"cb0610d84caaae921c1412454e52df0f61417f4b","modified":1476676347000},{"_id":"source/_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","hash":"9e26be70b2e590fbb39aff0519a342f72f070fc7","modified":1476675868000},{"_id":"source/_posts/H5的体验优化.md","hash":"a6eaaadd1b10072978ed924b168150c77afa8300","modified":1476677413000},{"_id":"source/_posts/Mach-O格式文件(用户态下的进程加载).md","hash":"6617d58a862a0403cbe040260bdd9e073b277f4b","modified":1476676923000},{"_id":"source/_posts/Mach原语：一起以消息为媒介.md","hash":"b4601b768984c911d7f6dff2830232520f13c94a","modified":1476676881000},{"_id":"source/_posts/Mach调度.md","hash":"6fca7c6fda9997878c5437a707da1b7fde6debf9","modified":1476676908000},{"_id":"source/_posts/React Native笔记.md","hash":"1e023ff37c2daaa96f570405f9d74aba0482df4d","modified":1476677404000},{"_id":"source/_posts/Thrift的二进制数据编解码-以OC为例.md","hash":"ea971736db3cd9858857d9f2e1971dc996f6d49e","modified":1476533851000},{"_id":"source/_posts/iOS中的MAX-A-B-，需要注意的点.md","hash":"b5d581bd281ad1c19e52e7d40ea8faba21c8dd3c","modified":1476530655000},{"_id":"source/_posts/iOS引导页的镂空效果.md","hash":"a97a9c3d033784c1b47b86b58825bf27b897f927","modified":1476530949000},{"_id":"source/_posts/iOS支持懒加载的PageViewController.md","hash":"0459482711792b36c524def45100ac3acaef2f9a","modified":1476533611000},{"_id":"source/_posts/iOS签名.md","hash":"ead1d78c0ea39df0742c7db75d7fc7db14644012","modified":1472522466000},{"_id":"source/_posts/内核架构.md","hash":"bcaa328663c846ec60518b27606f63771fb88f43","modified":1476677328000},{"_id":"source/_posts/创建pod库的步骤.md","hash":"945e342f28e7cec38f5df4a682c7089352c85cca","modified":1476677365000},{"_id":"source/_posts/引导过程：EFI和iBoot.md","hash":"2bbe004654cf4a22fe40d4a53386cf5830ed1418","modified":1476676127000},{"_id":"source/_posts/文件系统和虚拟文件系统交换（VFS）.md","hash":"7b743b4d03b0e471c6754e9c6fc9b70fc888e862","modified":1476676176000},{"_id":"source/_posts/由生到死--内核引导和内核崩溃.md","hash":"37919029e0999840425429261b3790c19a0850f8","modified":1476676195000},{"_id":"source/_posts/简约的iOS音乐播放UI控件.md","hash":"5f61f73f32bedcb2b28274cbd73ac0c206c8523d","modified":1476531344000},{"_id":"source/_posts/网络七层协议（结合操作系统来了解）.md","hash":"7f2812bc1914c1d73886fb1c4f10f8557b143be5","modified":1476676218000},{"_id":"source/_posts/读书笔记之《如何阅读一本书》.md","hash":"2999777369bdd7c3134734f9727fafba2be63913","modified":1476676295000},{"_id":"source/_posts/贯穿始终-launchd.md","hash":"ed3596ef14724ab2abc5a016aa15d1f4099ce37f","modified":1476676318000},{"_id":"source/categories/index.md","hash":"6c08bfbf9f2886cb743d160ea4cfb7d49eb93180","modified":1476677263000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1476675435000},{"_id":"source/tags/index.md","hash":"24d4749d12b9eeb9d94b622d1082ffded236272a","modified":1476677252000},{"_id":"source/images/avatar.jpg","hash":"36db1779bb7cccbd55d8af4c52db5623815a26f4","modified":1476675371000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1476674939000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1476674939000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1476674939000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1476674939000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1476674939000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1476674939000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1476674939000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1476674939000},{"_id":"themes/next/languages/ko.yml","hash":"ce8b047c89daae77c03482fc76f16ffec6bdbf2d","modified":1476674939000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1476674939000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1476674939000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1476674939000},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1476674939000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1476674939000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1476674939000},{"_id":"themes/next/layout/_layout.swig","hash":"cfb04083ccde8c0a7749c1a4ac39327f69c84863","modified":1476674939000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1476674939000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1476674939000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1476674939000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1476674939000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1476674939000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1476674939000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1476674939000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1476674939000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1476674939000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1476674939000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"bc311e9f4333188da5c9c721ae467ba14410d5b2","modified":1476674939000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1476674939000},{"_id":"themes/next/layout/_macro/post.swig","hash":"ea40d388ae190e2228cbe54f054be621e3fa061c","modified":1476674939000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"084867c289c95c5ebc18435a3b2092091bb8e2ba","modified":1476674939000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1476674939000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1476674939000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"58fd826ca75b0cbc48b61a58da4b841e2fa34403","modified":1476674939000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1476674939000},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1476674939000},{"_id":"themes/next/layout/_partials/head.swig","hash":"06b6604176367af52587312e2575b52ecf53c3d9","modified":1476674939000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1476674939000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1476674939000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1476674939000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1476674939000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1476674939000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1476674939000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1476674939000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1476674939000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1476674939000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1476674939000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1476674939000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1476674939000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1476674939000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1476674939000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1476674939000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1476674939000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1476674939000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1476674939000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1476674939000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1476674939000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1476674939000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1476674939000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1476674939000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1476674939000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1476674939000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1476674939000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"60a51a33416e2b86ac9fbefc86b80f2f5f60e1c0","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1476674939000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1476674939000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1476674939000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1476674939000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1476674939000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"9a13073ae239ac0c8a35c5d8cf77b706c10f58c2","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1476674939000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1476674939000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1476674939000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1476674939000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1476674939000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1476674939000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1476674939000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1476674939000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1476674939000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1476674939000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1476674939000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1476674939000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1476674939000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1476674939000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1476674939000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1476674939000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e533b70f281275357fce083422e5d26bbf69d543","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1476674939000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1476674939000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1476674939000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1476674939000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1476674939000},{"_id":"public/categories/index.html","hash":"cf95cf7542a920a418d7000a2cf470d9f49e0daa","modified":1476678908195},{"_id":"public/tags/index.html","hash":"44456ac4857c1c57e7120a81297ac35dd764868c","modified":1476678908195},{"_id":"public/archives/page/3/index.html","hash":"a4b9d75d869a801223e88a1e04e6b313c160f9dd","modified":1476678908196},{"_id":"public/archives/2016/page/3/index.html","hash":"a230ffaf02b347a1b2526225bde99c8bd5ab9370","modified":1476678908196},{"_id":"public/archives/2016/04/index.html","hash":"2db7deb5c42f15228f71a6956b70259c851c71e4","modified":1476678908196},{"_id":"public/archives/2016/05/index.html","hash":"0ba201e603784632696d59b8dddf528e14fc8d28","modified":1476678908196},{"_id":"public/archives/2016/07/index.html","hash":"dda62f37ab857f8cef31187eec17b7bb72fdaad9","modified":1476678908197},{"_id":"public/archives/2016/08/index.html","hash":"776f5b1f3d3a9123d830099a442b71ae34c83004","modified":1476678908197},{"_id":"public/archives/2016/09/index.html","hash":"3fcc2efdc47e0bc2dc71f91c050c498b45ef72cc","modified":1476678908197},{"_id":"public/categories/Apple-Development/index.html","hash":"1dc5d066571fba938ca8932ad8997f97e5acd657","modified":1476678908197},{"_id":"public/categories/Apple-Development/page/2/index.html","hash":"20742ab90f358b27b7714859d93b8910be201c64","modified":1476678908197},{"_id":"public/categories/Web/index.html","hash":"fa69b0f5475e8468ba0854a4e2725b53a20cd047","modified":1476678908197},{"_id":"public/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/index.html","hash":"c7931afc54cf20109eaf136e5513ad04c47ffe92","modified":1476678908197},{"_id":"public/categories/Apple-Development/iOS开发笔记/index.html","hash":"a6eaca5f273577cdfe420bf2f4df5f0831cd7174","modified":1476678908197},{"_id":"public/categories/JS/index.html","hash":"7914f2d5fe9d723bc001658eb7bf7315a6783e5c","modified":1476678908197},{"_id":"public/categories/Apple-Development/深入解析Mac-OS-X-iOS操作系统笔记/内核/index.html","hash":"131a5877b190c21202ddd8261117d9d96ca04f06","modified":1476678908197},{"_id":"public/categories/方法论/index.html","hash":"c81313aff09063ece350467b0b7e13351821f452","modified":1476678908197},{"_id":"public/categories/JS/React-Native/index.html","hash":"532da235534053d767848a3f7543526fffa498e7","modified":1476678908197},{"_id":"public/tags/内核/index.html","hash":"4e6ff222602402b8533c5413967a538a53e09ab6","modified":1476678908197},{"_id":"public/tags/编译/index.html","hash":"0cd87cd9282cb2403d876ec80702d31ebed7ba8a","modified":1476678908198},{"_id":"public/tags/H5/index.html","hash":"07f26c789b3812c2c8199e0eab42a0ae8a772508","modified":1476678908198},{"_id":"public/tags/JS/index.html","hash":"c890676aa42c79b297815e97c3362b8a4f20f5ef","modified":1476678908198},{"_id":"public/tags/Mach/index.html","hash":"ea3b6ebb2e883f42d15bc38d705ee93be0fbe89d","modified":1476678908198},{"_id":"public/tags/React/index.html","hash":"b0216e71f741a8faaca4cb89999e370f85efcf94","modified":1476678908198},{"_id":"public/tags/Cocoapods/index.html","hash":"ac6f106dd1d2aa998cdb1a08c138fdf45155f84d","modified":1476678908198},{"_id":"public/tags/学习方法/index.html","hash":"2b0426d5703846f04d59694f7aaf385cfa5706cb","modified":1476678908198},{"_id":"public/tags/launchd/index.html","hash":"ec379d6716a3b58b109b1d17c7859434cbccd423","modified":1476678908198},{"_id":"public/2016/09/16/Mach-O格式文件(用户态下的进程加载)/index.html","hash":"a461d34fb87a2c1b4622be3b5581dd8ce4741842","modified":1476678908198},{"_id":"public/2016/09/11/Mach原语：一起以消息为媒介/index.html","hash":"03de4571195ac617d0577f32cc037948803d2985","modified":1476678908198},{"_id":"public/2016/09/08/Building xnu for OS X 10.11 El Capitan/index.html","hash":"35e1f6fa1891cf6ceff289209258115791075ce7","modified":1476678908198},{"_id":"public/2016/09/07/由生到死--内核引导和内核崩溃/index.html","hash":"711e45d8391cf7e6ef3560c6a33cbd8041ad9633","modified":1476678908198},{"_id":"public/2016/09/04/内核架构/index.html","hash":"6de4c6eedf42ac3029ad72988ccec441d0e85a81","modified":1476678908198},{"_id":"public/2016/09/02/贯穿始终-launchd/index.html","hash":"3df0e3989ee49b095888ee7f0404fad2813a4913","modified":1476678908199},{"_id":"public/2016/09/02/iOS支持懒加载的PageViewController/index.html","hash":"a309129465cef968e23cef1cda28496672e46637","modified":1476678908199},{"_id":"public/2016/09/01/引导过程：EFI和iBoot/index.html","hash":"583cb73c382e46cd4f1f08171273b0ff42398292","modified":1476678908199},{"_id":"public/2016/08/30/Mach调度/index.html","hash":"9ff285e4de606d1eda5092604c7721c2305f5024","modified":1476678908199},{"_id":"public/2016/08/30/文件系统和虚拟文件系统交换（VFS）/index.html","hash":"7e1420fe5a07481dda2b7071c3e7765b5e18c68e","modified":1476678908199},{"_id":"public/2016/08/30/React Native笔记/index.html","hash":"67c90efab09dc4e591afa7a387d1e872ca64f9c5","modified":1476678908199},{"_id":"public/2016/08/30/网络七层协议（结合操作系统来了解）/index.html","hash":"8f3512af577455b16ed332da7d61be4f6914f91d","modified":1476678908199},{"_id":"public/2016/08/30/H5的体验优化/index.html","hash":"0e5b84d83ef1d19fcdb1c0d2da072863430bd2b1","modified":1476678908199},{"_id":"public/2016/08/30/创建pod库的步骤/index.html","hash":"aa7f5e02b98e33534d8a5b946056ce9f2bd8704e","modified":1476678908199},{"_id":"public/2016/08/30/iOS签名/index.html","hash":"574649ad9488e2b41233db255b639ebd98191d41","modified":1476678908200},{"_id":"public/2016/08/30/读书笔记之《如何阅读一本书》/index.html","hash":"99cc6fb70860af05cdb5d08f6b1a3cb3882774b3","modified":1476678908200},{"_id":"public/2016/07/09/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？/index.html","hash":"77f81b20f2caabb82bd558e1ad7c353e16e30fa8","modified":1476678908200},{"_id":"public/2016/05/24/简约的iOS音乐播放UI控件/index.html","hash":"3ac49b4430f601670e4896b5b11c9b2c8b1a3a91","modified":1476678908200},{"_id":"public/2016/04/29/iOS引导页的镂空效果/index.html","hash":"9e2986b21707ca463d14eb954c0eab4c02c2c7ee","modified":1476678908200},{"_id":"public/2016/04/19/iOS中的MAX-A-B-，需要注意的点/index.html","hash":"cf5ac9a97354fb8273b57c82e1d0ec252281ba37","modified":1476678908200},{"_id":"public/2016/04/16/Thrift的二进制数据编解码-以OC为例/index.html","hash":"2538fd9a05c8386fb944b3a16126d3705b2c050f","modified":1476678908200},{"_id":"public/archives/index.html","hash":"7c652c141602192a3e1d2286949e1e386c571495","modified":1476678908201},{"_id":"public/archives/page/2/index.html","hash":"c0b47b8f32ad014b4cefc08fb896b82d6360c78d","modified":1476678908201},{"_id":"public/archives/2016/index.html","hash":"f60a8b3328c278248c0fcfc0f586b5f2e43c7b8c","modified":1476678908201},{"_id":"public/archives/2016/page/2/index.html","hash":"28b6561ce2d0526ff0bdc2114b6dbdfbfb4a324c","modified":1476678908201},{"_id":"public/index.html","hash":"283fcf66046dda30b983cc48e440aac7212be055","modified":1476678908201},{"_id":"public/page/2/index.html","hash":"84c1339ea4b9061bd07febe879b9c9051fd26891","modified":1476678908201},{"_id":"public/page/3/index.html","hash":"24beb3211b1a0ad0f9664a804361e55173383118","modified":1476678908201},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1476678908217},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1476678908217},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1476678908218},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1476678908218},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1476678908218},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1476678908218},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1476678908218},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1476678908218},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1476678908218},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1476678908218},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1476678908218},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1476678908218},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1476678908218},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1476678908218},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1476678908218},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1476678908218},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1476678908218},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1476678908219},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1476678908219},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1476678908219},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1476678908219},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1476678908219},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1476678908219},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1476678908219},{"_id":"public/images/avatar.jpg","hash":"36db1779bb7cccbd55d8af4c52db5623815a26f4","modified":1476678909072},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1476678909073},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1476678909081},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1476678909081},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1476678909087},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1476678909087},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1476678909087},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1476678909087},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1476678909088},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1476678909088},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1476678909088},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1476678909088},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1476678909088},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1476678909088},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1476678909088},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1476678909088},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1476678909088},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1476678909088},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1476678909088},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1476678909088},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1476678909088},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1476678909088},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1476678909088},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1476678909088},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1476678909088},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1476678909088},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1476678909088},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1476678909088},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1476678909088},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1476678909089},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1476678909089},{"_id":"public/css/main.css","hash":"d6d4ba71e50fb9de41a07bdc0ec06d7e5c995982","modified":1476678909089},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1476678909089},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1476678909089},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1476678909089},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1476678909089},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1476678909089},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1476678909089},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1476678909089},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1476678909089},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1476678909089},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1476678909089},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1476678909110}],"Category":[{"name":"Apple Development","_id":"ciudkhr0q0003gv04k5axk36y"},{"name":"Web","_id":"ciudkhr1b000cgv042v24pvmr"},{"name":"深入解析Mac OS X && iOS操作系统笔记","parent":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr1f000igv04h2hwsw6l"},{"name":"iOS开发笔记","parent":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr1z0014gv042txb1a06"},{"name":"JS","_id":"ciudkhr29001bgv04iew6eaej"},{"name":"内核","parent":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr2q0020gv04vw875jnv"},{"name":"方法论","_id":"ciudkhr36002zgv04lmmoa2lp"},{"name":"React Native","parent":"ciudkhr29001bgv04iew6eaej","_id":"ciudkhr360032gv04ed9xbn5z"}],"Data":[],"Page":[{"title":"categories","date":"2016-10-17T04:04:17.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-10-17 12:04:17\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-10-17T04:07:43.000Z","path":"categories/index.html","layout":"page","_id":"ciudkhr0j0001gv04vuvkexns","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-10-17T04:04:24.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-10-17 12:04:24\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-10-17T04:07:32.000Z","path":"tags/index.html","layout":"page","_id":"ciudkhr3z003kgv04rpk24q41","content":"","excerpt":"","more":""}],"Post":[{"title":"Building xnu for OS X 10.11 El Capitan","_content":"\n\n*此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份。*\n\nThe OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: [here](https://opensource.apple.com/source/xnu/xnu-3247.1.106/)\n\nBuilding xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:\n\n1. Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with \"sudo xcodebuild -license\"\n2. Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself\n\n\t```\n    $ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz\n\t```\n    \n3. Build and install CTF tools from dtrace\n\n\t```\n    $ tar zxf dtrace-168.tar.gz\n    $ cd dtrace-168\n    $ mkdir -p obj sym dst\n    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=\"x86_64\" SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    ...\n    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain\n    Password:\n    $ cd ..\n\t```    \n\n4. Install AvailabilityVersions\n\n\t```\n    $ tar zxf AvailabilityVersions-20.tar.gz \n    $ cd AvailabilityVersions-20\n    $ mkdir -p dst\n    $ make install SRCROOT=$PWD DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst/usr/local `xcrun -sdk macosx -show-sdk-path`/usr/local\n    $ cd ..\n\t```\n\n5. Build xnu\n\n\t```\n    $ tar zxf xnu-3247.1.106.tar.gz\n    $ cd xnu-3247.1.106\n    $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\n\t```\n\n**See xnu's top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**\n\nUpdate: If you are attempting to add system calls, you may also need to build Libsyscall.\n\n1. Download the Libsystem source\n\n\t```\n\t$ curl -O https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\n\t```\n\n2. Install Libsystem headers\n\n\t```\n    $ tar zxf Libsystem-1225.1.1.tar.gz\n    $ cd Libsystem-1225.1.1\n    $ xcodebuild installhdrs -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst `xcrun -sdk macosx -show-sdk-path`\n    $ cd ..\n    ```\n3. Install xnu and Libsyscall headers\n\t\n\t```\n    $ cd xnu-3247.1.106\n    $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst\n    $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo ditto BUILD.hdrs/dst `xcrun -sdk macosx -show-sdk-path`\n    ```\n4. Build Libsyscall\n\n\t```\n    $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst\n    $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst\n    ```\n5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).\n\n6. To install the resulting new binaries, execute:\n  \t1. xnu: \n\t\n\t\t```\n\t    $ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n\t    $ sudo kextcache -invalidate /\n\t    / locked; waiting for lock.\n\t    Lock acquired; proceeding.\n\t    ...\n\t    $ sudo reboot\n   \t\t ```\n  \t2. Libsyscall: \n\t\t\n\t\t```\n        $ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n\t    $ sudo update_dyld_shared_cache\n\t    ...\n\t    $ sudo reboot\n    \t```\n\n---\n[1]: http://shantonu.blogspot.co.uk","source":"_posts/Building xnu for OS X 10.11 El Capitan.md","raw":"---\ntitle: Building xnu for OS X 10.11 El Capitan\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n - 编译\n---\n\n\n*此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份。*\n\nThe OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: [here](https://opensource.apple.com/source/xnu/xnu-3247.1.106/)\n\nBuilding xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:\n\n1. Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with \"sudo xcodebuild -license\"\n2. Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself\n\n\t```\n    $ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz\n\t```\n    \n3. Build and install CTF tools from dtrace\n\n\t```\n    $ tar zxf dtrace-168.tar.gz\n    $ cd dtrace-168\n    $ mkdir -p obj sym dst\n    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=\"x86_64\" SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    ...\n    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain\n    Password:\n    $ cd ..\n\t```    \n\n4. Install AvailabilityVersions\n\n\t```\n    $ tar zxf AvailabilityVersions-20.tar.gz \n    $ cd AvailabilityVersions-20\n    $ mkdir -p dst\n    $ make install SRCROOT=$PWD DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst/usr/local `xcrun -sdk macosx -show-sdk-path`/usr/local\n    $ cd ..\n\t```\n\n5. Build xnu\n\n\t```\n    $ tar zxf xnu-3247.1.106.tar.gz\n    $ cd xnu-3247.1.106\n    $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\n\t```\n\n**See xnu's top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**\n\nUpdate: If you are attempting to add system calls, you may also need to build Libsyscall.\n\n1. Download the Libsystem source\n\n\t```\n\t$ curl -O https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\n\t```\n\n2. Install Libsystem headers\n\n\t```\n    $ tar zxf Libsystem-1225.1.1.tar.gz\n    $ cd Libsystem-1225.1.1\n    $ xcodebuild installhdrs -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst `xcrun -sdk macosx -show-sdk-path`\n    $ cd ..\n    ```\n3. Install xnu and Libsyscall headers\n\t\n\t```\n    $ cd xnu-3247.1.106\n    $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst\n    $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo ditto BUILD.hdrs/dst `xcrun -sdk macosx -show-sdk-path`\n    ```\n4. Build Libsyscall\n\n\t```\n    $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst\n    $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst\n    ```\n5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).\n\n6. To install the resulting new binaries, execute:\n  \t1. xnu: \n\t\n\t\t```\n\t    $ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n\t    $ sudo kextcache -invalidate /\n\t    / locked; waiting for lock.\n\t    Lock acquired; proceeding.\n\t    ...\n\t    $ sudo reboot\n   \t\t ```\n  \t2. Libsyscall: \n\t\t\n\t\t```\n        $ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n\t    $ sudo update_dyld_shared_cache\n\t    ...\n\t    $ sudo reboot\n    \t```\n\n---\n[1]: http://shantonu.blogspot.co.uk","slug":"Building xnu for OS X 10.11 El Capitan","published":1,"date":"2016-09-08T02:36:41.000Z","updated":"2016-10-17T03:52:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr0e0000gv04xl8v8f8t","content":"<p><em>此文只因为国内浏览<a href=\"http://shantonu.blogspot.co.uk\" target=\"_blank\" rel=\"external\">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>\n<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href=\"https://opensource.apple.com/source/xnu/xnu-3247.1.106/\" target=\"_blank\" rel=\"external\">here</a></p>\n<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>\n<ol>\n<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>\n<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>Build and install CTF tools from dtrace</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    $ tar zxf dtrace-168.tar.gz</div><div class=\"line\">    $ cd dtrace-168</div><div class=\"line\">    $ mkdir -p obj sym dst</div><div class=\"line\">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class=\"line\">    ...</div><div class=\"line\">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class=\"line\">    Password:</div><div class=\"line\">    $ cd ..</div><div class=\"line\">\t```    </div><div class=\"line\"></div><div class=\"line\">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>\n<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. Build xnu</div></pre></td></tr></table></figure>\n<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**</div><div class=\"line\"></div><div class=\"line\">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class=\"line\"></div><div class=\"line\">1. Download the Libsystem source</div></pre></td></tr></table></figure>\n<p> $ curl -O <a href=\"https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\" target=\"_blank\" rel=\"external\">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">2. Install Libsystem headers</div></pre></td></tr></table></figure>\n<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>\n<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">4. Build Libsyscall</div></pre></td></tr></table></figure>\n<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class=\"line\"></div><div class=\"line\">6. To install the resulting new binaries, execute:</div><div class=\"line\">  \t1. xnu:</div></pre></td></tr></table></figure>\n<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n$ sudo kextcache -invalidate /\n/ locked; waiting for lock.\nLock acquired; proceeding.\n...\n$ sudo reboot\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2. Libsyscall:</div></pre></td></tr></table></figure>\n\n$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n$ sudo update_dyld_shared_cache\n...\n$ sudo reboot\n```\n</code></pre></li>\n</ol>\n<hr>\n","excerpt":"","more":"<p><em>此文只因为国内浏览<a href=\"http://shantonu.blogspot.co.uk\">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>\n<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href=\"https://opensource.apple.com/source/xnu/xnu-3247.1.106/\">here</a></p>\n<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>\n<ol>\n<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>\n<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>Build and install CTF tools from dtrace</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    $ tar zxf dtrace-168.tar.gz</div><div class=\"line\">    $ cd dtrace-168</div><div class=\"line\">    $ mkdir -p obj sym dst</div><div class=\"line\">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class=\"line\">    ...</div><div class=\"line\">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class=\"line\">    Password:</div><div class=\"line\">    $ cd ..</div><div class=\"line\">\t```    </div><div class=\"line\"></div><div class=\"line\">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>\n<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. Build xnu</div></pre></td></tr></table></figure>\n<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**</div><div class=\"line\"></div><div class=\"line\">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class=\"line\"></div><div class=\"line\">1. Download the Libsystem source</div></pre></td></tr></table></figure>\n<p> $ curl -O <a href=\"https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">2. Install Libsystem headers</div></pre></td></tr></table></figure>\n<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>\n<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">4. Build Libsyscall</div></pre></td></tr></table></figure>\n<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class=\"line\"></div><div class=\"line\">6. To install the resulting new binaries, execute:</div><div class=\"line\">  \t1. xnu:</div></pre></td></tr></table></figure>\n<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n$ sudo kextcache -invalidate /\n/ locked; waiting for lock.\nLock acquired; proceeding.\n...\n$ sudo reboot\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2. Libsyscall:</div></pre></td></tr></table></figure>\n\n$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n$ sudo update_dyld_shared_cache\n...\n$ sudo reboot\n```\n</code></pre></li>\n</ol>\n<hr>\n"},{"title":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","date":"2016-07-09T06:22:30.000Z","_content":"\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n## KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","source":"_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","raw":"---\ntitle: KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\ndate: 2016-07-09 14:22:30\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n## KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","slug":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","published":1,"updated":"2016-10-17T03:44:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr0l0002gv043gvygz15","content":"<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<h2 id=\"KVO是元凶\"><a href=\"#KVO是元凶\" class=\"headerlink\" title=\"KVO是元凶\"></a>KVO是元凶</h2><ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<h2 id=\"KVO是元凶\"><a href=\"#KVO是元凶\" class=\"headerlink\" title=\"KVO是元凶\"></a>KVO是元凶</h2><ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n"},{"title":"H5的体验优化","_content":"\n## H5跟Native的性能对比\n- native可以做缓存，第二次访问可以实现秒开。\n- 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。\n- webView的加载需要耗时，网络建立连接也需要时间。\n\n## 未采用的优化H5的方案\n- 离线包+预加载。\n缺点：\n1. 主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。\n2. 离线包发布效率低下。\n3. 由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。\n\n## 比较好的优化方案\n1. 由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。\n2. 将HTTP改成了Socket。\n3. 通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。\n\n## 进一步优化\n1. H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。\n2. 模板也需要制定一套更新的机制。\n\n## React Native\n- 针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。\n\n要点提炼自：[QQ空间面向移动时代Hybrid架构设计][1]\n[1]: http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650993637&idx=1&sn=8a2673272575abbef4b0f6dbc25e0186&scene=0#wechat_redirect\n","source":"_posts/H5的体验优化.md","raw":"---\ntitle: H5的体验优化\ncategories: \n - Web \ntags:\n - H5\n - JS\n---\n\n## H5跟Native的性能对比\n- native可以做缓存，第二次访问可以实现秒开。\n- 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。\n- webView的加载需要耗时，网络建立连接也需要时间。\n\n## 未采用的优化H5的方案\n- 离线包+预加载。\n缺点：\n1. 主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。\n2. 离线包发布效率低下。\n3. 由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。\n\n## 比较好的优化方案\n1. 由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。\n2. 将HTTP改成了Socket。\n3. 通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。\n\n## 进一步优化\n1. H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。\n2. 模板也需要制定一套更新的机制。\n\n## React Native\n- 针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。\n\n要点提炼自：[QQ空间面向移动时代Hybrid架构设计][1]\n[1]: http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650993637&idx=1&sn=8a2673272575abbef4b0f6dbc25e0186&scene=0#wechat_redirect\n","slug":"H5的体验优化","published":1,"date":"2016-08-30T02:04:48.000Z","updated":"2016-10-17T04:10:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr0t0005gv04b4mnbt3g","content":"<h2 id=\"H5跟Native的性能对比\"><a href=\"#H5跟Native的性能对比\" class=\"headerlink\" title=\"H5跟Native的性能对比\"></a>H5跟Native的性能对比</h2><ul>\n<li>native可以做缓存，第二次访问可以实现秒开。</li>\n<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>\n<li>webView的加载需要耗时，网络建立连接也需要时间。</li>\n</ul>\n<h2 id=\"未采用的优化H5的方案\"><a href=\"#未采用的优化H5的方案\" class=\"headerlink\" title=\"未采用的优化H5的方案\"></a>未采用的优化H5的方案</h2><ul>\n<li>离线包+预加载。<br>缺点：</li>\n</ul>\n<ol>\n<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>\n<li>离线包发布效率低下。</li>\n<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>\n</ol>\n<h2 id=\"比较好的优化方案\"><a href=\"#比较好的优化方案\" class=\"headerlink\" title=\"比较好的优化方案\"></a>比较好的优化方案</h2><ol>\n<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>\n<li>将HTTP改成了Socket。</li>\n<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>\n</ol>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><ol>\n<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>\n<li>模板也需要制定一套更新的机制。</li>\n</ol>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>\n</ul>\n<p>要点提炼自：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">QQ空间面向移动时代Hybrid架构设计</a></p>\n","excerpt":"","more":"<h2 id=\"H5跟Native的性能对比\"><a href=\"#H5跟Native的性能对比\" class=\"headerlink\" title=\"H5跟Native的性能对比\"></a>H5跟Native的性能对比</h2><ul>\n<li>native可以做缓存，第二次访问可以实现秒开。</li>\n<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>\n<li>webView的加载需要耗时，网络建立连接也需要时间。</li>\n</ul>\n<h2 id=\"未采用的优化H5的方案\"><a href=\"#未采用的优化H5的方案\" class=\"headerlink\" title=\"未采用的优化H5的方案\"></a>未采用的优化H5的方案</h2><ul>\n<li>离线包+预加载。<br>缺点：</li>\n</ul>\n<ol>\n<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>\n<li>离线包发布效率低下。</li>\n<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>\n</ol>\n<h2 id=\"比较好的优化方案\"><a href=\"#比较好的优化方案\" class=\"headerlink\" title=\"比较好的优化方案\"></a>比较好的优化方案</h2><ol>\n<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>\n<li>将HTTP改成了Socket。</li>\n<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>\n</ol>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><ol>\n<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>\n<li>模板也需要制定一套更新的机制。</li>\n</ol>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>\n</ul>\n<p>要点提炼自：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect\">QQ空间面向移动时代Hybrid架构设计</a></p>\n"},{"title":"Mach-O格式文件(用户态下的进程加载)","_content":"\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mach-O格式文件(用户态下的进程加载).md","raw":"---\ntitle: Mach-O格式文件(用户态下的进程加载)\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n - Mach\n---\n\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mach-O格式文件(用户态下的进程加载)","published":1,"date":"2016-09-16T03:07:52.000Z","updated":"2016-10-17T04:02:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr0x0006gv04z7bbwagj","content":"<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"Mach原语：一起以消息为媒介","_content":"\n## 1. Mach概述\n### 1.1 Mach设计原则\n- 在Mach中所有东西（Task、线程、虚拟内存等））都是对象。\n- 对象与对象之间通信**只能**通过端口收发消息。\n\n### 1.2 Mach设计目标\n内核为了保持极简，只做如下的事情：\n\n- “控制点”或执行单元的管理。\n- 线程或线程组（Task）的资源分配。\n- 虚拟内存的分配和管理。\n- 底层物理资源--即CPU、内存和任何物理设备的分配。\n\n## 2. Mach消息\n### 2.1 简单消息\n最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：\n\n```\ntypedef\tstruct \n{\n  mach_msg_bits_t\tmsgh_bits;//标志位\n  mach_msg_size_t\tmsgh_size;//大小\n  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）\n  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）\n  mach_port_name_t\tmsgh_voucher_port;\n  mach_msg_id_t\t\tmsgh_id;\n} mach_msg_header_t; //消息头\n\ntypedef struct\n{\n        mach_msg_size_t msgh_descriptor_count;\n} mach_msg_body_t;//消息体\n\ntypedef struct\n{\n        mach_msg_header_t       header;\n        mach_msg_body_t         body;\n} mach_msg_base_t; //基本消息\n\ntypedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型\n\ntypedef struct \n{\n  mach_msg_trailer_type_t\tmsgh_trailer_type;\n  mach_msg_trailer_size_t\tmsgh_trailer_size;\n} mach_msg_trailer_t; //消息尾\n\n```\n\n### 2.2 复杂消息\n将消息头的标志位`mach_msg_bits_t`设置为`MACH_MSGH_BITS_COMPLEX`，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：\n\n```\ntypedef struct\n{\n  uint64_t\t\t\taddress;//数据的大小\n  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配\n  mach_msg_copy_options_t       copy: 8;//复制指令\n  unsigned int     \t\tpad1: 8;\n  mach_msg_descriptor_type_t    type: 8;\n  mach_msg_size_t       \tsize;//数据的大小\n} mach_msg_ool_descriptor64_t;\n\n```\n\n### 2.3 消息收发\n消息的收发在用户态都是通过如下方法进行的：\n\n```\nextern mach_msg_return_t\tmach_msg(\n\t\t\t\t\tmach_msg_header_t *msg,\n\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型\n\t\t\t\t\tmach_msg_size_t send_size,\n\t\t\t\t\tmach_msg_size_t rcv_size,\n\t\t\t\t\tmach_port_name_t rcv_name,\n\t\t\t\t\tmach_msg_timeout_t timeout,\n\t\t\t\t\tmach_port_name_t notify);\t\t\t\t\t\n```\n\n### 2.4 端口\n端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：\n\n```\nstruct ipc_port {\n\n\t/*\n\t * Initial sub-structure in common with ipc_pset\n\t * First element is an ipc_object second is a\n\t * message queue\n\t */\n\tstruct ipc_object ip_object;\n\tstruct ipc_mqueue ip_messages;\n\n\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */\n\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */\n\t\t  ip_impdonation:1,\t/* port supports importance donation */\n\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */\n\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */\n\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */\n\t\t  ip_reserved:2,\n\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */\n\n\tunion {\n\t\tstruct ipc_space *receiver;\n\t\tstruct ipc_port *destination;\n\t\tipc_port_timestamp_t timestamp;\n\t} data;\n\n\tunion {\n\t\tipc_kobject_t kobject;\n\t\tipc_importance_task_t imp_task;\n\t\tuintptr_t alias;\n\t} kdata;\n\t\t\n\tstruct ipc_port *ip_nsrequest;\n\tstruct ipc_port *ip_pdrequest;\n\tstruct ipc_port_request *ip_requests;\n\tstruct ipc_kmsg *ip_premsg;\n\n\tmach_vm_address_t ip_context;\n\n\tmach_port_mscount_t ip_mscount;\n\tmach_port_rights_t ip_srights;\n\tmach_port_rights_t ip_sorights;\n\n#if\tMACH_ASSERT\n#define\tIP_NSPARES\t\t4\n#define\tIP_CALLSTACK_MAX\t16\n/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */\n\tthread_t\tip_thread;\t/* who made me?  thread context */\n\tunsigned long\tip_timetrack;\t/* give an idea of \"when\" created */\n\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */\n\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */\n#endif\t/* MACH_ASSERT */\n} __attribute__((__packed__));\n\n```\n\n### 2.5 Mach接口生成器（MIG）\nMach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些`.defs`文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：\n![IG_opt.png][1]\n\n## 3. 深入IPC\n- Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。\n- 在用户态下，消息传递都是通过`mach_msg()`函数实现的，这个函数会触发一个mach陷阱`mach_msg_trap()`，接下来`mach_msg_trap()`又会调用`mach_msg_overwrite_trap()`，它会通过`MACH_SEND_MSG`和`MACH_RCV_MSG`来判断是发送操作，还是接收操作。\n- 期中内核态中还可以通过`mach_msg_receive()`和`mach_msg_send()`来收发数据。\n\n## 4. 同步原语\n### 4.1 锁的实现方式\n- **阻塞**：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。**当锁可用的时候**，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。\n- **忙等**：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。\n- **阻塞与忙等的对比**：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。\n\n### 4.2 互斥体(lck_mtx_t)（阻塞）\n- 互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。\n- 原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。\n\n### 4.3 信号量(semaphore_t)（阻塞）\n信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。\n\n### 4.4 自旋锁(hw_lock_t)（忙等）\n一种采用忙等形式的锁。\n### 4.5 读写锁(hw_lock_t)（阻塞）\n当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。\n\n### 4.6 锁集(lock_set_t)\n锁集就是锁的一个数组。\n\n## 5. 机器原语\n### 5.1 主机对象（Host）\n主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：\n\n```\nstruct\thost {\n\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */\n\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];\n\tstruct exception_action exc_actions[EXC_TYPES_COUNT];\n};\n```\n\n### 5.2 时钟对象（Clock）\nMach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是`clock_deadline_for_periodic_event（）`，调度器通过它设置了一个重复发生的通知--从而保证了多任务引擎的运转。\n\n### 5.3 处理器对象（Processer）\n在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给**处理器集**，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：\n\n```\nstruct processor {\n\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,\n\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */\n\tint\t\t\t\t\tstate;\t\t\t/* See below */\n\tboolean_t\t\tis_SMT;\n\tboolean_t\t\tis_recommended;\n\tstruct thread\n\t\t\t\t\t\t*active_thread,\t/* thread running on processor */\n\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */\n\t\t\t\t\t\t*idle_thread;\t/* this processor's idle thread. */\n\n\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */\n\n\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */\n\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */\n\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */\n\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */\n\n\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */\n\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */\n\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */\n\n\tuint64_t\t\t\tdeadline;\t\t/* current deadline */\n\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\trunq;\t\t\t/* runq for this processor */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */\n#endif\n#if defined(CONFIG_SCHED_GRRR)\n\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */\n#endif\n\n\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for\n\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer\n\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */\n\tprocessor_t\t\tprocessor_secondary;\n\tstruct ipc_port *\tprocessor_self;\t/* port for operations */\n\n\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */\n\tprocessor_data_t\tprocessor_data;\t/* per-processor data */\n};\n```\n其中最重要的是runq，这是分发到这个处理器的线程队列。\n\n### 5.3 处理器集\n处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：\n\n- `active_queue`：用于保存当前正在执行线程的CPU。\n- `idle_queue`：用于保存当前空闲的CPU（例如：正在执行`idle_thread`）。\n- `pset_runq`：保存了在这个集合中的所有CPU上执行的线程。\n\n`processor_set`的定义如下：\n\n```\nstruct processor_set {\n\tqueue_head_t\t\tactive_queue;\t/* active processors */\n\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */\n\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */\n\n\tint\t\t\t\t\tonline_processor_count;\n\n\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;\n\tint\t\t\t\t\tcpu_set_count;\n\n#if __SMP__\n\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\tpset_runq;      /* runq for this processor set */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\tpset_runq_bound_count;\n\t\t/* # of threads in runq bound to any processor in pset */\n#endif\n\n\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */\n\tuint64_t\t\t\tpending_AST_cpu_mask;\n#if defined(CONFIG_SCHED_DEFERRED_AST)\n\t/*\n\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on\n\t * some level of support for requesting an AST on a processor, and then quashing\n\t * that request later.\n\t *\n\t * The purpose of this field (and the associated codepaths) is to infer when we\n\t * no longer need a processor that is DISPATCHING to come up, and to prevent it\n\t * from coming out of IDLE if possible.  This should serve to decrease the number\n\t * of spurious ASTs in the system, and let processors spend longer periods in\n\t * IDLE.\n\t */\n\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;\n#endif\n\n\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */\n\tstruct ipc_port *\tpset_name_self;\t/* port for information */\n\n\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */\n\tpset_node_t\t\t\tnode;\n};\n```\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true","source":"_posts/Mach原语：一起以消息为媒介.md","raw":"---\ntitle: Mach原语：一起以消息为媒介\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - Mach\n---\n\n## 1. Mach概述\n### 1.1 Mach设计原则\n- 在Mach中所有东西（Task、线程、虚拟内存等））都是对象。\n- 对象与对象之间通信**只能**通过端口收发消息。\n\n### 1.2 Mach设计目标\n内核为了保持极简，只做如下的事情：\n\n- “控制点”或执行单元的管理。\n- 线程或线程组（Task）的资源分配。\n- 虚拟内存的分配和管理。\n- 底层物理资源--即CPU、内存和任何物理设备的分配。\n\n## 2. Mach消息\n### 2.1 简单消息\n最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：\n\n```\ntypedef\tstruct \n{\n  mach_msg_bits_t\tmsgh_bits;//标志位\n  mach_msg_size_t\tmsgh_size;//大小\n  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）\n  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）\n  mach_port_name_t\tmsgh_voucher_port;\n  mach_msg_id_t\t\tmsgh_id;\n} mach_msg_header_t; //消息头\n\ntypedef struct\n{\n        mach_msg_size_t msgh_descriptor_count;\n} mach_msg_body_t;//消息体\n\ntypedef struct\n{\n        mach_msg_header_t       header;\n        mach_msg_body_t         body;\n} mach_msg_base_t; //基本消息\n\ntypedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型\n\ntypedef struct \n{\n  mach_msg_trailer_type_t\tmsgh_trailer_type;\n  mach_msg_trailer_size_t\tmsgh_trailer_size;\n} mach_msg_trailer_t; //消息尾\n\n```\n\n### 2.2 复杂消息\n将消息头的标志位`mach_msg_bits_t`设置为`MACH_MSGH_BITS_COMPLEX`，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：\n\n```\ntypedef struct\n{\n  uint64_t\t\t\taddress;//数据的大小\n  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配\n  mach_msg_copy_options_t       copy: 8;//复制指令\n  unsigned int     \t\tpad1: 8;\n  mach_msg_descriptor_type_t    type: 8;\n  mach_msg_size_t       \tsize;//数据的大小\n} mach_msg_ool_descriptor64_t;\n\n```\n\n### 2.3 消息收发\n消息的收发在用户态都是通过如下方法进行的：\n\n```\nextern mach_msg_return_t\tmach_msg(\n\t\t\t\t\tmach_msg_header_t *msg,\n\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型\n\t\t\t\t\tmach_msg_size_t send_size,\n\t\t\t\t\tmach_msg_size_t rcv_size,\n\t\t\t\t\tmach_port_name_t rcv_name,\n\t\t\t\t\tmach_msg_timeout_t timeout,\n\t\t\t\t\tmach_port_name_t notify);\t\t\t\t\t\n```\n\n### 2.4 端口\n端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：\n\n```\nstruct ipc_port {\n\n\t/*\n\t * Initial sub-structure in common with ipc_pset\n\t * First element is an ipc_object second is a\n\t * message queue\n\t */\n\tstruct ipc_object ip_object;\n\tstruct ipc_mqueue ip_messages;\n\n\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */\n\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */\n\t\t  ip_impdonation:1,\t/* port supports importance donation */\n\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */\n\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */\n\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */\n\t\t  ip_reserved:2,\n\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */\n\n\tunion {\n\t\tstruct ipc_space *receiver;\n\t\tstruct ipc_port *destination;\n\t\tipc_port_timestamp_t timestamp;\n\t} data;\n\n\tunion {\n\t\tipc_kobject_t kobject;\n\t\tipc_importance_task_t imp_task;\n\t\tuintptr_t alias;\n\t} kdata;\n\t\t\n\tstruct ipc_port *ip_nsrequest;\n\tstruct ipc_port *ip_pdrequest;\n\tstruct ipc_port_request *ip_requests;\n\tstruct ipc_kmsg *ip_premsg;\n\n\tmach_vm_address_t ip_context;\n\n\tmach_port_mscount_t ip_mscount;\n\tmach_port_rights_t ip_srights;\n\tmach_port_rights_t ip_sorights;\n\n#if\tMACH_ASSERT\n#define\tIP_NSPARES\t\t4\n#define\tIP_CALLSTACK_MAX\t16\n/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */\n\tthread_t\tip_thread;\t/* who made me?  thread context */\n\tunsigned long\tip_timetrack;\t/* give an idea of \"when\" created */\n\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */\n\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */\n#endif\t/* MACH_ASSERT */\n} __attribute__((__packed__));\n\n```\n\n### 2.5 Mach接口生成器（MIG）\nMach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些`.defs`文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：\n![IG_opt.png][1]\n\n## 3. 深入IPC\n- Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。\n- 在用户态下，消息传递都是通过`mach_msg()`函数实现的，这个函数会触发一个mach陷阱`mach_msg_trap()`，接下来`mach_msg_trap()`又会调用`mach_msg_overwrite_trap()`，它会通过`MACH_SEND_MSG`和`MACH_RCV_MSG`来判断是发送操作，还是接收操作。\n- 期中内核态中还可以通过`mach_msg_receive()`和`mach_msg_send()`来收发数据。\n\n## 4. 同步原语\n### 4.1 锁的实现方式\n- **阻塞**：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。**当锁可用的时候**，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。\n- **忙等**：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。\n- **阻塞与忙等的对比**：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。\n\n### 4.2 互斥体(lck_mtx_t)（阻塞）\n- 互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。\n- 原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。\n\n### 4.3 信号量(semaphore_t)（阻塞）\n信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。\n\n### 4.4 自旋锁(hw_lock_t)（忙等）\n一种采用忙等形式的锁。\n### 4.5 读写锁(hw_lock_t)（阻塞）\n当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。\n\n### 4.6 锁集(lock_set_t)\n锁集就是锁的一个数组。\n\n## 5. 机器原语\n### 5.1 主机对象（Host）\n主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：\n\n```\nstruct\thost {\n\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */\n\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];\n\tstruct exception_action exc_actions[EXC_TYPES_COUNT];\n};\n```\n\n### 5.2 时钟对象（Clock）\nMach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是`clock_deadline_for_periodic_event（）`，调度器通过它设置了一个重复发生的通知--从而保证了多任务引擎的运转。\n\n### 5.3 处理器对象（Processer）\n在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给**处理器集**，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：\n\n```\nstruct processor {\n\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,\n\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */\n\tint\t\t\t\t\tstate;\t\t\t/* See below */\n\tboolean_t\t\tis_SMT;\n\tboolean_t\t\tis_recommended;\n\tstruct thread\n\t\t\t\t\t\t*active_thread,\t/* thread running on processor */\n\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */\n\t\t\t\t\t\t*idle_thread;\t/* this processor's idle thread. */\n\n\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */\n\n\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */\n\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */\n\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */\n\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */\n\n\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */\n\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */\n\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */\n\n\tuint64_t\t\t\tdeadline;\t\t/* current deadline */\n\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\trunq;\t\t\t/* runq for this processor */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */\n#endif\n#if defined(CONFIG_SCHED_GRRR)\n\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */\n#endif\n\n\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for\n\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer\n\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */\n\tprocessor_t\t\tprocessor_secondary;\n\tstruct ipc_port *\tprocessor_self;\t/* port for operations */\n\n\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */\n\tprocessor_data_t\tprocessor_data;\t/* per-processor data */\n};\n```\n其中最重要的是runq，这是分发到这个处理器的线程队列。\n\n### 5.3 处理器集\n处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：\n\n- `active_queue`：用于保存当前正在执行线程的CPU。\n- `idle_queue`：用于保存当前空闲的CPU（例如：正在执行`idle_thread`）。\n- `pset_runq`：保存了在这个集合中的所有CPU上执行的线程。\n\n`processor_set`的定义如下：\n\n```\nstruct processor_set {\n\tqueue_head_t\t\tactive_queue;\t/* active processors */\n\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */\n\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */\n\n\tint\t\t\t\t\tonline_processor_count;\n\n\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;\n\tint\t\t\t\t\tcpu_set_count;\n\n#if __SMP__\n\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\tpset_runq;      /* runq for this processor set */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\tpset_runq_bound_count;\n\t\t/* # of threads in runq bound to any processor in pset */\n#endif\n\n\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */\n\tuint64_t\t\t\tpending_AST_cpu_mask;\n#if defined(CONFIG_SCHED_DEFERRED_AST)\n\t/*\n\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on\n\t * some level of support for requesting an AST on a processor, and then quashing\n\t * that request later.\n\t *\n\t * The purpose of this field (and the associated codepaths) is to infer when we\n\t * no longer need a processor that is DISPATCHING to come up, and to prevent it\n\t * from coming out of IDLE if possible.  This should serve to decrease the number\n\t * of spurious ASTs in the system, and let processors spend longer periods in\n\t * IDLE.\n\t */\n\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;\n#endif\n\n\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */\n\tstruct ipc_port *\tpset_name_self;\t/* port for information */\n\n\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */\n\tpset_node_t\t\t\tnode;\n};\n```\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true","slug":"Mach原语：一起以消息为媒介","published":1,"date":"2016-09-11T09:05:13.000Z","updated":"2016-10-17T04:01:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr120007gv04esirki3w","content":"<h2 id=\"1-Mach概述\"><a href=\"#1-Mach概述\" class=\"headerlink\" title=\"1. Mach概述\"></a>1. Mach概述</h2><h3 id=\"1-1-Mach设计原则\"><a href=\"#1-1-Mach设计原则\" class=\"headerlink\" title=\"1.1 Mach设计原则\"></a>1.1 Mach设计原则</h3><ul>\n<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>\n<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>\n</ul>\n<h3 id=\"1-2-Mach设计目标\"><a href=\"#1-2-Mach设计目标\" class=\"headerlink\" title=\"1.2 Mach设计目标\"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>\n<ul>\n<li>“控制点”或执行单元的管理。</li>\n<li>线程或线程组（Task）的资源分配。</li>\n<li>虚拟内存的分配和管理。</li>\n<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>\n</ul>\n<h2 id=\"2-Mach消息\"><a href=\"#2-Mach消息\" class=\"headerlink\" title=\"2. Mach消息\"></a>2. Mach消息</h2><h3 id=\"2-1-简单消息\"><a href=\"#2-1-简单消息\" class=\"headerlink\" title=\"2.1 简单消息\"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef\tstruct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_bits_t\tmsgh_bits;//标志位</div><div class=\"line\">  mach_msg_size_t\tmsgh_size;//大小</div><div class=\"line\">  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class=\"line\">  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class=\"line\">  mach_port_name_t\tmsgh_voucher_port;</div><div class=\"line\">  mach_msg_id_t\t\tmsgh_id;</div><div class=\"line\">&#125; mach_msg_header_t; //消息头</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_size_t msgh_descriptor_count;</div><div class=\"line\">&#125; mach_msg_body_t;//消息体</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_header_t       header;</div><div class=\"line\">        mach_msg_body_t         body;</div><div class=\"line\">&#125; mach_msg_base_t; //基本消息</div><div class=\"line\"></div><div class=\"line\">typedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class=\"line\"></div><div class=\"line\">typedef struct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_trailer_type_t\tmsgh_trailer_type;</div><div class=\"line\">  mach_msg_trailer_size_t\tmsgh_trailer_size;</div><div class=\"line\">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-复杂消息\"><a href=\"#2-2-复杂消息\" class=\"headerlink\" title=\"2.2 复杂消息\"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">  uint64_t\t\t\taddress;//数据的大小</div><div class=\"line\">  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配</div><div class=\"line\">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class=\"line\">  unsigned int     \t\tpad1: 8;</div><div class=\"line\">  mach_msg_descriptor_type_t    type: 8;</div><div class=\"line\">  mach_msg_size_t       \tsize;//数据的大小</div><div class=\"line\">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>\n<h3 id=\"2-3-消息收发\"><a href=\"#2-3-消息收发\" class=\"headerlink\" title=\"2.3 消息收发\"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern mach_msg_return_t\tmach_msg(</div><div class=\"line\">\t\t\t\t\tmach_msg_header_t *msg,</div><div class=\"line\">\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t send_size,</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t rcv_size,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t rcv_name,</div><div class=\"line\">\t\t\t\t\tmach_msg_timeout_t timeout,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t notify);</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-端口\"><a href=\"#2-4-端口\" class=\"headerlink\" title=\"2.4 端口\"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ipc_port &#123;</div><div class=\"line\"></div><div class=\"line\">\t/*</div><div class=\"line\">\t * Initial sub-structure in common with ipc_pset</div><div class=\"line\">\t * First element is an ipc_object second is a</div><div class=\"line\">\t * message queue</div><div class=\"line\">\t */</div><div class=\"line\">\tstruct ipc_object ip_object;</div><div class=\"line\">\tstruct ipc_mqueue ip_messages;</div><div class=\"line\"></div><div class=\"line\">\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */</div><div class=\"line\">\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */</div><div class=\"line\">\t\t  ip_impdonation:1,\t/* port supports importance donation */</div><div class=\"line\">\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */</div><div class=\"line\">\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class=\"line\">\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */</div><div class=\"line\">\t\t  ip_reserved:2,</div><div class=\"line\">\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tstruct ipc_space *receiver;</div><div class=\"line\">\t\tstruct ipc_port *destination;</div><div class=\"line\">\t\tipc_port_timestamp_t timestamp;</div><div class=\"line\">\t&#125; data;</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tipc_kobject_t kobject;</div><div class=\"line\">\t\tipc_importance_task_t imp_task;</div><div class=\"line\">\t\tuintptr_t alias;</div><div class=\"line\">\t&#125; kdata;</div><div class=\"line\">\t\t</div><div class=\"line\">\tstruct ipc_port *ip_nsrequest;</div><div class=\"line\">\tstruct ipc_port *ip_pdrequest;</div><div class=\"line\">\tstruct ipc_port_request *ip_requests;</div><div class=\"line\">\tstruct ipc_kmsg *ip_premsg;</div><div class=\"line\"></div><div class=\"line\">\tmach_vm_address_t ip_context;</div><div class=\"line\"></div><div class=\"line\">\tmach_port_mscount_t ip_mscount;</div><div class=\"line\">\tmach_port_rights_t ip_srights;</div><div class=\"line\">\tmach_port_rights_t ip_sorights;</div><div class=\"line\"></div><div class=\"line\">#if\tMACH_ASSERT</div><div class=\"line\">#define\tIP_NSPARES\t\t4</div><div class=\"line\">#define\tIP_CALLSTACK_MAX\t16</div><div class=\"line\">/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */</div><div class=\"line\">\tthread_t\tip_thread;\t/* who made me?  thread context */</div><div class=\"line\">\tunsigned long\tip_timetrack;\t/* give an idea of &quot;when&quot; created */</div><div class=\"line\">\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class=\"line\">\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */</div><div class=\"line\">#endif\t/* MACH_ASSERT */</div><div class=\"line\">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>\n<h3 id=\"2-5-Mach接口生成器（MIG）\"><a href=\"#2-5-Mach接口生成器（MIG）\" class=\"headerlink\" title=\"2.5 Mach接口生成器（MIG）\"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\" alt=\"IG_opt.png\"></p>\n<h2 id=\"3-深入IPC\"><a href=\"#3-深入IPC\" class=\"headerlink\" title=\"3. 深入IPC\"></a>3. 深入IPC</h2><ul>\n<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>\n<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>\n<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>\n</ul>\n<h2 id=\"4-同步原语\"><a href=\"#4-同步原语\" class=\"headerlink\" title=\"4. 同步原语\"></a>4. 同步原语</h2><h3 id=\"4-1-锁的实现方式\"><a href=\"#4-1-锁的实现方式\" class=\"headerlink\" title=\"4.1 锁的实现方式\"></a>4.1 锁的实现方式</h3><ul>\n<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>\n<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>\n<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>\n</ul>\n<h3 id=\"4-2-互斥体-lck-mtx-t-（阻塞）\"><a href=\"#4-2-互斥体-lck-mtx-t-（阻塞）\" class=\"headerlink\" title=\"4.2 互斥体(lck_mtx_t)（阻塞）\"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>\n<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>\n<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>\n</ul>\n<h3 id=\"4-3-信号量-semaphore-t-（阻塞）\"><a href=\"#4-3-信号量-semaphore-t-（阻塞）\" class=\"headerlink\" title=\"4.3 信号量(semaphore_t)（阻塞）\"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>\n<h3 id=\"4-4-自旋锁-hw-lock-t-（忙等）\"><a href=\"#4-4-自旋锁-hw-lock-t-（忙等）\" class=\"headerlink\" title=\"4.4 自旋锁(hw_lock_t)（忙等）\"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>\n<h3 id=\"4-5-读写锁-hw-lock-t-（阻塞）\"><a href=\"#4-5-读写锁-hw-lock-t-（阻塞）\" class=\"headerlink\" title=\"4.5 读写锁(hw_lock_t)（阻塞）\"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>\n<h3 id=\"4-6-锁集-lock-set-t\"><a href=\"#4-6-锁集-lock-set-t\" class=\"headerlink\" title=\"4.6 锁集(lock_set_t)\"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>\n<h2 id=\"5-机器原语\"><a href=\"#5-机器原语\" class=\"headerlink\" title=\"5. 机器原语\"></a>5. 机器原语</h2><h3 id=\"5-1-主机对象（Host）\"><a href=\"#5-1-主机对象（Host）\" class=\"headerlink\" title=\"5.1 主机对象（Host）\"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct\thost &#123;</div><div class=\"line\">\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */</div><div class=\"line\">\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class=\"line\">\tstruct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"5-2-时钟对象（Clock）\"><a href=\"#5-2-时钟对象（Clock）\" class=\"headerlink\" title=\"5.2 时钟对象（Clock）\"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>\n<h3 id=\"5-3-处理器对象（Processer）\"><a href=\"#5-3-处理器对象（Processer）\" class=\"headerlink\" title=\"5.3 处理器对象（Processer）\"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor &#123;</div><div class=\"line\">\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */</div><div class=\"line\">\tint\t\t\t\t\tstate;\t\t\t/* See below */</div><div class=\"line\">\tboolean_t\t\tis_SMT;</div><div class=\"line\">\tboolean_t\t\tis_recommended;</div><div class=\"line\">\tstruct thread</div><div class=\"line\">\t\t\t\t\t\t*active_thread,\t/* thread running on processor */</div><div class=\"line\">\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */</div><div class=\"line\">\t\t\t\t\t\t*idle_thread;\t/* this processor&apos;s idle thread. */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */</div><div class=\"line\">\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */</div><div class=\"line\">\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */</div><div class=\"line\">\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */</div><div class=\"line\"></div><div class=\"line\">\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */</div><div class=\"line\">\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */</div><div class=\"line\">\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */</div><div class=\"line\"></div><div class=\"line\">\tuint64_t\t\t\tdeadline;\t\t/* current deadline */</div><div class=\"line\">\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\trunq;\t\t\t/* runq for this processor */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */</div><div class=\"line\">#endif</div><div class=\"line\">#if defined(CONFIG_SCHED_GRRR)</div><div class=\"line\">\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */</div><div class=\"line\">\tprocessor_t\t\tprocessor_secondary;</div><div class=\"line\">\tstruct ipc_port *\tprocessor_self;\t/* port for operations */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */</div><div class=\"line\">\tprocessor_data_t\tprocessor_data;\t/* per-processor data */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>\n<h3 id=\"5-3-处理器集\"><a href=\"#5-3-处理器集\" class=\"headerlink\" title=\"5.3 处理器集\"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>\n<ul>\n<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>\n<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>\n<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>\n</ul>\n<p><code>processor_set</code>的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor_set &#123;</div><div class=\"line\">\tqueue_head_t\t\tactive_queue;\t/* active processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tonline_processor_count;</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;</div><div class=\"line\">\tint\t\t\t\t\tcpu_set_count;</div><div class=\"line\"></div><div class=\"line\">#if __SMP__</div><div class=\"line\">\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\tpset_runq;      /* runq for this processor set */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\tpset_runq_bound_count;</div><div class=\"line\">\t\t/* # of threads in runq bound to any processor in pset */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class=\"line\">\tuint64_t\t\t\tpending_AST_cpu_mask;</div><div class=\"line\">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class=\"line\">\t/*</div><div class=\"line\">\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class=\"line\">\t * some level of support for requesting an AST on a processor, and then quashing</div><div class=\"line\">\t * that request later.</div><div class=\"line\">\t *</div><div class=\"line\">\t * The purpose of this field (and the associated codepaths) is to infer when we</div><div class=\"line\">\t * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class=\"line\">\t * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class=\"line\">\t * of spurious ASTs in the system, and let processors spend longer periods in</div><div class=\"line\">\t * IDLE.</div><div class=\"line\">\t */</div><div class=\"line\">\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */</div><div class=\"line\">\tstruct ipc_port *\tpset_name_self;\t/* port for information */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */</div><div class=\"line\">\tpset_node_t\t\t\tnode;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<hr>\n","excerpt":"","more":"<h2 id=\"1-Mach概述\"><a href=\"#1-Mach概述\" class=\"headerlink\" title=\"1. Mach概述\"></a>1. Mach概述</h2><h3 id=\"1-1-Mach设计原则\"><a href=\"#1-1-Mach设计原则\" class=\"headerlink\" title=\"1.1 Mach设计原则\"></a>1.1 Mach设计原则</h3><ul>\n<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>\n<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>\n</ul>\n<h3 id=\"1-2-Mach设计目标\"><a href=\"#1-2-Mach设计目标\" class=\"headerlink\" title=\"1.2 Mach设计目标\"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>\n<ul>\n<li>“控制点”或执行单元的管理。</li>\n<li>线程或线程组（Task）的资源分配。</li>\n<li>虚拟内存的分配和管理。</li>\n<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>\n</ul>\n<h2 id=\"2-Mach消息\"><a href=\"#2-Mach消息\" class=\"headerlink\" title=\"2. Mach消息\"></a>2. Mach消息</h2><h3 id=\"2-1-简单消息\"><a href=\"#2-1-简单消息\" class=\"headerlink\" title=\"2.1 简单消息\"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef\tstruct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_bits_t\tmsgh_bits;//标志位</div><div class=\"line\">  mach_msg_size_t\tmsgh_size;//大小</div><div class=\"line\">  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class=\"line\">  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class=\"line\">  mach_port_name_t\tmsgh_voucher_port;</div><div class=\"line\">  mach_msg_id_t\t\tmsgh_id;</div><div class=\"line\">&#125; mach_msg_header_t; //消息头</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_size_t msgh_descriptor_count;</div><div class=\"line\">&#125; mach_msg_body_t;//消息体</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_header_t       header;</div><div class=\"line\">        mach_msg_body_t         body;</div><div class=\"line\">&#125; mach_msg_base_t; //基本消息</div><div class=\"line\"></div><div class=\"line\">typedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class=\"line\"></div><div class=\"line\">typedef struct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_trailer_type_t\tmsgh_trailer_type;</div><div class=\"line\">  mach_msg_trailer_size_t\tmsgh_trailer_size;</div><div class=\"line\">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-复杂消息\"><a href=\"#2-2-复杂消息\" class=\"headerlink\" title=\"2.2 复杂消息\"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">  uint64_t\t\t\taddress;//数据的大小</div><div class=\"line\">  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配</div><div class=\"line\">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class=\"line\">  unsigned int     \t\tpad1: 8;</div><div class=\"line\">  mach_msg_descriptor_type_t    type: 8;</div><div class=\"line\">  mach_msg_size_t       \tsize;//数据的大小</div><div class=\"line\">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>\n<h3 id=\"2-3-消息收发\"><a href=\"#2-3-消息收发\" class=\"headerlink\" title=\"2.3 消息收发\"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern mach_msg_return_t\tmach_msg(</div><div class=\"line\">\t\t\t\t\tmach_msg_header_t *msg,</div><div class=\"line\">\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t send_size,</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t rcv_size,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t rcv_name,</div><div class=\"line\">\t\t\t\t\tmach_msg_timeout_t timeout,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t notify);</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-端口\"><a href=\"#2-4-端口\" class=\"headerlink\" title=\"2.4 端口\"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ipc_port &#123;</div><div class=\"line\"></div><div class=\"line\">\t/*</div><div class=\"line\">\t * Initial sub-structure in common with ipc_pset</div><div class=\"line\">\t * First element is an ipc_object second is a</div><div class=\"line\">\t * message queue</div><div class=\"line\">\t */</div><div class=\"line\">\tstruct ipc_object ip_object;</div><div class=\"line\">\tstruct ipc_mqueue ip_messages;</div><div class=\"line\"></div><div class=\"line\">\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */</div><div class=\"line\">\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */</div><div class=\"line\">\t\t  ip_impdonation:1,\t/* port supports importance donation */</div><div class=\"line\">\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */</div><div class=\"line\">\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class=\"line\">\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */</div><div class=\"line\">\t\t  ip_reserved:2,</div><div class=\"line\">\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tstruct ipc_space *receiver;</div><div class=\"line\">\t\tstruct ipc_port *destination;</div><div class=\"line\">\t\tipc_port_timestamp_t timestamp;</div><div class=\"line\">\t&#125; data;</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tipc_kobject_t kobject;</div><div class=\"line\">\t\tipc_importance_task_t imp_task;</div><div class=\"line\">\t\tuintptr_t alias;</div><div class=\"line\">\t&#125; kdata;</div><div class=\"line\">\t\t</div><div class=\"line\">\tstruct ipc_port *ip_nsrequest;</div><div class=\"line\">\tstruct ipc_port *ip_pdrequest;</div><div class=\"line\">\tstruct ipc_port_request *ip_requests;</div><div class=\"line\">\tstruct ipc_kmsg *ip_premsg;</div><div class=\"line\"></div><div class=\"line\">\tmach_vm_address_t ip_context;</div><div class=\"line\"></div><div class=\"line\">\tmach_port_mscount_t ip_mscount;</div><div class=\"line\">\tmach_port_rights_t ip_srights;</div><div class=\"line\">\tmach_port_rights_t ip_sorights;</div><div class=\"line\"></div><div class=\"line\">#if\tMACH_ASSERT</div><div class=\"line\">#define\tIP_NSPARES\t\t4</div><div class=\"line\">#define\tIP_CALLSTACK_MAX\t16</div><div class=\"line\">/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */</div><div class=\"line\">\tthread_t\tip_thread;\t/* who made me?  thread context */</div><div class=\"line\">\tunsigned long\tip_timetrack;\t/* give an idea of &quot;when&quot; created */</div><div class=\"line\">\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class=\"line\">\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */</div><div class=\"line\">#endif\t/* MACH_ASSERT */</div><div class=\"line\">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>\n<h3 id=\"2-5-Mach接口生成器（MIG）\"><a href=\"#2-5-Mach接口生成器（MIG）\" class=\"headerlink\" title=\"2.5 Mach接口生成器（MIG）\"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\" alt=\"IG_opt.png\"></p>\n<h2 id=\"3-深入IPC\"><a href=\"#3-深入IPC\" class=\"headerlink\" title=\"3. 深入IPC\"></a>3. 深入IPC</h2><ul>\n<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>\n<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>\n<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>\n</ul>\n<h2 id=\"4-同步原语\"><a href=\"#4-同步原语\" class=\"headerlink\" title=\"4. 同步原语\"></a>4. 同步原语</h2><h3 id=\"4-1-锁的实现方式\"><a href=\"#4-1-锁的实现方式\" class=\"headerlink\" title=\"4.1 锁的实现方式\"></a>4.1 锁的实现方式</h3><ul>\n<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>\n<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>\n<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>\n</ul>\n<h3 id=\"4-2-互斥体-lck-mtx-t-（阻塞）\"><a href=\"#4-2-互斥体-lck-mtx-t-（阻塞）\" class=\"headerlink\" title=\"4.2 互斥体(lck_mtx_t)（阻塞）\"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>\n<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>\n<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>\n</ul>\n<h3 id=\"4-3-信号量-semaphore-t-（阻塞）\"><a href=\"#4-3-信号量-semaphore-t-（阻塞）\" class=\"headerlink\" title=\"4.3 信号量(semaphore_t)（阻塞）\"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>\n<h3 id=\"4-4-自旋锁-hw-lock-t-（忙等）\"><a href=\"#4-4-自旋锁-hw-lock-t-（忙等）\" class=\"headerlink\" title=\"4.4 自旋锁(hw_lock_t)（忙等）\"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>\n<h3 id=\"4-5-读写锁-hw-lock-t-（阻塞）\"><a href=\"#4-5-读写锁-hw-lock-t-（阻塞）\" class=\"headerlink\" title=\"4.5 读写锁(hw_lock_t)（阻塞）\"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>\n<h3 id=\"4-6-锁集-lock-set-t\"><a href=\"#4-6-锁集-lock-set-t\" class=\"headerlink\" title=\"4.6 锁集(lock_set_t)\"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>\n<h2 id=\"5-机器原语\"><a href=\"#5-机器原语\" class=\"headerlink\" title=\"5. 机器原语\"></a>5. 机器原语</h2><h3 id=\"5-1-主机对象（Host）\"><a href=\"#5-1-主机对象（Host）\" class=\"headerlink\" title=\"5.1 主机对象（Host）\"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct\thost &#123;</div><div class=\"line\">\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */</div><div class=\"line\">\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class=\"line\">\tstruct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"5-2-时钟对象（Clock）\"><a href=\"#5-2-时钟对象（Clock）\" class=\"headerlink\" title=\"5.2 时钟对象（Clock）\"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>\n<h3 id=\"5-3-处理器对象（Processer）\"><a href=\"#5-3-处理器对象（Processer）\" class=\"headerlink\" title=\"5.3 处理器对象（Processer）\"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor &#123;</div><div class=\"line\">\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */</div><div class=\"line\">\tint\t\t\t\t\tstate;\t\t\t/* See below */</div><div class=\"line\">\tboolean_t\t\tis_SMT;</div><div class=\"line\">\tboolean_t\t\tis_recommended;</div><div class=\"line\">\tstruct thread</div><div class=\"line\">\t\t\t\t\t\t*active_thread,\t/* thread running on processor */</div><div class=\"line\">\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */</div><div class=\"line\">\t\t\t\t\t\t*idle_thread;\t/* this processor&apos;s idle thread. */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */</div><div class=\"line\">\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */</div><div class=\"line\">\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */</div><div class=\"line\">\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */</div><div class=\"line\"></div><div class=\"line\">\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */</div><div class=\"line\">\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */</div><div class=\"line\">\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */</div><div class=\"line\"></div><div class=\"line\">\tuint64_t\t\t\tdeadline;\t\t/* current deadline */</div><div class=\"line\">\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\trunq;\t\t\t/* runq for this processor */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */</div><div class=\"line\">#endif</div><div class=\"line\">#if defined(CONFIG_SCHED_GRRR)</div><div class=\"line\">\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */</div><div class=\"line\">\tprocessor_t\t\tprocessor_secondary;</div><div class=\"line\">\tstruct ipc_port *\tprocessor_self;\t/* port for operations */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */</div><div class=\"line\">\tprocessor_data_t\tprocessor_data;\t/* per-processor data */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>\n<h3 id=\"5-3-处理器集\"><a href=\"#5-3-处理器集\" class=\"headerlink\" title=\"5.3 处理器集\"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>\n<ul>\n<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>\n<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>\n<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>\n</ul>\n<p><code>processor_set</code>的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor_set &#123;</div><div class=\"line\">\tqueue_head_t\t\tactive_queue;\t/* active processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tonline_processor_count;</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;</div><div class=\"line\">\tint\t\t\t\t\tcpu_set_count;</div><div class=\"line\"></div><div class=\"line\">#if __SMP__</div><div class=\"line\">\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\tpset_runq;      /* runq for this processor set */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\tpset_runq_bound_count;</div><div class=\"line\">\t\t/* # of threads in runq bound to any processor in pset */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class=\"line\">\tuint64_t\t\t\tpending_AST_cpu_mask;</div><div class=\"line\">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class=\"line\">\t/*</div><div class=\"line\">\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class=\"line\">\t * some level of support for requesting an AST on a processor, and then quashing</div><div class=\"line\">\t * that request later.</div><div class=\"line\">\t *</div><div class=\"line\">\t * The purpose of this field (and the associated codepaths) is to infer when we</div><div class=\"line\">\t * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class=\"line\">\t * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class=\"line\">\t * of spurious ASTs in the system, and let processors spend longer periods in</div><div class=\"line\">\t * IDLE.</div><div class=\"line\">\t */</div><div class=\"line\">\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */</div><div class=\"line\">\tstruct ipc_port *\tpset_name_self;\t/* port for information */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */</div><div class=\"line\">\tpset_node_t\t\t\tnode;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<hr>\n"},{"title":"读书笔记之Mach调度","_content":"\n## 线程\n线程是个结构体\n## 任务（task）\n线程的容器，是以线程为元素的数组\n## 优先级\n## 运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n## 续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n## 抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n## 异步软件陷阱（AST）\n\n## 定时器中断\n软件定时器：\n硬件定时器：\n## 异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","source":"_posts/Mach调度.md","raw":"---\ntitle: 读书笔记之Mach调度\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n - Mach\n---\n\n## 线程\n线程是个结构体\n## 任务（task）\n线程的容器，是以线程为元素的数组\n## 优先级\n## 运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n## 续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n## 抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n## 异步软件陷阱（AST）\n\n## 定时器中断\n软件定时器：\n硬件定时器：\n## 异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","slug":"Mach调度","published":1,"date":"2016-08-30T02:12:09.000Z","updated":"2016-10-17T04:01:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr18000agv04ewuuqtlk","content":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是个结构体</p>\n<h2 id=\"任务（task）\"><a href=\"#任务（task）\" class=\"headerlink\" title=\"任务（task）\"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><h2 id=\"运行队列\"><a href=\"#运行队列\" class=\"headerlink\" title=\"运行队列\"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<h2 id=\"续体\"><a href=\"#续体\" class=\"headerlink\" title=\"续体\"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<h2 id=\"抢占模式\"><a href=\"#抢占模式\" class=\"headerlink\" title=\"抢占模式\"></a>抢占模式</h2><ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<h2 id=\"异步软件陷阱（AST）\"><a href=\"#异步软件陷阱（AST）\" class=\"headerlink\" title=\"异步软件陷阱（AST）\"></a>异步软件陷阱（AST）</h2></li>\n</ul>\n<h2 id=\"定时器中断\"><a href=\"#定时器中断\" class=\"headerlink\" title=\"定时器中断\"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是个结构体</p>\n<h2 id=\"任务（task）\"><a href=\"#任务（task）\" class=\"headerlink\" title=\"任务（task）\"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><h2 id=\"运行队列\"><a href=\"#运行队列\" class=\"headerlink\" title=\"运行队列\"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<h2 id=\"续体\"><a href=\"#续体\" class=\"headerlink\" title=\"续体\"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<h2 id=\"抢占模式\"><a href=\"#抢占模式\" class=\"headerlink\" title=\"抢占模式\"></a>抢占模式</h2><ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<h2 id=\"异步软件陷阱（AST）\"><a href=\"#异步软件陷阱（AST）\" class=\"headerlink\" title=\"异步软件陷阱（AST）\"></a>异步软件陷阱（AST）</h2></li>\n</ul>\n<h2 id=\"定时器中断\"><a href=\"#定时器中断\" class=\"headerlink\" title=\"定时器中断\"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n"},{"title":"React Native笔记","_content":"\n##要点记录\n###本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // Call long-running code on background thread\n    ...\n    // You can invoke callback from any thread/queue\n    callback(@[...]);\n  });\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@\"name\"];\n  [self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n  'EventReminder',\n  (reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n##本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\n  RCTMap *map = [RCTMap new];\n  map.delegate = self;\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\n  render() {\n    return <RCTMap {...this.props} />;\n  }\n}\n\nMapView.propTypes = {\n  /**\n   * When this property is set to `true` and a valid camera is associated\n   * with the map, the camera’s pitch angle is used to tilt the plane\n   * of the map. When this property is set to `false`, the camera’s pitch\n   * angle is ignored and the map is always displayed as if the user\n   * is looking straight down onto it.\n   */\n  pitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n##FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 网友眼中的MVC\n![网友眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n##ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n##遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","source":"_posts/React Native笔记.md","raw":"---\ntitle: React Native笔记\ncategories: \n - JS\n - React Native\ntags:\n - React\n - JS\n---\n\n##要点记录\n###本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // Call long-running code on background thread\n    ...\n    // You can invoke callback from any thread/queue\n    callback(@[...]);\n  });\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@\"name\"];\n  [self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n  'EventReminder',\n  (reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n##本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\n  RCTMap *map = [RCTMap new];\n  map.delegate = self;\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\n  render() {\n    return <RCTMap {...this.props} />;\n  }\n}\n\nMapView.propTypes = {\n  /**\n   * When this property is set to `true` and a valid camera is associated\n   * with the map, the camera’s pitch angle is used to tilt the plane\n   * of the map. When this property is set to `false`, the camera’s pitch\n   * angle is ignored and the map is always displayed as if the user\n   * is looking straight down onto it.\n   */\n  pitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n##FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 网友眼中的MVC\n![网友眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n##ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n##遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","slug":"React Native笔记","published":1,"date":"2016-08-30T02:10:53.000Z","updated":"2016-10-17T04:10:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1b000bgv04h5e8bpsx","content":"<p>##要点记录</p>\n<p>###本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\" target=\"_blank\" rel=\"external\">Native Modules</a>）</p>\n<ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">    callback(@[...]);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">  [<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\">  <span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">  (reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<p>##本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\" target=\"_blank\" rel=\"external\">Native UI Components</a>)</p>\n<ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">  RCTMap *map = [RCTMap new];</div><div class=\"line\">  map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">  [view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">  /**</div><div class=\"line\">   * When this property is set to `true` and a valid camera is associated</div><div class=\"line\">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">   * angle is ignored and the map is always displayed as if the user</div><div class=\"line\">   * is looking straight down onto it.</div><div class=\"line\">   */</div><div class=\"line\">  pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<p>##FLUX<br><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<p>##ES6语法相关</p>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<p>##遇到的问题</p>\n<ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\" target=\"_blank\" rel=\"external\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n","excerpt":"","more":"<p>##要点记录</p>\n<p>###本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\">Native Modules</a>）</p>\n<ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">    callback(@[...]);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">  [<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\">  <span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">  (reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<p>##本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\">Native UI Components</a>)</p>\n<ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">  RCTMap *map = [RCTMap new];</div><div class=\"line\">  map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">  [view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">  /**</div><div class=\"line\">   * When this property is set to `true` and a valid camera is associated</div><div class=\"line\">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">   * angle is ignored and the map is always displayed as if the user</div><div class=\"line\">   * is looking straight down onto it.</div><div class=\"line\">   */</div><div class=\"line\">  pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<p>##FLUX<br><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<p>##ES6语法相关</p>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<p>##遇到的问题</p>\n<ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n"},{"title":"Thrift的二进制数据编解码--以OC为例","date":"2016-04-16T14:56:14.000Z","_content":"\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","source":"_posts/Thrift的二进制数据编解码-以OC为例.md","raw":"---\ntitle: Thrift的二进制数据编解码--以OC为例\ndate: 2016-04-16 22:56:14\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","slug":"Thrift的二进制数据编解码-以OC为例","published":1,"updated":"2016-10-15T12:17:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1d000egv04zd388mam","content":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\" target=\"_blank\" rel=\"external\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n"},{"title":"iOS中的MAX(A,B)，需要注意的点","date":"2016-04-19T03:22:30.000Z","_content":"\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","source":"_posts/iOS中的MAX-A-B-，需要注意的点.md","raw":"---\ntitle: iOS中的MAX(A,B)，需要注意的点\ndate: 2016-04-19 11:22:30\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","slug":"iOS中的MAX-A-B-，需要注意的点","published":1,"updated":"2016-10-15T11:24:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1e000ggv041bbpdexn","content":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n"},{"title":"iOS引导页的镂空效果","date":"2016-04-29T14:06:55.000Z","_content":"\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","source":"_posts/iOS引导页的镂空效果.md","raw":"---\ntitle: iOS引导页的镂空效果\ndate: 2016-04-29 22:06:55\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","slug":"iOS引导页的镂空效果","published":1,"updated":"2016-10-15T11:29:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1g000kgv04oj4c3y1s","content":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n"},{"title":"iOS支持懒加载的PageViewController","date":"2016-09-01T16:12:18.000Z","_content":"\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","source":"_posts/iOS支持懒加载的PageViewController.md","raw":"---\ntitle: iOS支持懒加载的PageViewController\ndate: 2016-09-02 00:12:18\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","slug":"iOS支持懒加载的PageViewController","published":1,"updated":"2016-10-15T12:13:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1i000lgv04cfq9nlq2","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n"},{"_content":"# iOS签名\n\n标签（空格分隔）： iOS 安全\n\n---\n[TOC]\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","source":"_posts/iOS签名.md","raw":"# iOS签名\n\n标签（空格分隔）： iOS 安全\n\n---\n[TOC]\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","slug":"iOS签名","published":1,"date":"2016-08-30T02:01:06.000Z","updated":"2016-08-30T02:01:06.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1l000pgv04w74cp3k0","content":"<h1 id=\"iOS签名\"><a href=\"#iOS签名\" class=\"headerlink\" title=\"iOS签名\"></a>iOS签名</h1><p>标签（空格分隔）： iOS 安全</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\" target=\"_blank\" rel=\"external\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\" target=\"_blank\" rel=\"external\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\" target=\"_blank\" rel=\"external\">iOS Code Signing 学习笔记</a></p>\n","excerpt":"","more":"<h1 id=\"iOS签名\"><a href=\"#iOS签名\" class=\"headerlink\" title=\"iOS签名\"></a>iOS签名</h1><p>标签（空格分隔）： iOS 安全</p>\n<hr>\n<p>[TOC]</p>\n<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\">iOS Code Signing 学习笔记</a></p>\n"},{"title":"内核架构","_content":"\n# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","source":"_posts/内核架构.md","raw":"---\ntitle: 内核架构\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n---\n\n# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","slug":"内核架构","published":1,"date":"2016-09-04T14:42:35.000Z","updated":"2016-10-17T04:08:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1n000rgv04043n16v0","content":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>","excerpt":"","more":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>"},{"title":"创建pod库的步骤","_content":"\n标签（空格分隔）： 开发 iOS\n---\n## 注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n## 验证邮箱\n```\npod trunk me\n```\n## push源码到git仓库\n## 创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n## 编辑podspec文件\n## 检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n## 使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n## 成功后`pod setup`\n## 验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","source":"_posts/创建pod库的步骤.md","raw":"---\ntitle: 创建pod库的步骤\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n - Cocoapods\n---\n\n标签（空格分隔）： 开发 iOS\n---\n## 注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n## 验证邮箱\n```\npod trunk me\n```\n## push源码到git仓库\n## 创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n## 编辑podspec文件\n## 检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n## 使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n## 成功后`pod setup`\n## 验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","slug":"创建pod库的步骤","published":1,"date":"2016-08-30T02:02:32.000Z","updated":"2016-10-17T04:09:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1r000ugv04tauhzgfj","content":"<h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><h2 id=\"注册Trunk\"><a href=\"#注册Trunk\" class=\"headerlink\" title=\"注册Trunk\"></a>注册Trunk</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure>\n<h2 id=\"push源码到git仓库\"><a href=\"#push源码到git仓库\" class=\"headerlink\" title=\"push源码到git仓库\"></a>push源码到git仓库</h2><h2 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>\n<h2 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h2><h2 id=\"检查podspec文件格式是否符合规则\"><a href=\"#检查podspec文件格式是否符合规则\" class=\"headerlink\" title=\"检查podspec文件格式是否符合规则\"></a>检查podspec文件格式是否符合规则</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<h2 id=\"使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\"><a href=\"#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\" class=\"headerlink\" title=\"使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>\n<h2 id=\"成功后pod-setup\"><a href=\"#成功后pod-setup\" class=\"headerlink\" title=\"成功后pod setup\"></a>成功后<code>pod setup</code></h2><h2 id=\"验证是否成功：\"><a href=\"#验证是否成功：\" class=\"headerlink\" title=\"验证是否成功：\"></a>验证是否成功：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><h2 id=\"注册Trunk\"><a href=\"#注册Trunk\" class=\"headerlink\" title=\"注册Trunk\"></a>注册Trunk</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure>\n<h2 id=\"push源码到git仓库\"><a href=\"#push源码到git仓库\" class=\"headerlink\" title=\"push源码到git仓库\"></a>push源码到git仓库</h2><h2 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>\n<h2 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h2><h2 id=\"检查podspec文件格式是否符合规则\"><a href=\"#检查podspec文件格式是否符合规则\" class=\"headerlink\" title=\"检查podspec文件格式是否符合规则\"></a>检查podspec文件格式是否符合规则</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<h2 id=\"使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\"><a href=\"#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\" class=\"headerlink\" title=\"使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>\n<h2 id=\"成功后pod-setup\"><a href=\"#成功后pod-setup\" class=\"headerlink\" title=\"成功后pod setup\"></a>成功后<code>pod setup</code></h2><h2 id=\"验证是否成功：\"><a href=\"#验证是否成功：\" class=\"headerlink\" title=\"验证是否成功：\"></a>验证是否成功：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n"},{"title":"引导过程：EFI和iBoot","_content":"\n## 什么是引导过程\n引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：\n\n1. 刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。\n2. 接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到`操作系统加载器`。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。\n3. 由操作系统加载器加载操作系统代码。\n\n## EFI（Extensible Firmware Interface，可扩展固件接口）\n\n### BIOS的局限性\n- BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。\n- 只允许4个可引导分区（或称为主分区）。\n\n### EFI的概念\n正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。\n> EFI自下而上的架构大概是：硬件->固件（包含：EFI引导服务和EFI运行时服务）->EFI二进制文件（EFI引导加载器）->软件\n\n### EFI提供的服务\n\n#### EFI引导服务\n当系统仍然在EFI环境中，并且没有调用`ExitBootServices()`这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了`ExitBootServices()`,引导服务就无法访问了。\n\n对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：\n\n- **控制台协议**（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）\n- **媒介访问**（和文件系统打交道）\n- **杂项协议**（）\n\n#### EFI运行时服务\n跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：\n\n- 时间管理\n- 闹钟\n- 固件变量\n- 其他杂项\n\n## OS X的boot.efi\n1. 调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。\n2. 引导内核，EFI引导服务退出。\n3. 内核回调EFI运行时服务。\n\n## iOS的iBoot\niOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：\n\n- **普通引导、恢复模式引导**\n- **DFU模式引导**\n\n![图1][1]\n\n整个引导过程大概是这样的：\n\n1. 首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)\n2. 接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。\n3. 普通引导或恢复模式引导：\n\t- 加载LLB（Low level Bootloader，底层引导加载器。\n\t- 加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 \n4. DFU模式引导，使用了两个镜像iBSS和iBEC。\n\t- iBSS：负责底层初始化以及iBEC的加载。\n\t- iBEC：负责iTunes通过USB升级的过程。\n\n### 普通引导或恢复模式引导\n#### LLB\n它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。\n#### iBoot\niBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：\n\n- **“main”线程**，负责苹果的logo，以及系统的引导。\n- **“uart reader”线程**，这个线程用户调试用。\n\n正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入**恢复模式**，main线程会派生几下几个任务：\n\n- **idleoff任务**，当用户不操作时，关闭设备。\n- **poweroff任务**，当电量不足的时候，关闭设备。\n- **usb-req任务**，处理iTunes的USB请求。\n- **usb-high-current和usb-no-current任务**，响应USB充电。（当设备充电或者断开充电，修改电池图标）\n- **command任务**,启动命令行接口，即通过串口操作的控制台。\n\n#### 恢复模式引导与普通引导的区别\n恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。\n\n### DFU模式引导\n再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。\n\n## OS X的安装过程\n### 步骤1：installXXX.app\n安装包包含的文件如下图所示：\n![图2][2]\n运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作`根文件系统`的镜像--BaseSystem.dmg，然后通过`bless`命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。\n\n### 步骤2：OSInstaller\n引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。\n### 步骤3：安装.pkg文件\n最后就是安装各种各样的软件包了。\n\n## iOS文件系统镜像（.ipsw文件）\n将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。\n![图3][3]\n\n> 可以使用工具[wpwntool][4]解密文件，使用[vfdecrypt][4]解密系统镜像。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/ipsw.png?raw=true\n[4]: http://theiphonewiki.com/\n\n\n\n\n\n\n\n","source":"_posts/引导过程：EFI和iBoot.md","raw":"---\ntitle: 引导过程：EFI和iBoot\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n---\n\n## 什么是引导过程\n引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：\n\n1. 刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。\n2. 接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到`操作系统加载器`。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。\n3. 由操作系统加载器加载操作系统代码。\n\n## EFI（Extensible Firmware Interface，可扩展固件接口）\n\n### BIOS的局限性\n- BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。\n- 只允许4个可引导分区（或称为主分区）。\n\n### EFI的概念\n正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。\n> EFI自下而上的架构大概是：硬件->固件（包含：EFI引导服务和EFI运行时服务）->EFI二进制文件（EFI引导加载器）->软件\n\n### EFI提供的服务\n\n#### EFI引导服务\n当系统仍然在EFI环境中，并且没有调用`ExitBootServices()`这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了`ExitBootServices()`,引导服务就无法访问了。\n\n对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：\n\n- **控制台协议**（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）\n- **媒介访问**（和文件系统打交道）\n- **杂项协议**（）\n\n#### EFI运行时服务\n跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：\n\n- 时间管理\n- 闹钟\n- 固件变量\n- 其他杂项\n\n## OS X的boot.efi\n1. 调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。\n2. 引导内核，EFI引导服务退出。\n3. 内核回调EFI运行时服务。\n\n## iOS的iBoot\niOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：\n\n- **普通引导、恢复模式引导**\n- **DFU模式引导**\n\n![图1][1]\n\n整个引导过程大概是这样的：\n\n1. 首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)\n2. 接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。\n3. 普通引导或恢复模式引导：\n\t- 加载LLB（Low level Bootloader，底层引导加载器。\n\t- 加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 \n4. DFU模式引导，使用了两个镜像iBSS和iBEC。\n\t- iBSS：负责底层初始化以及iBEC的加载。\n\t- iBEC：负责iTunes通过USB升级的过程。\n\n### 普通引导或恢复模式引导\n#### LLB\n它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。\n#### iBoot\niBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：\n\n- **“main”线程**，负责苹果的logo，以及系统的引导。\n- **“uart reader”线程**，这个线程用户调试用。\n\n正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入**恢复模式**，main线程会派生几下几个任务：\n\n- **idleoff任务**，当用户不操作时，关闭设备。\n- **poweroff任务**，当电量不足的时候，关闭设备。\n- **usb-req任务**，处理iTunes的USB请求。\n- **usb-high-current和usb-no-current任务**，响应USB充电。（当设备充电或者断开充电，修改电池图标）\n- **command任务**,启动命令行接口，即通过串口操作的控制台。\n\n#### 恢复模式引导与普通引导的区别\n恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。\n\n### DFU模式引导\n再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。\n\n## OS X的安装过程\n### 步骤1：installXXX.app\n安装包包含的文件如下图所示：\n![图2][2]\n运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作`根文件系统`的镜像--BaseSystem.dmg，然后通过`bless`命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。\n\n### 步骤2：OSInstaller\n引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。\n### 步骤3：安装.pkg文件\n最后就是安装各种各样的软件包了。\n\n## iOS文件系统镜像（.ipsw文件）\n将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。\n![图3][3]\n\n> 可以使用工具[wpwntool][4]解密文件，使用[vfdecrypt][4]解密系统镜像。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/ipsw.png?raw=true\n[4]: http://theiphonewiki.com/\n\n\n\n\n\n\n\n","slug":"引导过程：EFI和iBoot","published":1,"date":"2016-09-01T01:17:21.000Z","updated":"2016-10-17T03:48:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1t000xgv04watp3nmd","content":"<h2 id=\"什么是引导过程\"><a href=\"#什么是引导过程\" class=\"headerlink\" title=\"什么是引导过程\"></a>什么是引导过程</h2><p>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>\n<ol>\n<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>\n<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>\n<li>由操作系统加载器加载操作系统代码。</li>\n</ol>\n<h2 id=\"EFI（Extensible-Firmware-Interface，可扩展固件接口）\"><a href=\"#EFI（Extensible-Firmware-Interface，可扩展固件接口）\" class=\"headerlink\" title=\"EFI（Extensible Firmware Interface，可扩展固件接口）\"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id=\"BIOS的局限性\"><a href=\"#BIOS的局限性\" class=\"headerlink\" title=\"BIOS的局限性\"></a>BIOS的局限性</h3><ul>\n<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>\n<li>只允许4个可引导分区（或称为主分区）。</li>\n</ul>\n<h3 id=\"EFI的概念\"><a href=\"#EFI的概念\" class=\"headerlink\" title=\"EFI的概念\"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>\n<blockquote>\n<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>\n</blockquote>\n<h3 id=\"EFI提供的服务\"><a href=\"#EFI提供的服务\" class=\"headerlink\" title=\"EFI提供的服务\"></a>EFI提供的服务</h3><h4 id=\"EFI引导服务\"><a href=\"#EFI引导服务\" class=\"headerlink\" title=\"EFI引导服务\"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>\n<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>\n<ul>\n<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>\n<li><strong>媒介访问</strong>（和文件系统打交道）</li>\n<li><strong>杂项协议</strong>（）</li>\n</ul>\n<h4 id=\"EFI运行时服务\"><a href=\"#EFI运行时服务\" class=\"headerlink\" title=\"EFI运行时服务\"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>\n<ul>\n<li>时间管理</li>\n<li>闹钟</li>\n<li>固件变量</li>\n<li>其他杂项</li>\n</ul>\n<h2 id=\"OS-X的boot-efi\"><a href=\"#OS-X的boot-efi\" class=\"headerlink\" title=\"OS X的boot.efi\"></a>OS X的boot.efi</h2><ol>\n<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>\n<li>引导内核，EFI引导服务退出。</li>\n<li>内核回调EFI运行时服务。</li>\n</ol>\n<h2 id=\"iOS的iBoot\"><a href=\"#iOS的iBoot\" class=\"headerlink\" title=\"iOS的iBoot\"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>\n<ul>\n<li><strong>普通引导、恢复模式引导</strong></li>\n<li><strong>DFU模式引导</strong></li>\n</ul>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\" alt=\"图1\"></p>\n<p>整个引导过程大概是这样的：</p>\n<ol>\n<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>\n<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>\n<li>普通引导或恢复模式引导：<ul>\n<li>加载LLB（Low level Bootloader，底层引导加载器。</li>\n<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>\n</ul>\n</li>\n<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>\n<li>iBSS：负责底层初始化以及iBEC的加载。</li>\n<li>iBEC：负责iTunes通过USB升级的过程。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"普通引导或恢复模式引导\"><a href=\"#普通引导或恢复模式引导\" class=\"headerlink\" title=\"普通引导或恢复模式引导\"></a>普通引导或恢复模式引导</h3><h4 id=\"LLB\"><a href=\"#LLB\" class=\"headerlink\" title=\"LLB\"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>\n<h4 id=\"iBoot\"><a href=\"#iBoot\" class=\"headerlink\" title=\"iBoot\"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>\n<ul>\n<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>\n<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>\n</ul>\n<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>\n<ul>\n<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>\n<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>\n<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>\n<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>\n<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>\n</ul>\n<h4 id=\"恢复模式引导与普通引导的区别\"><a href=\"#恢复模式引导与普通引导的区别\" class=\"headerlink\" title=\"恢复模式引导与普通引导的区别\"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>\n<h3 id=\"DFU模式引导\"><a href=\"#DFU模式引导\" class=\"headerlink\" title=\"DFU模式引导\"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>\n<h2 id=\"OS-X的安装过程\"><a href=\"#OS-X的安装过程\" class=\"headerlink\" title=\"OS X的安装过程\"></a>OS X的安装过程</h2><h3 id=\"步骤1：installXXX-app\"><a href=\"#步骤1：installXXX-app\" class=\"headerlink\" title=\"步骤1：installXXX.app\"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\" alt=\"图2\"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>\n<h3 id=\"步骤2：OSInstaller\"><a href=\"#步骤2：OSInstaller\" class=\"headerlink\" title=\"步骤2：OSInstaller\"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>\n<h3 id=\"步骤3：安装-pkg文件\"><a href=\"#步骤3：安装-pkg文件\" class=\"headerlink\" title=\"步骤3：安装.pkg文件\"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>\n<h2 id=\"iOS文件系统镜像（-ipsw文件）\"><a href=\"#iOS文件系统镜像（-ipsw文件）\" class=\"headerlink\" title=\"iOS文件系统镜像（.ipsw文件）\"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true\" alt=\"图3\"></p>\n<blockquote>\n<p>可以使用工具<a href=\"http://theiphonewiki.com/\" target=\"_blank\" rel=\"external\">wpwntool</a>解密文件，使用<a href=\"http://theiphonewiki.com/\" target=\"_blank\" rel=\"external\">vfdecrypt</a>解密系统镜像。</p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是引导过程\"><a href=\"#什么是引导过程\" class=\"headerlink\" title=\"什么是引导过程\"></a>什么是引导过程</h2><p>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>\n<ol>\n<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>\n<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>\n<li>由操作系统加载器加载操作系统代码。</li>\n</ol>\n<h2 id=\"EFI（Extensible-Firmware-Interface，可扩展固件接口）\"><a href=\"#EFI（Extensible-Firmware-Interface，可扩展固件接口）\" class=\"headerlink\" title=\"EFI（Extensible Firmware Interface，可扩展固件接口）\"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id=\"BIOS的局限性\"><a href=\"#BIOS的局限性\" class=\"headerlink\" title=\"BIOS的局限性\"></a>BIOS的局限性</h3><ul>\n<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>\n<li>只允许4个可引导分区（或称为主分区）。</li>\n</ul>\n<h3 id=\"EFI的概念\"><a href=\"#EFI的概念\" class=\"headerlink\" title=\"EFI的概念\"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>\n<blockquote>\n<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>\n</blockquote>\n<h3 id=\"EFI提供的服务\"><a href=\"#EFI提供的服务\" class=\"headerlink\" title=\"EFI提供的服务\"></a>EFI提供的服务</h3><h4 id=\"EFI引导服务\"><a href=\"#EFI引导服务\" class=\"headerlink\" title=\"EFI引导服务\"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>\n<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>\n<ul>\n<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>\n<li><strong>媒介访问</strong>（和文件系统打交道）</li>\n<li><strong>杂项协议</strong>（）</li>\n</ul>\n<h4 id=\"EFI运行时服务\"><a href=\"#EFI运行时服务\" class=\"headerlink\" title=\"EFI运行时服务\"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>\n<ul>\n<li>时间管理</li>\n<li>闹钟</li>\n<li>固件变量</li>\n<li>其他杂项</li>\n</ul>\n<h2 id=\"OS-X的boot-efi\"><a href=\"#OS-X的boot-efi\" class=\"headerlink\" title=\"OS X的boot.efi\"></a>OS X的boot.efi</h2><ol>\n<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>\n<li>引导内核，EFI引导服务退出。</li>\n<li>内核回调EFI运行时服务。</li>\n</ol>\n<h2 id=\"iOS的iBoot\"><a href=\"#iOS的iBoot\" class=\"headerlink\" title=\"iOS的iBoot\"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>\n<ul>\n<li><strong>普通引导、恢复模式引导</strong></li>\n<li><strong>DFU模式引导</strong></li>\n</ul>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\" alt=\"图1\"></p>\n<p>整个引导过程大概是这样的：</p>\n<ol>\n<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>\n<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>\n<li>普通引导或恢复模式引导：<ul>\n<li>加载LLB（Low level Bootloader，底层引导加载器。</li>\n<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>\n</ul>\n</li>\n<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>\n<li>iBSS：负责底层初始化以及iBEC的加载。</li>\n<li>iBEC：负责iTunes通过USB升级的过程。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"普通引导或恢复模式引导\"><a href=\"#普通引导或恢复模式引导\" class=\"headerlink\" title=\"普通引导或恢复模式引导\"></a>普通引导或恢复模式引导</h3><h4 id=\"LLB\"><a href=\"#LLB\" class=\"headerlink\" title=\"LLB\"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>\n<h4 id=\"iBoot\"><a href=\"#iBoot\" class=\"headerlink\" title=\"iBoot\"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>\n<ul>\n<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>\n<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>\n</ul>\n<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>\n<ul>\n<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>\n<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>\n<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>\n<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>\n<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>\n</ul>\n<h4 id=\"恢复模式引导与普通引导的区别\"><a href=\"#恢复模式引导与普通引导的区别\" class=\"headerlink\" title=\"恢复模式引导与普通引导的区别\"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>\n<h3 id=\"DFU模式引导\"><a href=\"#DFU模式引导\" class=\"headerlink\" title=\"DFU模式引导\"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>\n<h2 id=\"OS-X的安装过程\"><a href=\"#OS-X的安装过程\" class=\"headerlink\" title=\"OS X的安装过程\"></a>OS X的安装过程</h2><h3 id=\"步骤1：installXXX-app\"><a href=\"#步骤1：installXXX-app\" class=\"headerlink\" title=\"步骤1：installXXX.app\"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\" alt=\"图2\"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>\n<h3 id=\"步骤2：OSInstaller\"><a href=\"#步骤2：OSInstaller\" class=\"headerlink\" title=\"步骤2：OSInstaller\"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>\n<h3 id=\"步骤3：安装-pkg文件\"><a href=\"#步骤3：安装-pkg文件\" class=\"headerlink\" title=\"步骤3：安装.pkg文件\"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>\n<h2 id=\"iOS文件系统镜像（-ipsw文件）\"><a href=\"#iOS文件系统镜像（-ipsw文件）\" class=\"headerlink\" title=\"iOS文件系统镜像（.ipsw文件）\"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true\" alt=\"图3\"></p>\n<blockquote>\n<p>可以使用工具<a href=\"http://theiphonewiki.com/\">wpwntool</a>解密文件，使用<a href=\"http://theiphonewiki.com/\">vfdecrypt</a>解密系统镜像。</p>\n</blockquote>\n<hr>\n"},{"title":"文件系统和虚拟文件系统交换（VFS）","_content":"\n## 硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","source":"_posts/文件系统和虚拟文件系统交换（VFS）.md","raw":"---\ntitle: 文件系统和虚拟文件系统交换（VFS）\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n---\n\n## 硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","slug":"文件系统和虚拟文件系统交换（VFS）","published":1,"date":"2016-08-30T02:11:37.000Z","updated":"2016-10-17T03:49:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1w0010gv042p279zhr","content":"<h2 id=\"硬盘分区\"><a href=\"#硬盘分区\" class=\"headerlink\" title=\"硬盘分区\"></a>硬盘分区</h2><h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"硬盘分区\"><a href=\"#硬盘分区\" class=\"headerlink\" title=\"硬盘分区\"></a>硬盘分区</h2><h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n"},{"title":"由生到死--内核引导和内核崩溃","_content":"\n## XNU内核的编译\n参考[Building xnu for OS X 10.11 El Capitan][2],但是还没有成功编译通过。。。\n\n## 一个内核，支持多种架构\n- osfmk目录包含了架构相关的子目录（如：i386，x86_64）。\n- pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。\n- i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：\n ![pexpert结构][1]\n\n## 内核代码树\n- 可以使用[FXR浏览工具](http://fxr.watson.org)查看源码。\n- XNU主目录结构：\n\t![XNU主目录结构][3]\n\t\n- BSD目录结构：\n\t![BSD目录结构][4]\n\t\n- OSFMK目录结构：\n\t![OSFMK目录结构][5]\t\n\n## XNU的引导过程\n**XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。**\n\n### 从高层次看XNU的引导过程\n- 整个过程如下图，后面会介绍各个阶段的细节。\n\t![高层次看XNU的引导过程][6]\n- **OSX：vstart**\n\t- 如果是Debug环境初始化串口（pal_serial_init()）。\n\t- 开启NX/XD：防止代码注入。\n\t- 初始化主CPU的[GDT和LDT][7]，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）\n\t- 初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）\n\t- 主从CPU调用相应的i386_init/i386_init_slave。\n\t\n- **iOS：start**\n\n\t这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。\n\n- **[i386|arm]_init**（osfmk/i386/i386_init.c）\n\n\t*主要工作是初始化主CPU为可用状态，然后准备好内核引导。*\n\n- **i386_init_slave()**\n初始化从CPU。\n\n- **machine_startup**\n\n主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。\n\n- **kernel_bootstrap**\n这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：\n\t- **初始化虚拟内存**。\n\t- **IPC（进程间通信）**：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。\n\t- **时钟**：通过时钟实现闹铃、报时功能。 \n\t- **账本**：Mach系统的记账功能。\n\t- **任务**：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。\n\t- **线程**：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。\n其中调用的重要的函数有：\n\t- kernel_bootstrap_thread:他的工作如下\n\t\t1. 主线程开始以`kernel_bootstrap_thread`的身份运行，初始化各个子系统。\n\t\t2. 调用kernel_create_thread()派生辅助线程。第一个创建的线程是**idle线程**（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。\n\t\t3. 下-个创建线程就是**线程调度器**，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。\n\t\t4. OSX的XNU启动`mapping_replenish线程`，在iOS上是`zone_refill_thread线程`。\n\t\t5. 如果内核设置了**SERIAL_KDP**,那么调度器会调用`init_kdp()`初始化调试器。\n\t\t6. 初始化**IOKit**，如果没有**IOKit**，XNU将无法访问硬件设备。\n\t\t7. 启用**中断**。\n\t\t8. 初始化**共享区模块（shared region）**，dyld在加载共享库时会使用这个模块，内核本身的**commpage**也会使用这个模块，**commpage**指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。\n\t\t9. 如果编译时启动了**MAC（Mandatory Access Control）**，则会调用`mac_policy_initmach()`。\n\t\t10. 调用`bsd_init`初始化BSD子系统，这个函数最终会派生出init任务来执行`bin/launchd`，init任务是所有用户态进程的祖先。\n\t\t11. 如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。\n\n## 睡眠和唤醒\n睡眠流程一般如下：\n\n- 除了当前CPU外，停止其他的CPU。\n- 关闭本地的APIC，准备进入睡眠。\n- 输出一条kdebug消息。\n- 在x86_64平台上保留CR3。\n- 调用`acpi_sleep_cpu()`,将CPU设置为睡眠状态。\n- 将控制权交给固件。\n\n唤醒处理程序的工作是：\n\n- 切换回64位模式。\n- 恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。\n- 恢复所有保存的寄存器。\n\n\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\n[7]: http://blog.csdn.net/yleek/article/details/8204393\n","source":"_posts/由生到死--内核引导和内核崩溃.md","raw":"---\ntitle: 由生到死--内核引导和内核崩溃\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n---\n\n## XNU内核的编译\n参考[Building xnu for OS X 10.11 El Capitan][2],但是还没有成功编译通过。。。\n\n## 一个内核，支持多种架构\n- osfmk目录包含了架构相关的子目录（如：i386，x86_64）。\n- pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。\n- i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：\n ![pexpert结构][1]\n\n## 内核代码树\n- 可以使用[FXR浏览工具](http://fxr.watson.org)查看源码。\n- XNU主目录结构：\n\t![XNU主目录结构][3]\n\t\n- BSD目录结构：\n\t![BSD目录结构][4]\n\t\n- OSFMK目录结构：\n\t![OSFMK目录结构][5]\t\n\n## XNU的引导过程\n**XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。**\n\n### 从高层次看XNU的引导过程\n- 整个过程如下图，后面会介绍各个阶段的细节。\n\t![高层次看XNU的引导过程][6]\n- **OSX：vstart**\n\t- 如果是Debug环境初始化串口（pal_serial_init()）。\n\t- 开启NX/XD：防止代码注入。\n\t- 初始化主CPU的[GDT和LDT][7]，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）\n\t- 初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）\n\t- 主从CPU调用相应的i386_init/i386_init_slave。\n\t\n- **iOS：start**\n\n\t这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。\n\n- **[i386|arm]_init**（osfmk/i386/i386_init.c）\n\n\t*主要工作是初始化主CPU为可用状态，然后准备好内核引导。*\n\n- **i386_init_slave()**\n初始化从CPU。\n\n- **machine_startup**\n\n主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。\n\n- **kernel_bootstrap**\n这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：\n\t- **初始化虚拟内存**。\n\t- **IPC（进程间通信）**：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。\n\t- **时钟**：通过时钟实现闹铃、报时功能。 \n\t- **账本**：Mach系统的记账功能。\n\t- **任务**：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。\n\t- **线程**：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。\n其中调用的重要的函数有：\n\t- kernel_bootstrap_thread:他的工作如下\n\t\t1. 主线程开始以`kernel_bootstrap_thread`的身份运行，初始化各个子系统。\n\t\t2. 调用kernel_create_thread()派生辅助线程。第一个创建的线程是**idle线程**（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。\n\t\t3. 下-个创建线程就是**线程调度器**，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。\n\t\t4. OSX的XNU启动`mapping_replenish线程`，在iOS上是`zone_refill_thread线程`。\n\t\t5. 如果内核设置了**SERIAL_KDP**,那么调度器会调用`init_kdp()`初始化调试器。\n\t\t6. 初始化**IOKit**，如果没有**IOKit**，XNU将无法访问硬件设备。\n\t\t7. 启用**中断**。\n\t\t8. 初始化**共享区模块（shared region）**，dyld在加载共享库时会使用这个模块，内核本身的**commpage**也会使用这个模块，**commpage**指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。\n\t\t9. 如果编译时启动了**MAC（Mandatory Access Control）**，则会调用`mac_policy_initmach()`。\n\t\t10. 调用`bsd_init`初始化BSD子系统，这个函数最终会派生出init任务来执行`bin/launchd`，init任务是所有用户态进程的祖先。\n\t\t11. 如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。\n\n## 睡眠和唤醒\n睡眠流程一般如下：\n\n- 除了当前CPU外，停止其他的CPU。\n- 关闭本地的APIC，准备进入睡眠。\n- 输出一条kdebug消息。\n- 在x86_64平台上保留CR3。\n- 调用`acpi_sleep_cpu()`,将CPU设置为睡眠状态。\n- 将控制权交给固件。\n\n唤醒处理程序的工作是：\n\n- 切换回64位模式。\n- 恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。\n- 恢复所有保存的寄存器。\n\n\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\n[7]: http://blog.csdn.net/yleek/article/details/8204393\n","slug":"由生到死--内核引导和内核崩溃","published":1,"date":"2016-09-07T12:43:53.000Z","updated":"2016-10-17T03:49:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr1y0013gv043outbhm0","content":"<h2 id=\"XNU内核的编译\"><a href=\"#XNU内核的编译\" class=\"headerlink\" title=\"XNU内核的编译\"></a>XNU内核的编译</h2><p>参考<a href=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>\n<h2 id=\"一个内核，支持多种架构\"><a href=\"#一个内核，支持多种架构\" class=\"headerlink\" title=\"一个内核，支持多种架构\"></a>一个内核，支持多种架构</h2><ul>\n<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>\n<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>\n<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\" alt=\"pexpert结构\"></li>\n</ul>\n<h2 id=\"内核代码树\"><a href=\"#内核代码树\" class=\"headerlink\" title=\"内核代码树\"></a>内核代码树</h2><ul>\n<li>可以使用<a href=\"http://fxr.watson.org\" target=\"_blank\" rel=\"external\">FXR浏览工具</a>查看源码。</li>\n<li><p>XNU主目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\" alt=\"XNU主目录结构\"></p>\n</li>\n<li><p>BSD目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\" alt=\"BSD目录结构\"></p>\n</li>\n<li><p>OSFMK目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\" alt=\"OSFMK目录结构\">    </p>\n</li>\n</ul>\n<h2 id=\"XNU的引导过程\"><a href=\"#XNU的引导过程\" class=\"headerlink\" title=\"XNU的引导过程\"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>\n<h3 id=\"从高层次看XNU的引导过程\"><a href=\"#从高层次看XNU的引导过程\" class=\"headerlink\" title=\"从高层次看XNU的引导过程\"></a>从高层次看XNU的引导过程</h3><ul>\n<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\" alt=\"高层次看XNU的引导过程\"></li>\n<li><p><strong>OSX：vstart</strong></p>\n<ul>\n<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>\n<li>开启NX/XD：防止代码注入。</li>\n<li>初始化主CPU的<a href=\"http://blog.csdn.net/yleek/article/details/8204393\" target=\"_blank\" rel=\"external\">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>\n<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>\n<li>主从CPU调用相应的i386_init/i386_init_slave。</li>\n</ul>\n</li>\n<li><p><strong>iOS：start</strong></p>\n<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>\n</li>\n<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>\n<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>\n</li>\n<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>\n</li>\n<li><p><strong>machine_startup</strong></p>\n</li>\n</ul>\n<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>\n<ul>\n<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>\n<li><strong>初始化虚拟内存</strong>。</li>\n<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>\n<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>\n<li><strong>账本</strong>：Mach系统的记账功能。</li>\n<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>\n<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>\n<li>kernel_bootstrap_thread:他的工作如下<ol>\n<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>\n<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>\n<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>\n<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>\n<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>\n<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>\n<li>启用<strong>中断</strong>。</li>\n<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>\n<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>\n<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>\n<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"睡眠和唤醒\"><a href=\"#睡眠和唤醒\" class=\"headerlink\" title=\"睡眠和唤醒\"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>\n<ul>\n<li>除了当前CPU外，停止其他的CPU。</li>\n<li>关闭本地的APIC，准备进入睡眠。</li>\n<li>输出一条kdebug消息。</li>\n<li>在x86_64平台上保留CR3。</li>\n<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>\n<li>将控制权交给固件。</li>\n</ul>\n<p>唤醒处理程序的工作是：</p>\n<ul>\n<li>切换回64位模式。</li>\n<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>\n<li>恢复所有保存的寄存器。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"XNU内核的编译\"><a href=\"#XNU内核的编译\" class=\"headerlink\" title=\"XNU内核的编译\"></a>XNU内核的编译</h2><p>参考<a href=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>\n<h2 id=\"一个内核，支持多种架构\"><a href=\"#一个内核，支持多种架构\" class=\"headerlink\" title=\"一个内核，支持多种架构\"></a>一个内核，支持多种架构</h2><ul>\n<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>\n<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>\n<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\" alt=\"pexpert结构\"></li>\n</ul>\n<h2 id=\"内核代码树\"><a href=\"#内核代码树\" class=\"headerlink\" title=\"内核代码树\"></a>内核代码树</h2><ul>\n<li>可以使用<a href=\"http://fxr.watson.org\">FXR浏览工具</a>查看源码。</li>\n<li><p>XNU主目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\" alt=\"XNU主目录结构\"></p>\n</li>\n<li><p>BSD目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\" alt=\"BSD目录结构\"></p>\n</li>\n<li><p>OSFMK目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\" alt=\"OSFMK目录结构\">    </p>\n</li>\n</ul>\n<h2 id=\"XNU的引导过程\"><a href=\"#XNU的引导过程\" class=\"headerlink\" title=\"XNU的引导过程\"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>\n<h3 id=\"从高层次看XNU的引导过程\"><a href=\"#从高层次看XNU的引导过程\" class=\"headerlink\" title=\"从高层次看XNU的引导过程\"></a>从高层次看XNU的引导过程</h3><ul>\n<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\" alt=\"高层次看XNU的引导过程\"></li>\n<li><p><strong>OSX：vstart</strong></p>\n<ul>\n<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>\n<li>开启NX/XD：防止代码注入。</li>\n<li>初始化主CPU的<a href=\"http://blog.csdn.net/yleek/article/details/8204393\">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>\n<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>\n<li>主从CPU调用相应的i386_init/i386_init_slave。</li>\n</ul>\n</li>\n<li><p><strong>iOS：start</strong></p>\n<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>\n</li>\n<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>\n<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>\n</li>\n<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>\n</li>\n<li><p><strong>machine_startup</strong></p>\n</li>\n</ul>\n<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>\n<ul>\n<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>\n<li><strong>初始化虚拟内存</strong>。</li>\n<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>\n<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>\n<li><strong>账本</strong>：Mach系统的记账功能。</li>\n<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>\n<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>\n<li>kernel_bootstrap_thread:他的工作如下<ol>\n<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>\n<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>\n<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>\n<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>\n<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>\n<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>\n<li>启用<strong>中断</strong>。</li>\n<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>\n<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>\n<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>\n<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"睡眠和唤醒\"><a href=\"#睡眠和唤醒\" class=\"headerlink\" title=\"睡眠和唤醒\"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>\n<ul>\n<li>除了当前CPU外，停止其他的CPU。</li>\n<li>关闭本地的APIC，准备进入睡眠。</li>\n<li>输出一条kdebug消息。</li>\n<li>在x86_64平台上保留CR3。</li>\n<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>\n<li>将控制权交给固件。</li>\n</ul>\n<p>唤醒处理程序的工作是：</p>\n<ul>\n<li>切换回64位模式。</li>\n<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>\n<li>恢复所有保存的寄存器。</li>\n</ul>\n<hr>\n"},{"title":"简约的iOS音乐播放UI控件","date":"2016-05-24T10:46:59.000Z","_content":"\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","source":"_posts/简约的iOS音乐播放UI控件.md","raw":"---\ntitle: 简约的iOS音乐播放UI控件\ndate: 2016-05-24 18:46:59\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","slug":"简约的iOS音乐播放UI控件","published":1,"updated":"2016-10-15T11:35:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr200016gv04e3z9wog2","content":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n"},{"title":"网络七层协议（结合操作系统来了解）","_content":"\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n##硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","source":"_posts/网络七层协议（结合操作系统来了解）.md","raw":"---\ntitle: 网络七层协议（结合操作系统来了解）\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n---\n\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n##硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","slug":"网络七层协议（结合操作系统来了解）","published":1,"date":"2016-08-30T02:09:57.000Z","updated":"2016-10-17T03:50:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr230019gv04fza253k3","content":"<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<p>##硬件</p>\n<h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n","excerpt":"","more":"<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<p>##硬件</p>\n<h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n"},{"title":"读书笔记之《如何阅读一本书》","_content":"\n##阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n##基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n##检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","source":"_posts/读书笔记之《如何阅读一本书》.md","raw":"---\ntitle: 读书笔记之《如何阅读一本书》\ncategories: \n - 方法论\ntags:\n - 学习方法\n---\n\n##阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n##基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n##检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","slug":"读书笔记之《如何阅读一本书》","published":1,"date":"2016-08-30T01:57:32.000Z","updated":"2016-10-17T03:51:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr2a001cgv04gglo8flb","content":"<p>##阅读的四个层次</p>\n<ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<p>##基础阅读（四个阶段）</p>\n<ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<p>##检视阅读（如何做）</p>\n<ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n","excerpt":"","more":"<p>##阅读的四个层次</p>\n<ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<p>##基础阅读（四个阶段）</p>\n<ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<p>##检视阅读（如何做）</p>\n<ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n"},{"title":"贯穿始终-launchd","_content":"\n## launchd\nlaunchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。\nlaunchd分为两种类型的后台作业：\n\n- **守护程序**（daemon），不可和用户交互。\n- **代理程序**（agent），特殊的守护程序，可以和用户交互。\n\n## launchd的职责\n\n### 运行定时作业\n指定时间运行指定的命令。\n\n### 启动网络服务\n绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。\n\n### 提供自举服务<servers/bootstrap.h>\n- launchd在启动的时候声明一个端口（**bootstrap_port**）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个**bootstrap_port**来访问自举服务器来查询某个服务，并且匹配服务程序的端口。\n- 如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数`bootstrap_check_in()`来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。\n\n### 事物支持\n`vproc_transaction_begi`n和`vproc_transaction_end`之间的操作称为**未决事物**，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。\n\n### 资源限制和遏制\niOS Jetsam机制，可以强制施行虚拟内存使用率限制。\n\n### Autorun模拟和文件系统观察\n- launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。\n- 通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。\n\n### 整合了I/O Kit\n\n## iOS的launchDeamon\niOS包含的launchDeamon列表如下图所示：\n![launchDeamon][1]\n\n**其中最重要的两个守护进程是lockdownd和SpringBoard**\n\n### lockdownd\nlockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。\n\n### SpringBoard\n- 创建GUI\n- 处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。\n- SpringBoard包含大量的线程，比如：\n\t- 有Web相关的线程（WebCore和WebThread）\n\t- WiFiManager\n\t- CoreAnimation\n- SpringBoard通过launchd注册了很多Mach端口，其中最重要的是`PurpleSystemEventPort`，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。\n\n## XPC\n- XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：\n\n```\nxpc_connection_send_message\n(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.\n```\n```\nxpc_connection_send_barrier\n(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.\n```\n```\nxpc_connection_send_message_with_reply\n(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.\n```\n```\nxpc_object_t\nxpc_connection_send_message_with_reply_sync\n(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value\n```\n- XPC的例子可以参照：苹果官方的[SandboxedFetch][2]\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\n[2]: https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/贯穿始终-launchd.md","raw":"---\ntitle: 贯穿始终-launchd\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\n - 内核\ntags:\n - 内核\n - launchd\n---\n\n## launchd\nlaunchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。\nlaunchd分为两种类型的后台作业：\n\n- **守护程序**（daemon），不可和用户交互。\n- **代理程序**（agent），特殊的守护程序，可以和用户交互。\n\n## launchd的职责\n\n### 运行定时作业\n指定时间运行指定的命令。\n\n### 启动网络服务\n绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。\n\n### 提供自举服务<servers/bootstrap.h>\n- launchd在启动的时候声明一个端口（**bootstrap_port**）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个**bootstrap_port**来访问自举服务器来查询某个服务，并且匹配服务程序的端口。\n- 如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数`bootstrap_check_in()`来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。\n\n### 事物支持\n`vproc_transaction_begi`n和`vproc_transaction_end`之间的操作称为**未决事物**，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。\n\n### 资源限制和遏制\niOS Jetsam机制，可以强制施行虚拟内存使用率限制。\n\n### Autorun模拟和文件系统观察\n- launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。\n- 通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。\n\n### 整合了I/O Kit\n\n## iOS的launchDeamon\niOS包含的launchDeamon列表如下图所示：\n![launchDeamon][1]\n\n**其中最重要的两个守护进程是lockdownd和SpringBoard**\n\n### lockdownd\nlockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。\n\n### SpringBoard\n- 创建GUI\n- 处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。\n- SpringBoard包含大量的线程，比如：\n\t- 有Web相关的线程（WebCore和WebThread）\n\t- WiFiManager\n\t- CoreAnimation\n- SpringBoard通过launchd注册了很多Mach端口，其中最重要的是`PurpleSystemEventPort`，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。\n\n## XPC\n- XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：\n\n```\nxpc_connection_send_message\n(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.\n```\n```\nxpc_connection_send_barrier\n(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.\n```\n```\nxpc_connection_send_message_with_reply\n(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.\n```\n```\nxpc_object_t\nxpc_connection_send_message_with_reply_sync\n(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value\n```\n- XPC的例子可以参照：苹果官方的[SandboxedFetch][2]\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\n[2]: https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"贯穿始终-launchd","published":1,"date":"2016-09-02T13:22:44.000Z","updated":"2016-10-17T03:51:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciudkhr2h001fgv048zfylm36","content":"<h2 id=\"launchd\"><a href=\"#launchd\" class=\"headerlink\" title=\"launchd\"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>\n<ul>\n<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>\n<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>\n</ul>\n<h2 id=\"launchd的职责\"><a href=\"#launchd的职责\" class=\"headerlink\" title=\"launchd的职责\"></a>launchd的职责</h2><h3 id=\"运行定时作业\"><a href=\"#运行定时作业\" class=\"headerlink\" title=\"运行定时作业\"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>\n<h3 id=\"提供自举服务\"><a href=\"#提供自举服务\" class=\"headerlink\" title=\"提供自举服务\"></a>提供自举服务<servers bootstrap.h=\"\"></servers></h3><ul>\n<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>\n<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers bootstrap.h=\"\">中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</servers></li>\n</ul>\n<h3 id=\"事物支持\"><a href=\"#事物支持\" class=\"headerlink\" title=\"事物支持\"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>\n<h3 id=\"资源限制和遏制\"><a href=\"#资源限制和遏制\" class=\"headerlink\" title=\"资源限制和遏制\"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>\n<h3 id=\"Autorun模拟和文件系统观察\"><a href=\"#Autorun模拟和文件系统观察\" class=\"headerlink\" title=\"Autorun模拟和文件系统观察\"></a>Autorun模拟和文件系统观察</h3><ul>\n<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>\n<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>\n</ul>\n<h3 id=\"整合了I-O-Kit\"><a href=\"#整合了I-O-Kit\" class=\"headerlink\" title=\"整合了I/O Kit\"></a>整合了I/O Kit</h3><h2 id=\"iOS的launchDeamon\"><a href=\"#iOS的launchDeamon\" class=\"headerlink\" title=\"iOS的launchDeamon\"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\" alt=\"launchDeamon\"></p>\n<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>\n<h3 id=\"lockdownd\"><a href=\"#lockdownd\" class=\"headerlink\" title=\"lockdownd\"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>\n<h3 id=\"SpringBoard\"><a href=\"#SpringBoard\" class=\"headerlink\" title=\"SpringBoard\"></a>SpringBoard</h3><ul>\n<li>创建GUI</li>\n<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>\n<li>SpringBoard包含大量的线程，比如：<ul>\n<li>有Web相关的线程（WebCore和WebThread）</li>\n<li>WiFiManager</li>\n<li>CoreAnimation</li>\n</ul>\n</li>\n<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>\n</ul>\n<h2 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h2><ul>\n<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_barrier</div><div class=\"line\">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message_with_reply</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_object_t</div><div class=\"line\">xpc_connection_send_message_with_reply_sync</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>\n<ul>\n<li>XPC的例子可以参照：苹果官方的<a href=\"https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\" target=\"_blank\" rel=\"external\">SandboxedFetch</a></li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"launchd\"><a href=\"#launchd\" class=\"headerlink\" title=\"launchd\"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>\n<ul>\n<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>\n<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>\n</ul>\n<h2 id=\"launchd的职责\"><a href=\"#launchd的职责\" class=\"headerlink\" title=\"launchd的职责\"></a>launchd的职责</h2><h3 id=\"运行定时作业\"><a href=\"#运行定时作业\" class=\"headerlink\" title=\"运行定时作业\"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>\n<h3 id=\"提供自举服务\"><a href=\"#提供自举服务\" class=\"headerlink\" title=\"提供自举服务\"></a>提供自举服务<servers/bootstrap.h></h3><ul>\n<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>\n<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</li>\n</ul>\n<h3 id=\"事物支持\"><a href=\"#事物支持\" class=\"headerlink\" title=\"事物支持\"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>\n<h3 id=\"资源限制和遏制\"><a href=\"#资源限制和遏制\" class=\"headerlink\" title=\"资源限制和遏制\"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>\n<h3 id=\"Autorun模拟和文件系统观察\"><a href=\"#Autorun模拟和文件系统观察\" class=\"headerlink\" title=\"Autorun模拟和文件系统观察\"></a>Autorun模拟和文件系统观察</h3><ul>\n<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>\n<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>\n</ul>\n<h3 id=\"整合了I-O-Kit\"><a href=\"#整合了I-O-Kit\" class=\"headerlink\" title=\"整合了I/O Kit\"></a>整合了I/O Kit</h3><h2 id=\"iOS的launchDeamon\"><a href=\"#iOS的launchDeamon\" class=\"headerlink\" title=\"iOS的launchDeamon\"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\" alt=\"launchDeamon\"></p>\n<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>\n<h3 id=\"lockdownd\"><a href=\"#lockdownd\" class=\"headerlink\" title=\"lockdownd\"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>\n<h3 id=\"SpringBoard\"><a href=\"#SpringBoard\" class=\"headerlink\" title=\"SpringBoard\"></a>SpringBoard</h3><ul>\n<li>创建GUI</li>\n<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>\n<li>SpringBoard包含大量的线程，比如：<ul>\n<li>有Web相关的线程（WebCore和WebThread）</li>\n<li>WiFiManager</li>\n<li>CoreAnimation</li>\n</ul>\n</li>\n<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>\n</ul>\n<h2 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h2><ul>\n<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_barrier</div><div class=\"line\">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message_with_reply</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_object_t</div><div class=\"line\">xpc_connection_send_message_with_reply_sync</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>\n<ul>\n<li>XPC的例子可以参照：苹果官方的<a href=\"https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\">SandboxedFetch</a></li>\n</ul>\n<hr>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciudkhr0t0005gv04b4mnbt3g","category_id":"ciudkhr1b000cgv042v24pvmr","_id":"ciudkhr1j000mgv04a05klbpj"},{"post_id":"ciudkhr200016gv04e3z9wog2","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2h001ggv04s4sq89b9"},{"post_id":"ciudkhr200016gv04e3z9wog2","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr2j001igv04jfxa9098"},{"post_id":"ciudkhr0l0002gv043gvygz15","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2l001mgv0446pusler"},{"post_id":"ciudkhr0l0002gv043gvygz15","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr2l001ogv04ru939ubh"},{"post_id":"ciudkhr1d000egv04zd388mam","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2n001tgv04jat20zez"},{"post_id":"ciudkhr1d000egv04zd388mam","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr2p001wgv04p29qc6ri"},{"post_id":"ciudkhr1e000ggv041bbpdexn","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2p001zgv04ly72ciqp"},{"post_id":"ciudkhr1e000ggv041bbpdexn","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr2q0021gv04tbnga6nt"},{"post_id":"ciudkhr1g000kgv04oj4c3y1s","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2r0022gv045dexpmr6"},{"post_id":"ciudkhr1g000kgv04oj4c3y1s","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr2r0025gv04uvh5xb9q"},{"post_id":"ciudkhr0x0006gv04z7bbwagj","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2s0027gv045bkbwul6"},{"post_id":"ciudkhr0x0006gv04z7bbwagj","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr2t0029gv048ai2nndf"},{"post_id":"ciudkhr0x0006gv04z7bbwagj","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr2u002agv04ctbl33gi"},{"post_id":"ciudkhr1i000lgv04cfq9nlq2","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2v002cgv04k6r2rl5n"},{"post_id":"ciudkhr1i000lgv04cfq9nlq2","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr2w002dgv04r47819vx"},{"post_id":"ciudkhr0e0000gv04xl8v8f8t","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr2w002fgv04l1jhx8ye"},{"post_id":"ciudkhr0e0000gv04xl8v8f8t","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr2x002ggv043rzoy94d"},{"post_id":"ciudkhr0e0000gv04xl8v8f8t","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr2z002igv04uepcghho"},{"post_id":"ciudkhr1n000rgv04043n16v0","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr30002jgv04qk0j2232"},{"post_id":"ciudkhr1n000rgv04043n16v0","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr31002lgv042aezolho"},{"post_id":"ciudkhr1n000rgv04043n16v0","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr31002mgv04vv5a4506"},{"post_id":"ciudkhr1r000ugv04tauhzgfj","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr31002ogv04r31t38mf"},{"post_id":"ciudkhr1r000ugv04tauhzgfj","category_id":"ciudkhr1z0014gv042txb1a06","_id":"ciudkhr33002pgv04kdc15elq"},{"post_id":"ciudkhr120007gv04esirki3w","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr34002rgv04ynrv06jj"},{"post_id":"ciudkhr120007gv04esirki3w","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr34002sgv041ww68agy"},{"post_id":"ciudkhr120007gv04esirki3w","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr35002ugv04uiw2sll1"},{"post_id":"ciudkhr1t000xgv04watp3nmd","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr35002vgv04lg7n7zn0"},{"post_id":"ciudkhr1t000xgv04watp3nmd","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr36002xgv048dssr1u0"},{"post_id":"ciudkhr1t000xgv04watp3nmd","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr36002ygv04vhn7i5zs"},{"post_id":"ciudkhr1w0010gv042p279zhr","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr360030gv04owe1j7ft"},{"post_id":"ciudkhr1w0010gv042p279zhr","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr360031gv04cf1lf25f"},{"post_id":"ciudkhr1w0010gv042p279zhr","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr370033gv04gubw57b4"},{"post_id":"ciudkhr18000agv04ewuuqtlk","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr370034gv04r2n34opn"},{"post_id":"ciudkhr18000agv04ewuuqtlk","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr370036gv04ijch65y5"},{"post_id":"ciudkhr18000agv04ewuuqtlk","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr380037gv04rnjexnwb"},{"post_id":"ciudkhr1y0013gv043outbhm0","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr380038gv0455h8kimn"},{"post_id":"ciudkhr1y0013gv043outbhm0","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr380039gv04mch2vh4k"},{"post_id":"ciudkhr1y0013gv043outbhm0","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr38003agv041gk681vk"},{"post_id":"ciudkhr230019gv04fza253k3","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr39003bgv04nsnzt5vy"},{"post_id":"ciudkhr230019gv04fza253k3","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr39003cgv0436q6653h"},{"post_id":"ciudkhr230019gv04fza253k3","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr39003dgv04tjue6odi"},{"post_id":"ciudkhr2a001cgv04gglo8flb","category_id":"ciudkhr36002zgv04lmmoa2lp","_id":"ciudkhr39003egv049dhm6hfs"},{"post_id":"ciudkhr1b000bgv04h5e8bpsx","category_id":"ciudkhr29001bgv04iew6eaej","_id":"ciudkhr39003fgv04jgiehd96"},{"post_id":"ciudkhr1b000bgv04h5e8bpsx","category_id":"ciudkhr360032gv04ed9xbn5z","_id":"ciudkhr39003ggv04hnccs7a1"},{"post_id":"ciudkhr2h001fgv048zfylm36","category_id":"ciudkhr0q0003gv04k5axk36y","_id":"ciudkhr3a003hgv04l6tfjebk"},{"post_id":"ciudkhr2h001fgv048zfylm36","category_id":"ciudkhr1f000igv04h2hwsw6l","_id":"ciudkhr3a003igv0421tkvpta"},{"post_id":"ciudkhr2h001fgv048zfylm36","category_id":"ciudkhr2q0020gv04vw875jnv","_id":"ciudkhr3a003jgv04xpnnnqp4"}],"PostTag":[{"post_id":"ciudkhr0e0000gv04xl8v8f8t","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr1e000fgv04u8ci2mqb"},{"post_id":"ciudkhr0e0000gv04xl8v8f8t","tag_id":"ciudkhr140009gv04icubmhtz","_id":"ciudkhr1f000hgv04cb67g8xh"},{"post_id":"ciudkhr0t0005gv04b4mnbt3g","tag_id":"ciudkhr1c000dgv04qgnacxjv","_id":"ciudkhr1m000qgv04alroazzm"},{"post_id":"ciudkhr0t0005gv04b4mnbt3g","tag_id":"ciudkhr1g000jgv04ydwuxheh","_id":"ciudkhr1q000tgv04zoki35mc"},{"post_id":"ciudkhr1n000rgv04043n16v0","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr1s000wgv04rsrw0zsc"},{"post_id":"ciudkhr0x0006gv04z7bbwagj","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr1v000zgv04t7c012oc"},{"post_id":"ciudkhr0x0006gv04z7bbwagj","tag_id":"ciudkhr1l000ogv045bht6j46","_id":"ciudkhr1x0012gv04s1o6bsay"},{"post_id":"ciudkhr1t000xgv04watp3nmd","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr1z0015gv04xw0x0iey"},{"post_id":"ciudkhr120007gv04esirki3w","tag_id":"ciudkhr1l000ogv045bht6j46","_id":"ciudkhr230018gv0428is2dkw"},{"post_id":"ciudkhr1w0010gv042p279zhr","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr28001agv04qy3iup4c"},{"post_id":"ciudkhr1y0013gv043outbhm0","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr2g001egv04mtyuaawu"},{"post_id":"ciudkhr18000agv04ewuuqtlk","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr2i001hgv04b3r299fj"},{"post_id":"ciudkhr18000agv04ewuuqtlk","tag_id":"ciudkhr1l000ogv045bht6j46","_id":"ciudkhr2l001lgv04cskkhqdo"},{"post_id":"ciudkhr230019gv04fza253k3","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr2l001ngv046yynfufk"},{"post_id":"ciudkhr1b000bgv04h5e8bpsx","tag_id":"ciudkhr210017gv04r8o190ot","_id":"ciudkhr2m001rgv04ft14by0s"},{"post_id":"ciudkhr1b000bgv04h5e8bpsx","tag_id":"ciudkhr1g000jgv04ydwuxheh","_id":"ciudkhr2n001sgv04imo5dgxw"},{"post_id":"ciudkhr1r000ugv04tauhzgfj","tag_id":"ciudkhr2j001kgv04a8m25ggy","_id":"ciudkhr2p001vgv04tywkmkxr"},{"post_id":"ciudkhr2a001cgv04gglo8flb","tag_id":"ciudkhr2m001qgv044gc3iyyu","_id":"ciudkhr2p001ygv04fa8syjn0"},{"post_id":"ciudkhr2h001fgv048zfylm36","tag_id":"ciudkhr0s0004gv0457ri3rg1","_id":"ciudkhr2r0023gv0486f34emc"},{"post_id":"ciudkhr2h001fgv048zfylm36","tag_id":"ciudkhr2p001xgv046tl3he9b","_id":"ciudkhr2r0026gv04d9qpi7x9"}],"Tag":[{"name":"内核","_id":"ciudkhr0s0004gv0457ri3rg1"},{"name":"编译","_id":"ciudkhr140009gv04icubmhtz"},{"name":"H5","_id":"ciudkhr1c000dgv04qgnacxjv"},{"name":"JS","_id":"ciudkhr1g000jgv04ydwuxheh"},{"name":"Mach","_id":"ciudkhr1l000ogv045bht6j46"},{"name":"React","_id":"ciudkhr210017gv04r8o190ot"},{"name":"Cocoapods","_id":"ciudkhr2j001kgv04a8m25ggy"},{"name":"学习方法","_id":"ciudkhr2m001qgv044gc3iyyu"},{"name":"launchd","_id":"ciudkhr2p001xgv046tl3he9b"}]}}