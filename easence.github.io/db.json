{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"47e3e6ea94ae1feb58b49f5550ca0eebb9a6f7aa","modified":1479198926000},{"_id":"themes/next/.DS_Store","hash":"cdd51829c6e43608c538d0e3afb6bc51f0945591","modified":1479199741000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1479196756000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1479196756000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1479196756000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1479196756000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1479196756000},{"_id":"themes/next/_config.yml","hash":"ac9bb71a024ad77484cb09583c9907d89d281ac9","modified":1479200225000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1479196756000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1479196756000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1479196756000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1479196756000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1479196756000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1479196756000},{"_id":"source/categories/index.md","hash":"6c08bfbf9f2886cb743d160ea4cfb7d49eb93180","modified":1476677263000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1476675435000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1476839610000},{"_id":"source/_posts/H5的体验优化.md","hash":"a6eaaadd1b10072978ed924b168150c77afa8300","modified":1476677413000},{"_id":"source/_posts/Building xnu for OS X 10.11 El Capitan.md","hash":"ee9ad19a3ab82b71ac61e9de4c248f525b2ad420","modified":1476795860000},{"_id":"source/_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","hash":"9e26be70b2e590fbb39aff0519a342f72f070fc7","modified":1476675868000},{"_id":"source/_posts/Mach-O格式文件(用户态下的进程加载).md","hash":"94d7342e0b89dc026105fc32c4a3c8d465e16cc6","modified":1476795822000},{"_id":"source/_posts/Mach调度.md","hash":"17fee55df081e5fd8aee0628722930b3d995bd08","modified":1476795835000},{"_id":"source/_posts/TheResponderChain.md","hash":"c39c43d6b94a65939f990d7bba7a12c7ac3a3a46","modified":1479193674000},{"_id":"source/_posts/React Native笔记.md","hash":"a202866e9d7ab10a6c2801cef4047e51a09378da","modified":1476689066000},{"_id":"source/_posts/Mach原语：一起以消息为媒介.md","hash":"4483d882d741f89a487dee3a098f49d57fd729d5","modified":1476795849000},{"_id":"source/_posts/Thrift的二进制数据编解码-以OC为例.md","hash":"ea971736db3cd9858857d9f2e1971dc996f6d49e","modified":1476533851000},{"_id":"source/_posts/iOS中的MAX-A-B-，需要注意的点.md","hash":"b5d581bd281ad1c19e52e7d40ea8faba21c8dd3c","modified":1476530655000},{"_id":"source/_posts/iOS引导页的镂空效果.md","hash":"a97a9c3d033784c1b47b86b58825bf27b897f927","modified":1476530949000},{"_id":"source/_posts/iOS支持懒加载的PageViewController.md","hash":"0459482711792b36c524def45100ac3acaef2f9a","modified":1476533611000},{"_id":"source/_posts/iOS签名.md","hash":"a80eedec1dec6f34cbd01a9b5fc776d221da5964","modified":1476681114000},{"_id":"source/_posts/内核架构.md","hash":"52af1f769e82b8094f302a4af5fd46fd55823bcc","modified":1479193886000},{"_id":"source/_posts/从code7到xcode8都有哪些坑？.md","hash":"76ed5ec972c7dbf7372fb51200e1ba475a565c50","modified":1479193718000},{"_id":"source/_posts/创建pod库的步骤.md","hash":"945e342f28e7cec38f5df4a682c7089352c85cca","modified":1476677365000},{"_id":"source/_posts/引导过程：EFI和iBoot.md","hash":"c94b83991084657fa6b35faa60765f2a6b009514","modified":1479200865000},{"_id":"source/_posts/文件系统和虚拟文件系统交换（VFS）.md","hash":"811a48eb64ce54bf4897de4903d485da19404844","modified":1476795919000},{"_id":"source/_posts/由生到死--内核引导和内核崩溃.md","hash":"bc2d5c950d9e6ddd31a50806f21a4f5786c740b5","modified":1476795909000},{"_id":"source/_posts/网络七层协议（结合操作系统来了解）.md","hash":"d5ff6a21a743d90e0e4fb3a392761c32eeb4fd0d","modified":1476795893000},{"_id":"source/_posts/简约的iOS音乐播放UI控件.md","hash":"5f61f73f32bedcb2b28274cbd73ac0c206c8523d","modified":1476531344000},{"_id":"source/_posts/苹果的文字系统.md","hash":"258bf9b90389068139cc3aa79671a730d584ccc5","modified":1479193308000},{"_id":"source/_posts/读书笔记之《如何阅读一本书》.md","hash":"78b0b0e0abf0e615b9b9cfaddc47889ec8154667","modified":1476960518000},{"_id":"source/_posts/贯穿始终-launchd.md","hash":"58602541c4b2dd104604d8f466830c3f596d7015","modified":1476795878000},{"_id":"source/_posts/高效学习法.md","hash":"46039dc08facc2c8dda032375cec773b800385c5","modified":1479200825000},{"_id":"source/_drafts/swift_100_tips笔记.md","hash":"3e0e643e3e78aea5d8a4cb9a892ceff69410e3b1","modified":1477880727000},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1477549557000},{"_id":"source/_drafts/时间管理.md","hash":"b6209eaef5753a24ff746b05f1dcc2a21b698444","modified":1477016327000},{"_id":"source/_drafts/编译过程预览.md","hash":"f334a0bb07e6e5f6bdb98ec5573951c2b913ce70","modified":1478569943000},{"_id":"source/tags/index.md","hash":"24d4749d12b9eeb9d94b622d1082ffded236272a","modified":1476677252000},{"_id":"themes/next/.git/FETCH_HEAD","hash":"d038847b1b4bb0568d712d5a917c3e595e3db1d3","modified":1479199521000},{"_id":"themes/next/.git/ORIG_HEAD","hash":"b501e81e63e8e9b5287e73d9ed7f9dc9688c074f","modified":1479199521000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1479196756000},{"_id":"themes/next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1479196756000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1479196578000},{"_id":"themes/next/.git/packed-refs","hash":"7ad631fcd1c8e21b38e561b9ff6f43d2e57ef0bd","modified":1479196756000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1479196756000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1479196756000},{"_id":"themes/next/.git/index","hash":"cbbd6d824f31f6c97c099c705bbd3099b3e4118a","modified":1479199509000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1479196756000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1479196756000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1479196756000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1479196756000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1479196756000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1479196756000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1479196756000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1479196756000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1479196756000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1479196756000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1479196756000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1479196756000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1479196756000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1479196756000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1479196756000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1479196756000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1479196756000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1479196756000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1479196756000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1479196756000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1479196756000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1479196756000},{"_id":"source/images/avatar.jpg","hash":"36db1779bb7cccbd55d8af4c52db5623815a26f4","modified":1476675371000},{"_id":"themes/next/source/.DS_Store","hash":"8f88ccc54ec777df39e223a0f6f44dac6848d878","modified":1479199769000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1479196756000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1479196756000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1479196756000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1479196578000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1479196578000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1479196578000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1479196578000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1479196578000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1479196578000},{"_id":"themes/next/.git/logs/HEAD","hash":"bf7ebf87d0d8bb5f6b7d05661f0900808ffe53f9","modified":1479199064000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1479196756000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1479196756000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1479196756000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1479196756000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1479196756000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1479196756000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1479196756000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f12f108c1f8e91cc55d49805d42c1fd96cdf51a6","modified":1479196756000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1479196756000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1479196756000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b8aaa008aafe4c6e325f7513719e1c251430883e","modified":1479196756000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a3ef28678467c45ee9416b41b943252e8036285","modified":1479196756000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1479196756000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1479196756000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1a43dde8c7bc53891be26b915a172b1f01e6bc26","modified":1479196756000},{"_id":"themes/next/layout/_partials/header.swig","hash":"f3627f51810bc906e4020a3fef61bc3629b63581","modified":1479196756000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1479196756000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1479196756000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1479196756000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1479196756000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1479196756000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1479196756000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1479196756000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1479196756000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1479196756000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1479196756000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1479196756000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1479196756000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1479196756000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1479196756000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1479196756000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1479196756000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1479196756000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/.git/objects/43/c060e63b216c0b5f320169ffc212840850a006","hash":"d1bbcb8324fb77ff35731c7534eb725f9b0770b5","modified":1479199064000},{"_id":"themes/next/.git/objects/1e/b53ecd31047d73027f22e7a2c345b925c911dc","hash":"27d43a2dfb7eb5f0c95f88e0b89246faf7b2e543","modified":1479199064000},{"_id":"themes/next/.git/objects/7d/26849a2097ef47d3b3c1212bc9c4f9deb3438a","hash":"fab1dfcfa4bb6a567e2f456c2e2ae49a1c25fc6d","modified":1479199064000},{"_id":"themes/next/.git/objects/45/ec67b62c7eb2ac736b710332c4f31f95bf5041","hash":"5a5e314d5b28933c893b5c712eae64a2f13ce816","modified":1479199064000},{"_id":"themes/next/.git/refs/heads/master","hash":"b501e81e63e8e9b5287e73d9ed7f9dc9688c074f","modified":1479199064000},{"_id":"themes/next/.git/objects/54/ff1d7576540fb9d1c77229f216df993da9ebf7","hash":"b7e9978df43fefb700a7b1592aea1215ee0268ce","modified":1479199064000},{"_id":"themes/next/.git/objects/50/dd6a5b8952b1d1ca6883bb461e99f744604637","hash":"9004ed2ab9a0735c07b1fc4c11a62add709670f8","modified":1479199064000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1479196756000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1479196756000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1479196756000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1479196756000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1479196756000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1479196756000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1479196756000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1479196756000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"82a2ac14d4200480a36bf10abcc3cc554ad744d6","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1479196756000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1479196756000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1479196756000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c5b28519b446c2af1e8754a6ae4d766823e6b348","modified":1479199064000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f0d6aa424f434e82ea507f740eeff110f996269","modified":1479196756000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1479196756000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1479196756000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1479196756000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1479196756000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1479196756000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1479196756000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1479196756000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1479196756000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1479196756000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1479196756000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1479196756000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"bf7ebf87d0d8bb5f6b7d05661f0900808ffe53f9","modified":1479199064000},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"b501e81e63e8e9b5287e73d9ed7f9dc9688c074f","modified":1479199064000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1479196756000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479196756000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1479196756000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1479196756000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1479196756000},{"_id":"themes/next/.git/objects/pack/pack-2d45224840110dc56fda8ece871300ad228db9e7.idx","hash":"89d97b90daa231249711a5269fb2e06c8b8499aa","modified":1479196755000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1479196756000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"f043b2ebf4717652c9a95cae513d9abc75cb21a0","modified":1479196756000},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"087e9342cb2ec6938f13c5475035e9e12d220351","modified":1479199064000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"5357db10656b260f8b332c67bb06e486bc64a4ad","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5433b6bc9d8f0c4685e760b326445ac51245b0a8","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1479196756000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1479196756000},{"_id":"themes/next/.git/objects/pack/pack-2d45224840110dc56fda8ece871300ad228db9e7.pack","hash":"45318f9038e59f721a9dba3087f3991e71fc0808","modified":1479196755000}],"Category":[{"name":"Web","_id":"civja2md300040k04lhltcln7"},{"name":"Apple Development","_id":"civja2mdl00090k04q35zny8f"},{"name":"iOS开发笔记","parent":"civja2mdl00090k04q35zny8f","_id":"civja2mem000u0k04tcbdh92i"},{"name":"深入解析Mac OS X && iOS操作系统笔记","parent":"civja2mdl00090k04q35zny8f","_id":"civja2mev000z0k04ighzgdiz"},{"name":"JS","_id":"civja2mf300150k04yx0blabq"},{"name":"安全","parent":"civja2mdl00090k04q35zny8f","_id":"civja2mgp002o0k04exoi7utc"},{"name":"React Native","parent":"civja2mf300150k04yx0blabq","_id":"civja2mgs002y0k04ejlsf3ct"},{"name":"iOS开发笔记","_id":"civja2mgt00340k049dd1glih"},{"name":"方法论","_id":"civja2mgv00390k04r0k4ey0n"},{"name":"编译系统","_id":"civja2mh7003j0k04ocia4zrd"}],"Data":[],"Page":[{"title":"categories","date":"2016-10-17T04:04:17.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-10-17 12:04:17\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-10-17T04:07:43.000Z","path":"categories/index.html","layout":"page","_id":"civja2mcl00000k04inq8zdk7","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-10-17T04:04:24.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-10-17 12:04:24\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-10-17T04:07:32.000Z","path":"tags/index.html","layout":"page","_id":"civja2mcy00020k04q5318eg8","content":"","excerpt":"","more":""}],"Post":[{"title":"H5的体验优化","_content":"\n## H5跟Native的性能对比\n- native可以做缓存，第二次访问可以实现秒开。\n- 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。\n- webView的加载需要耗时，网络建立连接也需要时间。\n\n## 未采用的优化H5的方案\n- 离线包+预加载。\n缺点：\n1. 主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。\n2. 离线包发布效率低下。\n3. 由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。\n\n## 比较好的优化方案\n1. 由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。\n2. 将HTTP改成了Socket。\n3. 通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。\n\n## 进一步优化\n1. H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。\n2. 模板也需要制定一套更新的机制。\n\n## React Native\n- 针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。\n\n要点提炼自：[QQ空间面向移动时代Hybrid架构设计][1]\n[1]: http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650993637&idx=1&sn=8a2673272575abbef4b0f6dbc25e0186&scene=0#wechat_redirect\n","source":"_posts/H5的体验优化.md","raw":"---\ntitle: H5的体验优化\ncategories: \n - Web \ntags:\n - H5\n - JS\n---\n\n## H5跟Native的性能对比\n- native可以做缓存，第二次访问可以实现秒开。\n- 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。\n- webView的加载需要耗时，网络建立连接也需要时间。\n\n## 未采用的优化H5的方案\n- 离线包+预加载。\n缺点：\n1. 主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。\n2. 离线包发布效率低下。\n3. 由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。\n\n## 比较好的优化方案\n1. 由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。\n2. 将HTTP改成了Socket。\n3. 通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。\n\n## 进一步优化\n1. H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。\n2. 模板也需要制定一套更新的机制。\n\n## React Native\n- 针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。\n\n要点提炼自：[QQ空间面向移动时代Hybrid架构设计][1]\n[1]: http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650993637&idx=1&sn=8a2673272575abbef4b0f6dbc25e0186&scene=0#wechat_redirect\n","slug":"H5的体验优化","published":1,"date":"2016-08-30T02:04:48.000Z","updated":"2016-10-17T04:10:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mcp00010k04vw7p1xh7","content":"<h2 id=\"H5跟Native的性能对比\"><a href=\"#H5跟Native的性能对比\" class=\"headerlink\" title=\"H5跟Native的性能对比\"></a>H5跟Native的性能对比</h2><ul>\n<li>native可以做缓存，第二次访问可以实现秒开。</li>\n<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>\n<li>webView的加载需要耗时，网络建立连接也需要时间。</li>\n</ul>\n<h2 id=\"未采用的优化H5的方案\"><a href=\"#未采用的优化H5的方案\" class=\"headerlink\" title=\"未采用的优化H5的方案\"></a>未采用的优化H5的方案</h2><ul>\n<li>离线包+预加载。<br>缺点：</li>\n</ul>\n<ol>\n<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>\n<li>离线包发布效率低下。</li>\n<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>\n</ol>\n<h2 id=\"比较好的优化方案\"><a href=\"#比较好的优化方案\" class=\"headerlink\" title=\"比较好的优化方案\"></a>比较好的优化方案</h2><ol>\n<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>\n<li>将HTTP改成了Socket。</li>\n<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>\n</ol>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><ol>\n<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>\n<li>模板也需要制定一套更新的机制。</li>\n</ol>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>\n</ul>\n<p>要点提炼自：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">QQ空间面向移动时代Hybrid架构设计</a></p>\n","excerpt":"","more":"<h2 id=\"H5跟Native的性能对比\"><a href=\"#H5跟Native的性能对比\" class=\"headerlink\" title=\"H5跟Native的性能对比\"></a>H5跟Native的性能对比</h2><ul>\n<li>native可以做缓存，第二次访问可以实现秒开。</li>\n<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>\n<li>webView的加载需要耗时，网络建立连接也需要时间。</li>\n</ul>\n<h2 id=\"未采用的优化H5的方案\"><a href=\"#未采用的优化H5的方案\" class=\"headerlink\" title=\"未采用的优化H5的方案\"></a>未采用的优化H5的方案</h2><ul>\n<li>离线包+预加载。<br>缺点：</li>\n</ul>\n<ol>\n<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>\n<li>离线包发布效率低下。</li>\n<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>\n</ol>\n<h2 id=\"比较好的优化方案\"><a href=\"#比较好的优化方案\" class=\"headerlink\" title=\"比较好的优化方案\"></a>比较好的优化方案</h2><ol>\n<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>\n<li>将HTTP改成了Socket。</li>\n<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>\n</ol>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><ol>\n<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>\n<li>模板也需要制定一套更新的机制。</li>\n</ol>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>\n</ul>\n<p>要点提炼自：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect\">QQ空间面向移动时代Hybrid架构设计</a></p>\n"},{"title":"Building xnu for OS X 10.11 El Capitan","_content":"\n\n*此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份。*\n\nThe OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: [here](https://opensource.apple.com/source/xnu/xnu-3247.1.106/)\n\nBuilding xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:\n\n1. Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with \"sudo xcodebuild -license\"\n2. Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself\n\n\t```\n    $ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz\n\t```\n    \n3. Build and install CTF tools from dtrace\n\n\t```\n    $ tar zxf dtrace-168.tar.gz\n    $ cd dtrace-168\n    $ mkdir -p obj sym dst\n    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=\"x86_64\" SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    ...\n    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain\n    Password:\n    $ cd ..\n\t```    \n\n4. Install AvailabilityVersions\n\n\t```\n    $ tar zxf AvailabilityVersions-20.tar.gz \n    $ cd AvailabilityVersions-20\n    $ mkdir -p dst\n    $ make install SRCROOT=$PWD DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst/usr/local `xcrun -sdk macosx -show-sdk-path`/usr/local\n    $ cd ..\n\t```\n\n5. Build xnu\n\n\t```\n    $ tar zxf xnu-3247.1.106.tar.gz\n    $ cd xnu-3247.1.106\n    $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\n\t```\n\n**See xnu's top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**\n\nUpdate: If you are attempting to add system calls, you may also need to build Libsyscall.\n\n1. Download the Libsystem source\n\n\t```\n\t$ curl -O https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\n\t```\n\n2. Install Libsystem headers\n\n\t```\n    $ tar zxf Libsystem-1225.1.1.tar.gz\n    $ cd Libsystem-1225.1.1\n    $ xcodebuild installhdrs -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst `xcrun -sdk macosx -show-sdk-path`\n    $ cd ..\n    ```\n3. Install xnu and Libsyscall headers\n\t\n\t```\n    $ cd xnu-3247.1.106\n    $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst\n    $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo ditto BUILD.hdrs/dst `xcrun -sdk macosx -show-sdk-path`\n    ```\n4. Build Libsyscall\n\n\t```\n    $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst\n    $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst\n    ```\n5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).\n\n6. To install the resulting new binaries, execute:\n  \t1. xnu: \n\t\n\t\t```\n\t    $ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n\t    $ sudo kextcache -invalidate /\n\t    / locked; waiting for lock.\n\t    Lock acquired; proceeding.\n\t    ...\n\t    $ sudo reboot\n   \t\t ```\n  \t2. Libsyscall: \n\t\t\n\t\t```\n        $ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n\t    $ sudo update_dyld_shared_cache\n\t    ...\n\t    $ sudo reboot\n    \t```\n\n---\n[1]: http://shantonu.blogspot.co.uk","source":"_posts/Building xnu for OS X 10.11 El Capitan.md","raw":"---\ntitle: Building xnu for OS X 10.11 El Capitan\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n - XNU\n---\n\n\n*此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份。*\n\nThe OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: [here](https://opensource.apple.com/source/xnu/xnu-3247.1.106/)\n\nBuilding xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:\n\n1. Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with \"sudo xcodebuild -license\"\n2. Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself\n\n\t```\n    $ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz\n\t```\n    \n3. Build and install CTF tools from dtrace\n\n\t```\n    $ tar zxf dtrace-168.tar.gz\n    $ cd dtrace-168\n    $ mkdir -p obj sym dst\n    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=\"x86_64\" SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    ...\n    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain\n    Password:\n    $ cd ..\n\t```    \n\n4. Install AvailabilityVersions\n\n\t```\n    $ tar zxf AvailabilityVersions-20.tar.gz \n    $ cd AvailabilityVersions-20\n    $ mkdir -p dst\n    $ make install SRCROOT=$PWD DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst/usr/local `xcrun -sdk macosx -show-sdk-path`/usr/local\n    $ cd ..\n\t```\n\n5. Build xnu\n\n\t```\n    $ tar zxf xnu-3247.1.106.tar.gz\n    $ cd xnu-3247.1.106\n    $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\n\t```\n\n**See xnu's top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**\n\nUpdate: If you are attempting to add system calls, you may also need to build Libsyscall.\n\n1. Download the Libsystem source\n\n\t```\n\t$ curl -O https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\n\t```\n\n2. Install Libsystem headers\n\n\t```\n    $ tar zxf Libsystem-1225.1.1.tar.gz\n    $ cd Libsystem-1225.1.1\n    $ xcodebuild installhdrs -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst `xcrun -sdk macosx -show-sdk-path`\n    $ cd ..\n    ```\n3. Install xnu and Libsyscall headers\n\t\n\t```\n    $ cd xnu-3247.1.106\n    $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst\n    $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo ditto BUILD.hdrs/dst `xcrun -sdk macosx -show-sdk-path`\n    ```\n4. Build Libsyscall\n\n\t```\n    $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst\n    $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst\n    ```\n5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).\n\n6. To install the resulting new binaries, execute:\n  \t1. xnu: \n\t\n\t\t```\n\t    $ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n\t    $ sudo kextcache -invalidate /\n\t    / locked; waiting for lock.\n\t    Lock acquired; proceeding.\n\t    ...\n\t    $ sudo reboot\n   \t\t ```\n  \t2. Libsyscall: \n\t\t\n\t\t```\n        $ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n\t    $ sudo update_dyld_shared_cache\n\t    ...\n\t    $ sudo reboot\n    \t```\n\n---\n[1]: http://shantonu.blogspot.co.uk","slug":"Building xnu for OS X 10.11 El Capitan","published":1,"date":"2016-09-08T02:36:41.000Z","updated":"2016-10-18T13:04:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2md000030k04tn2vbl0o","content":"<p><em>此文只因为国内浏览<a href=\"http://shantonu.blogspot.co.uk\" target=\"_blank\" rel=\"external\">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>\n<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href=\"https://opensource.apple.com/source/xnu/xnu-3247.1.106/\" target=\"_blank\" rel=\"external\">here</a></p>\n<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>\n<ol>\n<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>\n<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>Build and install CTF tools from dtrace</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    $ tar zxf dtrace-168.tar.gz</div><div class=\"line\">    $ cd dtrace-168</div><div class=\"line\">    $ mkdir -p obj sym dst</div><div class=\"line\">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class=\"line\">    ...</div><div class=\"line\">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class=\"line\">    Password:</div><div class=\"line\">    $ cd ..</div><div class=\"line\">\t```    </div><div class=\"line\"></div><div class=\"line\">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>\n<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. Build xnu</div></pre></td></tr></table></figure>\n<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**</div><div class=\"line\"></div><div class=\"line\">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class=\"line\"></div><div class=\"line\">1. Download the Libsystem source</div></pre></td></tr></table></figure>\n<p> $ curl -O <a href=\"https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\" target=\"_blank\" rel=\"external\">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">2. Install Libsystem headers</div></pre></td></tr></table></figure>\n<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>\n<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">4. Build Libsyscall</div></pre></td></tr></table></figure>\n<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class=\"line\"></div><div class=\"line\">6. To install the resulting new binaries, execute:</div><div class=\"line\">  \t1. xnu:</div></pre></td></tr></table></figure>\n<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n$ sudo kextcache -invalidate /\n/ locked; waiting for lock.\nLock acquired; proceeding.\n...\n$ sudo reboot\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2. Libsyscall:</div></pre></td></tr></table></figure>\n\n$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n$ sudo update_dyld_shared_cache\n...\n$ sudo reboot\n```\n</code></pre></li>\n</ol>\n<hr>\n","excerpt":"","more":"<p><em>此文只因为国内浏览<a href=\"http://shantonu.blogspot.co.uk\">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>\n<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href=\"https://opensource.apple.com/source/xnu/xnu-3247.1.106/\">here</a></p>\n<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>\n<ol>\n<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>\n<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>Build and install CTF tools from dtrace</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    $ tar zxf dtrace-168.tar.gz</div><div class=\"line\">    $ cd dtrace-168</div><div class=\"line\">    $ mkdir -p obj sym dst</div><div class=\"line\">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class=\"line\">    ...</div><div class=\"line\">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class=\"line\">    Password:</div><div class=\"line\">    $ cd ..</div><div class=\"line\">\t```    </div><div class=\"line\"></div><div class=\"line\">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>\n<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. Build xnu</div></pre></td></tr></table></figure>\n<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**</div><div class=\"line\"></div><div class=\"line\">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class=\"line\"></div><div class=\"line\">1. Download the Libsystem source</div></pre></td></tr></table></figure>\n<p> $ curl -O <a href=\"https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">2. Install Libsystem headers</div></pre></td></tr></table></figure>\n<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>\n<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">4. Build Libsyscall</div></pre></td></tr></table></figure>\n<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class=\"line\"></div><div class=\"line\">6. To install the resulting new binaries, execute:</div><div class=\"line\">  \t1. xnu:</div></pre></td></tr></table></figure>\n<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n$ sudo kextcache -invalidate /\n/ locked; waiting for lock.\nLock acquired; proceeding.\n...\n$ sudo reboot\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2. Libsyscall:</div></pre></td></tr></table></figure>\n\n$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n$ sudo update_dyld_shared_cache\n...\n$ sudo reboot\n```\n</code></pre></li>\n</ol>\n<hr>\n"},{"title":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","date":"2016-07-09T06:22:30.000Z","_content":"\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n## KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","source":"_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","raw":"---\ntitle: KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\ndate: 2016-07-09 14:22:30\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n## KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","slug":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","published":1,"updated":"2016-10-17T03:44:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mdb00060k04d1svr98v","content":"<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<h2 id=\"KVO是元凶\"><a href=\"#KVO是元凶\" class=\"headerlink\" title=\"KVO是元凶\"></a>KVO是元凶</h2><ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<h2 id=\"KVO是元凶\"><a href=\"#KVO是元凶\" class=\"headerlink\" title=\"KVO是元凶\"></a>KVO是元凶</h2><ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n"},{"title":"Mach-O格式文件(用户态下的进程加载)","_content":"\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mach-O格式文件(用户态下的进程加载).md","raw":"---\ntitle: Mach-O格式文件(用户态下的进程加载)\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - Mach\n---\n\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mach-O格式文件(用户态下的进程加载)","published":1,"date":"2016-09-16T03:07:52.000Z","updated":"2016-10-18T13:03:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mdf00070k042u8ha6ff","content":"<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"Mach调度","_content":"\n## 线程\n线程是个结构体\n## 任务（task）\n线程的容器，是以线程为元素的数组\n## 优先级\n## 运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n## 续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n## 抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n## 异步软件陷阱（AST）\n\n## 定时器中断\n软件定时器：\n硬件定时器：\n## 异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","source":"_posts/Mach调度.md","raw":"---\ntitle: Mach调度\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - Mach\n---\n\n## 线程\n线程是个结构体\n## 任务（task）\n线程的容器，是以线程为元素的数组\n## 优先级\n## 运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n## 续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n## 抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n## 异步软件陷阱（AST）\n\n## 定时器中断\n软件定时器：\n硬件定时器：\n## 异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","slug":"Mach调度","published":1,"date":"2016-08-30T02:12:09.000Z","updated":"2016-10-18T13:03:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mdi00080k04n8ihhe7c","content":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是个结构体</p>\n<h2 id=\"任务（task）\"><a href=\"#任务（task）\" class=\"headerlink\" title=\"任务（task）\"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><h2 id=\"运行队列\"><a href=\"#运行队列\" class=\"headerlink\" title=\"运行队列\"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<h2 id=\"续体\"><a href=\"#续体\" class=\"headerlink\" title=\"续体\"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<h2 id=\"抢占模式\"><a href=\"#抢占模式\" class=\"headerlink\" title=\"抢占模式\"></a>抢占模式</h2><ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<h2 id=\"异步软件陷阱（AST）\"><a href=\"#异步软件陷阱（AST）\" class=\"headerlink\" title=\"异步软件陷阱（AST）\"></a>异步软件陷阱（AST）</h2></li>\n</ul>\n<h2 id=\"定时器中断\"><a href=\"#定时器中断\" class=\"headerlink\" title=\"定时器中断\"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是个结构体</p>\n<h2 id=\"任务（task）\"><a href=\"#任务（task）\" class=\"headerlink\" title=\"任务（task）\"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><h2 id=\"运行队列\"><a href=\"#运行队列\" class=\"headerlink\" title=\"运行队列\"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<h2 id=\"续体\"><a href=\"#续体\" class=\"headerlink\" title=\"续体\"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<h2 id=\"抢占模式\"><a href=\"#抢占模式\" class=\"headerlink\" title=\"抢占模式\"></a>抢占模式</h2><ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<h2 id=\"异步软件陷阱（AST）\"><a href=\"#异步软件陷阱（AST）\" class=\"headerlink\" title=\"异步软件陷阱（AST）\"></a>异步软件陷阱（AST）</h2></li>\n</ul>\n<h2 id=\"定时器中断\"><a href=\"#定时器中断\" class=\"headerlink\" title=\"定时器中断\"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n"},{"title":"iOS的事件处理顺序","date":"2016-10-27T09:23:51.000Z","description":"通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。","_content":"\n\n通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。\n\n## 事件分发\n当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：\n\n![Hit-testing returns the subview that was touched][1]\n\n假设点击了View E。那么这个触摸事件传递的顺序是这样子的：\n\n1. 由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。\n2. 由于触摸区域在C内，因此会检查它的子view D和E。\n3. 最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。\n\n## 事件响应链\n事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。\n\n![The responder chain on iOS][2]\n\n由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：\n\n**view** -> **view'superView** -> ... -> **viewController** -> **window** -> **application**\n\n## 最后\n至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。\n\n## 参考文档\n[Event Delivery: The Responder Chain][3]\n\n---\n\n[1]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\n\n[2]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\n\n[3]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\n","source":"_posts/TheResponderChain.md","raw":"---\ntitle: iOS的事件处理顺序\ncategories: \n- Apple Development\n- iOS开发笔记\ntags: \n- 事件响应链\ndate: 2016-10-27 17:23:51\ndescription: \"通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。\"\n\n---\n\n\n通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。\n\n## 事件分发\n当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：\n\n![Hit-testing returns the subview that was touched][1]\n\n假设点击了View E。那么这个触摸事件传递的顺序是这样子的：\n\n1. 由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。\n2. 由于触摸区域在C内，因此会检查它的子view D和E。\n3. 最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。\n\n## 事件响应链\n事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。\n\n![The responder chain on iOS][2]\n\n由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：\n\n**view** -> **view'superView** -> ... -> **viewController** -> **window** -> **application**\n\n## 最后\n至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。\n\n## 参考文档\n[Event Delivery: The Responder Chain][3]\n\n---\n\n[1]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\n\n[2]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\n\n[3]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\n","slug":"TheResponderChain","published":1,"updated":"2016-11-15T07:07:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mdo000b0k04b6w514mk","content":"<p>通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。</p>\n<h2 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h2><p>当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\" alt=\"Hit-testing returns the subview that was touched\"></p>\n<p>假设点击了View E。那么这个触摸事件传递的顺序是这样子的：</p>\n<ol>\n<li>由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。</li>\n<li>由于触摸区域在C内，因此会检查它的子view D和E。</li>\n<li>最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。</li>\n</ol>\n<h2 id=\"事件响应链\"><a href=\"#事件响应链\" class=\"headerlink\" title=\"事件响应链\"></a>事件响应链</h2><p>事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\" alt=\"The responder chain on iOS\"></p>\n<p>由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：</p>\n<p><strong>view</strong> -&gt; <strong>view’superView</strong> -&gt; … -&gt; <strong>viewController</strong> -&gt; <strong>window</strong> -&gt; <strong>application</strong></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\" target=\"_blank\" rel=\"external\">Event Delivery: The Responder Chain</a></p>\n<hr>\n","excerpt":"","more":"<p>通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。</p>\n<h2 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h2><p>当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\" alt=\"Hit-testing returns the subview that was touched\"></p>\n<p>假设点击了View E。那么这个触摸事件传递的顺序是这样子的：</p>\n<ol>\n<li>由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。</li>\n<li>由于触摸区域在C内，因此会检查它的子view D和E。</li>\n<li>最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。</li>\n</ol>\n<h2 id=\"事件响应链\"><a href=\"#事件响应链\" class=\"headerlink\" title=\"事件响应链\"></a>事件响应链</h2><p>事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\" alt=\"The responder chain on iOS\"></p>\n<p>由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：</p>\n<p><strong>view</strong> -&gt; <strong>view’superView</strong> -&gt; … -&gt; <strong>viewController</strong> -&gt; <strong>window</strong> -&gt; <strong>application</strong></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\">Event Delivery: The Responder Chain</a></p>\n<hr>\n"},{"title":"React Native笔记","_content":"\n## 要点记录\n### 本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // Call long-running code on background thread\n    ...\n    // You can invoke callback from any thread/queue\n    callback(@[...]);\n  });\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@\"name\"];\n  [self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n  'EventReminder',\n  (reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n## 本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\n  RCTMap *map = [RCTMap new];\n  map.delegate = self;\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\n  render() {\n    return <RCTMap {...this.props} />;\n  }\n}\n\nMapView.propTypes = {\n  /**\n   * When this property is set to `true` and a valid camera is associated\n   * with the map, the camera’s pitch angle is used to tilt the plane\n   * of the map. When this property is set to `false`, the camera’s pitch\n   * angle is ignored and the map is always displayed as if the user\n   * is looking straight down onto it.\n   */\n  pitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n## FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 网友眼中的MVC\n![网友眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n## ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n## 遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","source":"_posts/React Native笔记.md","raw":"---\ntitle: React Native笔记\ncategories: \n - JS\n - React Native\ntags:\n - React\n - JS\n---\n\n## 要点记录\n### 本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // Call long-running code on background thread\n    ...\n    // You can invoke callback from any thread/queue\n    callback(@[...]);\n  });\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@\"name\"];\n  [self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n  'EventReminder',\n  (reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n## 本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\n  RCTMap *map = [RCTMap new];\n  map.delegate = self;\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\n  render() {\n    return <RCTMap {...this.props} />;\n  }\n}\n\nMapView.propTypes = {\n  /**\n   * When this property is set to `true` and a valid camera is associated\n   * with the map, the camera’s pitch angle is used to tilt the plane\n   * of the map. When this property is set to `false`, the camera’s pitch\n   * angle is ignored and the map is always displayed as if the user\n   * is looking straight down onto it.\n   */\n  pitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n## FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 网友眼中的MVC\n![网友眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n## ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n## 遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","slug":"React Native笔记","published":1,"date":"2016-08-30T02:10:53.000Z","updated":"2016-10-17T07:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mds000d0k04f7iax04g","content":"<h2 id=\"要点记录\"><a href=\"#要点记录\" class=\"headerlink\" title=\"要点记录\"></a>要点记录</h2><h3 id=\"本地模块（Native-Modules）\"><a href=\"#本地模块（Native-Modules）\" class=\"headerlink\" title=\"本地模块（Native Modules）\"></a>本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\" target=\"_blank\" rel=\"external\">Native Modules</a>）</h3><ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">    callback(@[...]);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">  [<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\">  <span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">  (reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地UI组件（Native-UI-Components\"><a href=\"#本地UI组件（Native-UI-Components\" class=\"headerlink\" title=\"本地UI组件（Native UI Components)\"></a>本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\" target=\"_blank\" rel=\"external\">Native UI Components</a>)</h2><ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">  RCTMap *map = [RCTMap new];</div><div class=\"line\">  map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">  [view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">  /**</div><div class=\"line\">   * When this property is set to `true` and a valid camera is associated</div><div class=\"line\">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">   * angle is ignored and the map is always displayed as if the user</div><div class=\"line\">   * is looking straight down onto it.</div><div class=\"line\">   */</div><div class=\"line\">  pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<h2 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<h2 id=\"ES6语法相关\"><a href=\"#ES6语法相关\" class=\"headerlink\" title=\"ES6语法相关\"></a>ES6语法相关</h2><ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\" target=\"_blank\" rel=\"external\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n","excerpt":"","more":"<h2 id=\"要点记录\"><a href=\"#要点记录\" class=\"headerlink\" title=\"要点记录\"></a>要点记录</h2><h3 id=\"本地模块（Native-Modules）\"><a href=\"#本地模块（Native-Modules）\" class=\"headerlink\" title=\"本地模块（Native Modules）\"></a>本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\">Native Modules</a>）</h3><ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">    callback(@[...]);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">  [<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\">  <span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">  (reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地UI组件（Native-UI-Components\"><a href=\"#本地UI组件（Native-UI-Components\" class=\"headerlink\" title=\"本地UI组件（Native UI Components)\"></a>本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\">Native UI Components</a>)</h2><ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">  RCTMap *map = [RCTMap new];</div><div class=\"line\">  map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">  [view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">  /**</div><div class=\"line\">   * When this property is set to `true` and a valid camera is associated</div><div class=\"line\">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">   * angle is ignored and the map is always displayed as if the user</div><div class=\"line\">   * is looking straight down onto it.</div><div class=\"line\">   */</div><div class=\"line\">  pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<h2 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<h2 id=\"ES6语法相关\"><a href=\"#ES6语法相关\" class=\"headerlink\" title=\"ES6语法相关\"></a>ES6语法相关</h2><ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n"},{"title":"Mach原语：一切以消息为媒介","_content":"\n## 1. Mach概述\n### 1.1 Mach设计原则\n- 在Mach中所有东西（Task、线程、虚拟内存等））都是对象。\n- 对象与对象之间通信**只能**通过端口收发消息。\n\n### 1.2 Mach设计目标\n内核为了保持极简，只做如下的事情：\n\n- “控制点”或执行单元的管理。\n- 线程或线程组（Task）的资源分配。\n- 虚拟内存的分配和管理。\n- 底层物理资源--即CPU、内存和任何物理设备的分配。\n\n## 2. Mach消息\n### 2.1 简单消息\n最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：\n\n```\ntypedef\tstruct \n{\n  mach_msg_bits_t\tmsgh_bits;//标志位\n  mach_msg_size_t\tmsgh_size;//大小\n  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）\n  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）\n  mach_port_name_t\tmsgh_voucher_port;\n  mach_msg_id_t\t\tmsgh_id;\n} mach_msg_header_t; //消息头\n\ntypedef struct\n{\n        mach_msg_size_t msgh_descriptor_count;\n} mach_msg_body_t;//消息体\n\ntypedef struct\n{\n        mach_msg_header_t       header;\n        mach_msg_body_t         body;\n} mach_msg_base_t; //基本消息\n\ntypedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型\n\ntypedef struct \n{\n  mach_msg_trailer_type_t\tmsgh_trailer_type;\n  mach_msg_trailer_size_t\tmsgh_trailer_size;\n} mach_msg_trailer_t; //消息尾\n\n```\n\n### 2.2 复杂消息\n将消息头的标志位`mach_msg_bits_t`设置为`MACH_MSGH_BITS_COMPLEX`，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：\n\n```\ntypedef struct\n{\n  uint64_t\t\t\taddress;//数据的大小\n  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配\n  mach_msg_copy_options_t       copy: 8;//复制指令\n  unsigned int     \t\tpad1: 8;\n  mach_msg_descriptor_type_t    type: 8;\n  mach_msg_size_t       \tsize;//数据的大小\n} mach_msg_ool_descriptor64_t;\n\n```\n\n### 2.3 消息收发\n消息的收发在用户态都是通过如下方法进行的：\n\n```\nextern mach_msg_return_t\tmach_msg(\n\t\t\t\t\tmach_msg_header_t *msg,\n\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型\n\t\t\t\t\tmach_msg_size_t send_size,\n\t\t\t\t\tmach_msg_size_t rcv_size,\n\t\t\t\t\tmach_port_name_t rcv_name,\n\t\t\t\t\tmach_msg_timeout_t timeout,\n\t\t\t\t\tmach_port_name_t notify);\t\t\t\t\t\n```\n\n### 2.4 端口\n端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：\n\n```\nstruct ipc_port {\n\n\t/*\n\t * Initial sub-structure in common with ipc_pset\n\t * First element is an ipc_object second is a\n\t * message queue\n\t */\n\tstruct ipc_object ip_object;\n\tstruct ipc_mqueue ip_messages;\n\n\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */\n\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */\n\t\t  ip_impdonation:1,\t/* port supports importance donation */\n\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */\n\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */\n\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */\n\t\t  ip_reserved:2,\n\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */\n\n\tunion {\n\t\tstruct ipc_space *receiver;\n\t\tstruct ipc_port *destination;\n\t\tipc_port_timestamp_t timestamp;\n\t} data;\n\n\tunion {\n\t\tipc_kobject_t kobject;\n\t\tipc_importance_task_t imp_task;\n\t\tuintptr_t alias;\n\t} kdata;\n\t\t\n\tstruct ipc_port *ip_nsrequest;\n\tstruct ipc_port *ip_pdrequest;\n\tstruct ipc_port_request *ip_requests;\n\tstruct ipc_kmsg *ip_premsg;\n\n\tmach_vm_address_t ip_context;\n\n\tmach_port_mscount_t ip_mscount;\n\tmach_port_rights_t ip_srights;\n\tmach_port_rights_t ip_sorights;\n\n#if\tMACH_ASSERT\n#define\tIP_NSPARES\t\t4\n#define\tIP_CALLSTACK_MAX\t16\n/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */\n\tthread_t\tip_thread;\t/* who made me?  thread context */\n\tunsigned long\tip_timetrack;\t/* give an idea of \"when\" created */\n\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */\n\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */\n#endif\t/* MACH_ASSERT */\n} __attribute__((__packed__));\n\n```\n\n### 2.5 Mach接口生成器（MIG）\nMach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些`.defs`文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：\n![IG_opt.png][1]\n\n## 3. 深入IPC\n- Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。\n- 在用户态下，消息传递都是通过`mach_msg()`函数实现的，这个函数会触发一个mach陷阱`mach_msg_trap()`，接下来`mach_msg_trap()`又会调用`mach_msg_overwrite_trap()`，它会通过`MACH_SEND_MSG`和`MACH_RCV_MSG`来判断是发送操作，还是接收操作。\n- 期中内核态中还可以通过`mach_msg_receive()`和`mach_msg_send()`来收发数据。\n\n## 4. 同步原语\n### 4.1 锁的实现方式\n- **阻塞**：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。**当锁可用的时候**，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。\n- **忙等**：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。\n- **阻塞与忙等的对比**：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。\n\n### 4.2 互斥体(lck_mtx_t)（阻塞）\n- 互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。\n- 原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。\n\n### 4.3 信号量(semaphore_t)（阻塞）\n信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。\n\n### 4.4 自旋锁(hw_lock_t)（忙等）\n一种采用忙等形式的锁。\n### 4.5 读写锁(hw_lock_t)（阻塞）\n当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。\n\n### 4.6 锁集(lock_set_t)\n锁集就是锁的一个数组。\n\n## 5. 机器原语\n### 5.1 主机对象（Host）\n主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：\n\n```\nstruct\thost {\n\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */\n\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];\n\tstruct exception_action exc_actions[EXC_TYPES_COUNT];\n};\n```\n\n### 5.2 时钟对象（Clock）\nMach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是`clock_deadline_for_periodic_event（）`，调度器通过它设置了一个重复发生的通知--从而保证了多任务引擎的运转。\n\n### 5.3 处理器对象（Processer）\n在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给**处理器集**，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：\n\n```\nstruct processor {\n\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,\n\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */\n\tint\t\t\t\t\tstate;\t\t\t/* See below */\n\tboolean_t\t\tis_SMT;\n\tboolean_t\t\tis_recommended;\n\tstruct thread\n\t\t\t\t\t\t*active_thread,\t/* thread running on processor */\n\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */\n\t\t\t\t\t\t*idle_thread;\t/* this processor's idle thread. */\n\n\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */\n\n\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */\n\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */\n\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */\n\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */\n\n\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */\n\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */\n\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */\n\n\tuint64_t\t\t\tdeadline;\t\t/* current deadline */\n\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\trunq;\t\t\t/* runq for this processor */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */\n#endif\n#if defined(CONFIG_SCHED_GRRR)\n\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */\n#endif\n\n\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for\n\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer\n\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */\n\tprocessor_t\t\tprocessor_secondary;\n\tstruct ipc_port *\tprocessor_self;\t/* port for operations */\n\n\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */\n\tprocessor_data_t\tprocessor_data;\t/* per-processor data */\n};\n```\n其中最重要的是runq，这是分发到这个处理器的线程队列。\n\n### 5.3 处理器集\n处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：\n\n- `active_queue`：用于保存当前正在执行线程的CPU。\n- `idle_queue`：用于保存当前空闲的CPU（例如：正在执行`idle_thread`）。\n- `pset_runq`：保存了在这个集合中的所有CPU上执行的线程。\n\n`processor_set`的定义如下：\n\n```\nstruct processor_set {\n\tqueue_head_t\t\tactive_queue;\t/* active processors */\n\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */\n\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */\n\n\tint\t\t\t\t\tonline_processor_count;\n\n\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;\n\tint\t\t\t\t\tcpu_set_count;\n\n#if __SMP__\n\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\tpset_runq;      /* runq for this processor set */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\tpset_runq_bound_count;\n\t\t/* # of threads in runq bound to any processor in pset */\n#endif\n\n\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */\n\tuint64_t\t\t\tpending_AST_cpu_mask;\n#if defined(CONFIG_SCHED_DEFERRED_AST)\n\t/*\n\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on\n\t * some level of support for requesting an AST on a processor, and then quashing\n\t * that request later.\n\t *\n\t * The purpose of this field (and the associated codepaths) is to infer when we\n\t * no longer need a processor that is DISPATCHING to come up, and to prevent it\n\t * from coming out of IDLE if possible.  This should serve to decrease the number\n\t * of spurious ASTs in the system, and let processors spend longer periods in\n\t * IDLE.\n\t */\n\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;\n#endif\n\n\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */\n\tstruct ipc_port *\tpset_name_self;\t/* port for information */\n\n\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */\n\tpset_node_t\t\t\tnode;\n};\n```\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\n","source":"_posts/Mach原语：一起以消息为媒介.md","raw":"---\ntitle: Mach原语：一切以消息为媒介\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n - Mach\n---\n\n## 1. Mach概述\n### 1.1 Mach设计原则\n- 在Mach中所有东西（Task、线程、虚拟内存等））都是对象。\n- 对象与对象之间通信**只能**通过端口收发消息。\n\n### 1.2 Mach设计目标\n内核为了保持极简，只做如下的事情：\n\n- “控制点”或执行单元的管理。\n- 线程或线程组（Task）的资源分配。\n- 虚拟内存的分配和管理。\n- 底层物理资源--即CPU、内存和任何物理设备的分配。\n\n## 2. Mach消息\n### 2.1 简单消息\n最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：\n\n```\ntypedef\tstruct \n{\n  mach_msg_bits_t\tmsgh_bits;//标志位\n  mach_msg_size_t\tmsgh_size;//大小\n  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）\n  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）\n  mach_port_name_t\tmsgh_voucher_port;\n  mach_msg_id_t\t\tmsgh_id;\n} mach_msg_header_t; //消息头\n\ntypedef struct\n{\n        mach_msg_size_t msgh_descriptor_count;\n} mach_msg_body_t;//消息体\n\ntypedef struct\n{\n        mach_msg_header_t       header;\n        mach_msg_body_t         body;\n} mach_msg_base_t; //基本消息\n\ntypedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型\n\ntypedef struct \n{\n  mach_msg_trailer_type_t\tmsgh_trailer_type;\n  mach_msg_trailer_size_t\tmsgh_trailer_size;\n} mach_msg_trailer_t; //消息尾\n\n```\n\n### 2.2 复杂消息\n将消息头的标志位`mach_msg_bits_t`设置为`MACH_MSGH_BITS_COMPLEX`，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：\n\n```\ntypedef struct\n{\n  uint64_t\t\t\taddress;//数据的大小\n  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配\n  mach_msg_copy_options_t       copy: 8;//复制指令\n  unsigned int     \t\tpad1: 8;\n  mach_msg_descriptor_type_t    type: 8;\n  mach_msg_size_t       \tsize;//数据的大小\n} mach_msg_ool_descriptor64_t;\n\n```\n\n### 2.3 消息收发\n消息的收发在用户态都是通过如下方法进行的：\n\n```\nextern mach_msg_return_t\tmach_msg(\n\t\t\t\t\tmach_msg_header_t *msg,\n\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型\n\t\t\t\t\tmach_msg_size_t send_size,\n\t\t\t\t\tmach_msg_size_t rcv_size,\n\t\t\t\t\tmach_port_name_t rcv_name,\n\t\t\t\t\tmach_msg_timeout_t timeout,\n\t\t\t\t\tmach_port_name_t notify);\t\t\t\t\t\n```\n\n### 2.4 端口\n端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：\n\n```\nstruct ipc_port {\n\n\t/*\n\t * Initial sub-structure in common with ipc_pset\n\t * First element is an ipc_object second is a\n\t * message queue\n\t */\n\tstruct ipc_object ip_object;\n\tstruct ipc_mqueue ip_messages;\n\n\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */\n\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */\n\t\t  ip_impdonation:1,\t/* port supports importance donation */\n\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */\n\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */\n\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */\n\t\t  ip_reserved:2,\n\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */\n\n\tunion {\n\t\tstruct ipc_space *receiver;\n\t\tstruct ipc_port *destination;\n\t\tipc_port_timestamp_t timestamp;\n\t} data;\n\n\tunion {\n\t\tipc_kobject_t kobject;\n\t\tipc_importance_task_t imp_task;\n\t\tuintptr_t alias;\n\t} kdata;\n\t\t\n\tstruct ipc_port *ip_nsrequest;\n\tstruct ipc_port *ip_pdrequest;\n\tstruct ipc_port_request *ip_requests;\n\tstruct ipc_kmsg *ip_premsg;\n\n\tmach_vm_address_t ip_context;\n\n\tmach_port_mscount_t ip_mscount;\n\tmach_port_rights_t ip_srights;\n\tmach_port_rights_t ip_sorights;\n\n#if\tMACH_ASSERT\n#define\tIP_NSPARES\t\t4\n#define\tIP_CALLSTACK_MAX\t16\n/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */\n\tthread_t\tip_thread;\t/* who made me?  thread context */\n\tunsigned long\tip_timetrack;\t/* give an idea of \"when\" created */\n\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */\n\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */\n#endif\t/* MACH_ASSERT */\n} __attribute__((__packed__));\n\n```\n\n### 2.5 Mach接口生成器（MIG）\nMach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些`.defs`文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：\n![IG_opt.png][1]\n\n## 3. 深入IPC\n- Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。\n- 在用户态下，消息传递都是通过`mach_msg()`函数实现的，这个函数会触发一个mach陷阱`mach_msg_trap()`，接下来`mach_msg_trap()`又会调用`mach_msg_overwrite_trap()`，它会通过`MACH_SEND_MSG`和`MACH_RCV_MSG`来判断是发送操作，还是接收操作。\n- 期中内核态中还可以通过`mach_msg_receive()`和`mach_msg_send()`来收发数据。\n\n## 4. 同步原语\n### 4.1 锁的实现方式\n- **阻塞**：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。**当锁可用的时候**，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。\n- **忙等**：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。\n- **阻塞与忙等的对比**：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。\n\n### 4.2 互斥体(lck_mtx_t)（阻塞）\n- 互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。\n- 原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。\n\n### 4.3 信号量(semaphore_t)（阻塞）\n信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。\n\n### 4.4 自旋锁(hw_lock_t)（忙等）\n一种采用忙等形式的锁。\n### 4.5 读写锁(hw_lock_t)（阻塞）\n当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。\n\n### 4.6 锁集(lock_set_t)\n锁集就是锁的一个数组。\n\n## 5. 机器原语\n### 5.1 主机对象（Host）\n主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：\n\n```\nstruct\thost {\n\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */\n\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];\n\tstruct exception_action exc_actions[EXC_TYPES_COUNT];\n};\n```\n\n### 5.2 时钟对象（Clock）\nMach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是`clock_deadline_for_periodic_event（）`，调度器通过它设置了一个重复发生的通知--从而保证了多任务引擎的运转。\n\n### 5.3 处理器对象（Processer）\n在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给**处理器集**，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：\n\n```\nstruct processor {\n\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,\n\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */\n\tint\t\t\t\t\tstate;\t\t\t/* See below */\n\tboolean_t\t\tis_SMT;\n\tboolean_t\t\tis_recommended;\n\tstruct thread\n\t\t\t\t\t\t*active_thread,\t/* thread running on processor */\n\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */\n\t\t\t\t\t\t*idle_thread;\t/* this processor's idle thread. */\n\n\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */\n\n\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */\n\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */\n\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */\n\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */\n\n\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */\n\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */\n\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */\n\n\tuint64_t\t\t\tdeadline;\t\t/* current deadline */\n\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\trunq;\t\t\t/* runq for this processor */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */\n#endif\n#if defined(CONFIG_SCHED_GRRR)\n\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */\n#endif\n\n\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for\n\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer\n\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */\n\tprocessor_t\t\tprocessor_secondary;\n\tstruct ipc_port *\tprocessor_self;\t/* port for operations */\n\n\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */\n\tprocessor_data_t\tprocessor_data;\t/* per-processor data */\n};\n```\n其中最重要的是runq，这是分发到这个处理器的线程队列。\n\n### 5.3 处理器集\n处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：\n\n- `active_queue`：用于保存当前正在执行线程的CPU。\n- `idle_queue`：用于保存当前空闲的CPU（例如：正在执行`idle_thread`）。\n- `pset_runq`：保存了在这个集合中的所有CPU上执行的线程。\n\n`processor_set`的定义如下：\n\n```\nstruct processor_set {\n\tqueue_head_t\t\tactive_queue;\t/* active processors */\n\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */\n\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */\n\n\tint\t\t\t\t\tonline_processor_count;\n\n\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;\n\tint\t\t\t\t\tcpu_set_count;\n\n#if __SMP__\n\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\tpset_runq;      /* runq for this processor set */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\tpset_runq_bound_count;\n\t\t/* # of threads in runq bound to any processor in pset */\n#endif\n\n\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */\n\tuint64_t\t\t\tpending_AST_cpu_mask;\n#if defined(CONFIG_SCHED_DEFERRED_AST)\n\t/*\n\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on\n\t * some level of support for requesting an AST on a processor, and then quashing\n\t * that request later.\n\t *\n\t * The purpose of this field (and the associated codepaths) is to infer when we\n\t * no longer need a processor that is DISPATCHING to come up, and to prevent it\n\t * from coming out of IDLE if possible.  This should serve to decrease the number\n\t * of spurious ASTs in the system, and let processors spend longer periods in\n\t * IDLE.\n\t */\n\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;\n#endif\n\n\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */\n\tstruct ipc_port *\tpset_name_self;\t/* port for information */\n\n\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */\n\tpset_node_t\t\t\tnode;\n};\n```\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\n","slug":"Mach原语：一起以消息为媒介","published":1,"date":"2016-09-11T09:05:13.000Z","updated":"2016-10-18T13:04:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mdy000g0k04y374v1ri","content":"<h2 id=\"1-Mach概述\"><a href=\"#1-Mach概述\" class=\"headerlink\" title=\"1. Mach概述\"></a>1. Mach概述</h2><h3 id=\"1-1-Mach设计原则\"><a href=\"#1-1-Mach设计原则\" class=\"headerlink\" title=\"1.1 Mach设计原则\"></a>1.1 Mach设计原则</h3><ul>\n<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>\n<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>\n</ul>\n<h3 id=\"1-2-Mach设计目标\"><a href=\"#1-2-Mach设计目标\" class=\"headerlink\" title=\"1.2 Mach设计目标\"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>\n<ul>\n<li>“控制点”或执行单元的管理。</li>\n<li>线程或线程组（Task）的资源分配。</li>\n<li>虚拟内存的分配和管理。</li>\n<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>\n</ul>\n<h2 id=\"2-Mach消息\"><a href=\"#2-Mach消息\" class=\"headerlink\" title=\"2. Mach消息\"></a>2. Mach消息</h2><h3 id=\"2-1-简单消息\"><a href=\"#2-1-简单消息\" class=\"headerlink\" title=\"2.1 简单消息\"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef\tstruct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_bits_t\tmsgh_bits;//标志位</div><div class=\"line\">  mach_msg_size_t\tmsgh_size;//大小</div><div class=\"line\">  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class=\"line\">  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class=\"line\">  mach_port_name_t\tmsgh_voucher_port;</div><div class=\"line\">  mach_msg_id_t\t\tmsgh_id;</div><div class=\"line\">&#125; mach_msg_header_t; //消息头</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_size_t msgh_descriptor_count;</div><div class=\"line\">&#125; mach_msg_body_t;//消息体</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_header_t       header;</div><div class=\"line\">        mach_msg_body_t         body;</div><div class=\"line\">&#125; mach_msg_base_t; //基本消息</div><div class=\"line\"></div><div class=\"line\">typedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class=\"line\"></div><div class=\"line\">typedef struct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_trailer_type_t\tmsgh_trailer_type;</div><div class=\"line\">  mach_msg_trailer_size_t\tmsgh_trailer_size;</div><div class=\"line\">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-复杂消息\"><a href=\"#2-2-复杂消息\" class=\"headerlink\" title=\"2.2 复杂消息\"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">  uint64_t\t\t\taddress;//数据的大小</div><div class=\"line\">  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配</div><div class=\"line\">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class=\"line\">  unsigned int     \t\tpad1: 8;</div><div class=\"line\">  mach_msg_descriptor_type_t    type: 8;</div><div class=\"line\">  mach_msg_size_t       \tsize;//数据的大小</div><div class=\"line\">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>\n<h3 id=\"2-3-消息收发\"><a href=\"#2-3-消息收发\" class=\"headerlink\" title=\"2.3 消息收发\"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern mach_msg_return_t\tmach_msg(</div><div class=\"line\">\t\t\t\t\tmach_msg_header_t *msg,</div><div class=\"line\">\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t send_size,</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t rcv_size,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t rcv_name,</div><div class=\"line\">\t\t\t\t\tmach_msg_timeout_t timeout,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t notify);</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-端口\"><a href=\"#2-4-端口\" class=\"headerlink\" title=\"2.4 端口\"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ipc_port &#123;</div><div class=\"line\"></div><div class=\"line\">\t/*</div><div class=\"line\">\t * Initial sub-structure in common with ipc_pset</div><div class=\"line\">\t * First element is an ipc_object second is a</div><div class=\"line\">\t * message queue</div><div class=\"line\">\t */</div><div class=\"line\">\tstruct ipc_object ip_object;</div><div class=\"line\">\tstruct ipc_mqueue ip_messages;</div><div class=\"line\"></div><div class=\"line\">\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */</div><div class=\"line\">\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */</div><div class=\"line\">\t\t  ip_impdonation:1,\t/* port supports importance donation */</div><div class=\"line\">\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */</div><div class=\"line\">\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class=\"line\">\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */</div><div class=\"line\">\t\t  ip_reserved:2,</div><div class=\"line\">\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tstruct ipc_space *receiver;</div><div class=\"line\">\t\tstruct ipc_port *destination;</div><div class=\"line\">\t\tipc_port_timestamp_t timestamp;</div><div class=\"line\">\t&#125; data;</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tipc_kobject_t kobject;</div><div class=\"line\">\t\tipc_importance_task_t imp_task;</div><div class=\"line\">\t\tuintptr_t alias;</div><div class=\"line\">\t&#125; kdata;</div><div class=\"line\">\t\t</div><div class=\"line\">\tstruct ipc_port *ip_nsrequest;</div><div class=\"line\">\tstruct ipc_port *ip_pdrequest;</div><div class=\"line\">\tstruct ipc_port_request *ip_requests;</div><div class=\"line\">\tstruct ipc_kmsg *ip_premsg;</div><div class=\"line\"></div><div class=\"line\">\tmach_vm_address_t ip_context;</div><div class=\"line\"></div><div class=\"line\">\tmach_port_mscount_t ip_mscount;</div><div class=\"line\">\tmach_port_rights_t ip_srights;</div><div class=\"line\">\tmach_port_rights_t ip_sorights;</div><div class=\"line\"></div><div class=\"line\">#if\tMACH_ASSERT</div><div class=\"line\">#define\tIP_NSPARES\t\t4</div><div class=\"line\">#define\tIP_CALLSTACK_MAX\t16</div><div class=\"line\">/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */</div><div class=\"line\">\tthread_t\tip_thread;\t/* who made me?  thread context */</div><div class=\"line\">\tunsigned long\tip_timetrack;\t/* give an idea of &quot;when&quot; created */</div><div class=\"line\">\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class=\"line\">\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */</div><div class=\"line\">#endif\t/* MACH_ASSERT */</div><div class=\"line\">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>\n<h3 id=\"2-5-Mach接口生成器（MIG）\"><a href=\"#2-5-Mach接口生成器（MIG）\" class=\"headerlink\" title=\"2.5 Mach接口生成器（MIG）\"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\" alt=\"IG_opt.png\"></p>\n<h2 id=\"3-深入IPC\"><a href=\"#3-深入IPC\" class=\"headerlink\" title=\"3. 深入IPC\"></a>3. 深入IPC</h2><ul>\n<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>\n<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>\n<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>\n</ul>\n<h2 id=\"4-同步原语\"><a href=\"#4-同步原语\" class=\"headerlink\" title=\"4. 同步原语\"></a>4. 同步原语</h2><h3 id=\"4-1-锁的实现方式\"><a href=\"#4-1-锁的实现方式\" class=\"headerlink\" title=\"4.1 锁的实现方式\"></a>4.1 锁的实现方式</h3><ul>\n<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>\n<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>\n<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>\n</ul>\n<h3 id=\"4-2-互斥体-lck-mtx-t-（阻塞）\"><a href=\"#4-2-互斥体-lck-mtx-t-（阻塞）\" class=\"headerlink\" title=\"4.2 互斥体(lck_mtx_t)（阻塞）\"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>\n<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>\n<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>\n</ul>\n<h3 id=\"4-3-信号量-semaphore-t-（阻塞）\"><a href=\"#4-3-信号量-semaphore-t-（阻塞）\" class=\"headerlink\" title=\"4.3 信号量(semaphore_t)（阻塞）\"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>\n<h3 id=\"4-4-自旋锁-hw-lock-t-（忙等）\"><a href=\"#4-4-自旋锁-hw-lock-t-（忙等）\" class=\"headerlink\" title=\"4.4 自旋锁(hw_lock_t)（忙等）\"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>\n<h3 id=\"4-5-读写锁-hw-lock-t-（阻塞）\"><a href=\"#4-5-读写锁-hw-lock-t-（阻塞）\" class=\"headerlink\" title=\"4.5 读写锁(hw_lock_t)（阻塞）\"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>\n<h3 id=\"4-6-锁集-lock-set-t\"><a href=\"#4-6-锁集-lock-set-t\" class=\"headerlink\" title=\"4.6 锁集(lock_set_t)\"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>\n<h2 id=\"5-机器原语\"><a href=\"#5-机器原语\" class=\"headerlink\" title=\"5. 机器原语\"></a>5. 机器原语</h2><h3 id=\"5-1-主机对象（Host）\"><a href=\"#5-1-主机对象（Host）\" class=\"headerlink\" title=\"5.1 主机对象（Host）\"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct\thost &#123;</div><div class=\"line\">\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */</div><div class=\"line\">\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class=\"line\">\tstruct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"5-2-时钟对象（Clock）\"><a href=\"#5-2-时钟对象（Clock）\" class=\"headerlink\" title=\"5.2 时钟对象（Clock）\"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>\n<h3 id=\"5-3-处理器对象（Processer）\"><a href=\"#5-3-处理器对象（Processer）\" class=\"headerlink\" title=\"5.3 处理器对象（Processer）\"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor &#123;</div><div class=\"line\">\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */</div><div class=\"line\">\tint\t\t\t\t\tstate;\t\t\t/* See below */</div><div class=\"line\">\tboolean_t\t\tis_SMT;</div><div class=\"line\">\tboolean_t\t\tis_recommended;</div><div class=\"line\">\tstruct thread</div><div class=\"line\">\t\t\t\t\t\t*active_thread,\t/* thread running on processor */</div><div class=\"line\">\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */</div><div class=\"line\">\t\t\t\t\t\t*idle_thread;\t/* this processor&apos;s idle thread. */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */</div><div class=\"line\">\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */</div><div class=\"line\">\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */</div><div class=\"line\">\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */</div><div class=\"line\"></div><div class=\"line\">\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */</div><div class=\"line\">\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */</div><div class=\"line\">\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */</div><div class=\"line\"></div><div class=\"line\">\tuint64_t\t\t\tdeadline;\t\t/* current deadline */</div><div class=\"line\">\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\trunq;\t\t\t/* runq for this processor */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */</div><div class=\"line\">#endif</div><div class=\"line\">#if defined(CONFIG_SCHED_GRRR)</div><div class=\"line\">\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */</div><div class=\"line\">\tprocessor_t\t\tprocessor_secondary;</div><div class=\"line\">\tstruct ipc_port *\tprocessor_self;\t/* port for operations */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */</div><div class=\"line\">\tprocessor_data_t\tprocessor_data;\t/* per-processor data */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>\n<h3 id=\"5-3-处理器集\"><a href=\"#5-3-处理器集\" class=\"headerlink\" title=\"5.3 处理器集\"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>\n<ul>\n<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>\n<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>\n<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>\n</ul>\n<p><code>processor_set</code>的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor_set &#123;</div><div class=\"line\">\tqueue_head_t\t\tactive_queue;\t/* active processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tonline_processor_count;</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;</div><div class=\"line\">\tint\t\t\t\t\tcpu_set_count;</div><div class=\"line\"></div><div class=\"line\">#if __SMP__</div><div class=\"line\">\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\tpset_runq;      /* runq for this processor set */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\tpset_runq_bound_count;</div><div class=\"line\">\t\t/* # of threads in runq bound to any processor in pset */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class=\"line\">\tuint64_t\t\t\tpending_AST_cpu_mask;</div><div class=\"line\">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class=\"line\">\t/*</div><div class=\"line\">\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class=\"line\">\t * some level of support for requesting an AST on a processor, and then quashing</div><div class=\"line\">\t * that request later.</div><div class=\"line\">\t *</div><div class=\"line\">\t * The purpose of this field (and the associated codepaths) is to infer when we</div><div class=\"line\">\t * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class=\"line\">\t * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class=\"line\">\t * of spurious ASTs in the system, and let processors spend longer periods in</div><div class=\"line\">\t * IDLE.</div><div class=\"line\">\t */</div><div class=\"line\">\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */</div><div class=\"line\">\tstruct ipc_port *\tpset_name_self;\t/* port for information */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */</div><div class=\"line\">\tpset_node_t\t\t\tnode;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<hr>\n","excerpt":"","more":"<h2 id=\"1-Mach概述\"><a href=\"#1-Mach概述\" class=\"headerlink\" title=\"1. Mach概述\"></a>1. Mach概述</h2><h3 id=\"1-1-Mach设计原则\"><a href=\"#1-1-Mach设计原则\" class=\"headerlink\" title=\"1.1 Mach设计原则\"></a>1.1 Mach设计原则</h3><ul>\n<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>\n<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>\n</ul>\n<h3 id=\"1-2-Mach设计目标\"><a href=\"#1-2-Mach设计目标\" class=\"headerlink\" title=\"1.2 Mach设计目标\"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>\n<ul>\n<li>“控制点”或执行单元的管理。</li>\n<li>线程或线程组（Task）的资源分配。</li>\n<li>虚拟内存的分配和管理。</li>\n<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>\n</ul>\n<h2 id=\"2-Mach消息\"><a href=\"#2-Mach消息\" class=\"headerlink\" title=\"2. Mach消息\"></a>2. Mach消息</h2><h3 id=\"2-1-简单消息\"><a href=\"#2-1-简单消息\" class=\"headerlink\" title=\"2.1 简单消息\"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef\tstruct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_bits_t\tmsgh_bits;//标志位</div><div class=\"line\">  mach_msg_size_t\tmsgh_size;//大小</div><div class=\"line\">  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class=\"line\">  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class=\"line\">  mach_port_name_t\tmsgh_voucher_port;</div><div class=\"line\">  mach_msg_id_t\t\tmsgh_id;</div><div class=\"line\">&#125; mach_msg_header_t; //消息头</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_size_t msgh_descriptor_count;</div><div class=\"line\">&#125; mach_msg_body_t;//消息体</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_header_t       header;</div><div class=\"line\">        mach_msg_body_t         body;</div><div class=\"line\">&#125; mach_msg_base_t; //基本消息</div><div class=\"line\"></div><div class=\"line\">typedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class=\"line\"></div><div class=\"line\">typedef struct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_trailer_type_t\tmsgh_trailer_type;</div><div class=\"line\">  mach_msg_trailer_size_t\tmsgh_trailer_size;</div><div class=\"line\">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-复杂消息\"><a href=\"#2-2-复杂消息\" class=\"headerlink\" title=\"2.2 复杂消息\"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">  uint64_t\t\t\taddress;//数据的大小</div><div class=\"line\">  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配</div><div class=\"line\">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class=\"line\">  unsigned int     \t\tpad1: 8;</div><div class=\"line\">  mach_msg_descriptor_type_t    type: 8;</div><div class=\"line\">  mach_msg_size_t       \tsize;//数据的大小</div><div class=\"line\">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>\n<h3 id=\"2-3-消息收发\"><a href=\"#2-3-消息收发\" class=\"headerlink\" title=\"2.3 消息收发\"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern mach_msg_return_t\tmach_msg(</div><div class=\"line\">\t\t\t\t\tmach_msg_header_t *msg,</div><div class=\"line\">\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t send_size,</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t rcv_size,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t rcv_name,</div><div class=\"line\">\t\t\t\t\tmach_msg_timeout_t timeout,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t notify);</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-端口\"><a href=\"#2-4-端口\" class=\"headerlink\" title=\"2.4 端口\"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ipc_port &#123;</div><div class=\"line\"></div><div class=\"line\">\t/*</div><div class=\"line\">\t * Initial sub-structure in common with ipc_pset</div><div class=\"line\">\t * First element is an ipc_object second is a</div><div class=\"line\">\t * message queue</div><div class=\"line\">\t */</div><div class=\"line\">\tstruct ipc_object ip_object;</div><div class=\"line\">\tstruct ipc_mqueue ip_messages;</div><div class=\"line\"></div><div class=\"line\">\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */</div><div class=\"line\">\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */</div><div class=\"line\">\t\t  ip_impdonation:1,\t/* port supports importance donation */</div><div class=\"line\">\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */</div><div class=\"line\">\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class=\"line\">\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */</div><div class=\"line\">\t\t  ip_reserved:2,</div><div class=\"line\">\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tstruct ipc_space *receiver;</div><div class=\"line\">\t\tstruct ipc_port *destination;</div><div class=\"line\">\t\tipc_port_timestamp_t timestamp;</div><div class=\"line\">\t&#125; data;</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tipc_kobject_t kobject;</div><div class=\"line\">\t\tipc_importance_task_t imp_task;</div><div class=\"line\">\t\tuintptr_t alias;</div><div class=\"line\">\t&#125; kdata;</div><div class=\"line\">\t\t</div><div class=\"line\">\tstruct ipc_port *ip_nsrequest;</div><div class=\"line\">\tstruct ipc_port *ip_pdrequest;</div><div class=\"line\">\tstruct ipc_port_request *ip_requests;</div><div class=\"line\">\tstruct ipc_kmsg *ip_premsg;</div><div class=\"line\"></div><div class=\"line\">\tmach_vm_address_t ip_context;</div><div class=\"line\"></div><div class=\"line\">\tmach_port_mscount_t ip_mscount;</div><div class=\"line\">\tmach_port_rights_t ip_srights;</div><div class=\"line\">\tmach_port_rights_t ip_sorights;</div><div class=\"line\"></div><div class=\"line\">#if\tMACH_ASSERT</div><div class=\"line\">#define\tIP_NSPARES\t\t4</div><div class=\"line\">#define\tIP_CALLSTACK_MAX\t16</div><div class=\"line\">/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */</div><div class=\"line\">\tthread_t\tip_thread;\t/* who made me?  thread context */</div><div class=\"line\">\tunsigned long\tip_timetrack;\t/* give an idea of &quot;when&quot; created */</div><div class=\"line\">\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class=\"line\">\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */</div><div class=\"line\">#endif\t/* MACH_ASSERT */</div><div class=\"line\">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>\n<h3 id=\"2-5-Mach接口生成器（MIG）\"><a href=\"#2-5-Mach接口生成器（MIG）\" class=\"headerlink\" title=\"2.5 Mach接口生成器（MIG）\"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\" alt=\"IG_opt.png\"></p>\n<h2 id=\"3-深入IPC\"><a href=\"#3-深入IPC\" class=\"headerlink\" title=\"3. 深入IPC\"></a>3. 深入IPC</h2><ul>\n<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>\n<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>\n<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>\n</ul>\n<h2 id=\"4-同步原语\"><a href=\"#4-同步原语\" class=\"headerlink\" title=\"4. 同步原语\"></a>4. 同步原语</h2><h3 id=\"4-1-锁的实现方式\"><a href=\"#4-1-锁的实现方式\" class=\"headerlink\" title=\"4.1 锁的实现方式\"></a>4.1 锁的实现方式</h3><ul>\n<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>\n<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>\n<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>\n</ul>\n<h3 id=\"4-2-互斥体-lck-mtx-t-（阻塞）\"><a href=\"#4-2-互斥体-lck-mtx-t-（阻塞）\" class=\"headerlink\" title=\"4.2 互斥体(lck_mtx_t)（阻塞）\"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>\n<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>\n<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>\n</ul>\n<h3 id=\"4-3-信号量-semaphore-t-（阻塞）\"><a href=\"#4-3-信号量-semaphore-t-（阻塞）\" class=\"headerlink\" title=\"4.3 信号量(semaphore_t)（阻塞）\"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>\n<h3 id=\"4-4-自旋锁-hw-lock-t-（忙等）\"><a href=\"#4-4-自旋锁-hw-lock-t-（忙等）\" class=\"headerlink\" title=\"4.4 自旋锁(hw_lock_t)（忙等）\"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>\n<h3 id=\"4-5-读写锁-hw-lock-t-（阻塞）\"><a href=\"#4-5-读写锁-hw-lock-t-（阻塞）\" class=\"headerlink\" title=\"4.5 读写锁(hw_lock_t)（阻塞）\"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>\n<h3 id=\"4-6-锁集-lock-set-t\"><a href=\"#4-6-锁集-lock-set-t\" class=\"headerlink\" title=\"4.6 锁集(lock_set_t)\"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>\n<h2 id=\"5-机器原语\"><a href=\"#5-机器原语\" class=\"headerlink\" title=\"5. 机器原语\"></a>5. 机器原语</h2><h3 id=\"5-1-主机对象（Host）\"><a href=\"#5-1-主机对象（Host）\" class=\"headerlink\" title=\"5.1 主机对象（Host）\"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct\thost &#123;</div><div class=\"line\">\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */</div><div class=\"line\">\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class=\"line\">\tstruct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"5-2-时钟对象（Clock）\"><a href=\"#5-2-时钟对象（Clock）\" class=\"headerlink\" title=\"5.2 时钟对象（Clock）\"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>\n<h3 id=\"5-3-处理器对象（Processer）\"><a href=\"#5-3-处理器对象（Processer）\" class=\"headerlink\" title=\"5.3 处理器对象（Processer）\"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor &#123;</div><div class=\"line\">\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */</div><div class=\"line\">\tint\t\t\t\t\tstate;\t\t\t/* See below */</div><div class=\"line\">\tboolean_t\t\tis_SMT;</div><div class=\"line\">\tboolean_t\t\tis_recommended;</div><div class=\"line\">\tstruct thread</div><div class=\"line\">\t\t\t\t\t\t*active_thread,\t/* thread running on processor */</div><div class=\"line\">\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */</div><div class=\"line\">\t\t\t\t\t\t*idle_thread;\t/* this processor&apos;s idle thread. */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */</div><div class=\"line\">\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */</div><div class=\"line\">\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */</div><div class=\"line\">\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */</div><div class=\"line\"></div><div class=\"line\">\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */</div><div class=\"line\">\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */</div><div class=\"line\">\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */</div><div class=\"line\"></div><div class=\"line\">\tuint64_t\t\t\tdeadline;\t\t/* current deadline */</div><div class=\"line\">\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\trunq;\t\t\t/* runq for this processor */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */</div><div class=\"line\">#endif</div><div class=\"line\">#if defined(CONFIG_SCHED_GRRR)</div><div class=\"line\">\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */</div><div class=\"line\">\tprocessor_t\t\tprocessor_secondary;</div><div class=\"line\">\tstruct ipc_port *\tprocessor_self;\t/* port for operations */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */</div><div class=\"line\">\tprocessor_data_t\tprocessor_data;\t/* per-processor data */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>\n<h3 id=\"5-3-处理器集\"><a href=\"#5-3-处理器集\" class=\"headerlink\" title=\"5.3 处理器集\"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>\n<ul>\n<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>\n<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>\n<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>\n</ul>\n<p><code>processor_set</code>的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor_set &#123;</div><div class=\"line\">\tqueue_head_t\t\tactive_queue;\t/* active processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tonline_processor_count;</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;</div><div class=\"line\">\tint\t\t\t\t\tcpu_set_count;</div><div class=\"line\"></div><div class=\"line\">#if __SMP__</div><div class=\"line\">\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\tpset_runq;      /* runq for this processor set */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\tpset_runq_bound_count;</div><div class=\"line\">\t\t/* # of threads in runq bound to any processor in pset */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class=\"line\">\tuint64_t\t\t\tpending_AST_cpu_mask;</div><div class=\"line\">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class=\"line\">\t/*</div><div class=\"line\">\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class=\"line\">\t * some level of support for requesting an AST on a processor, and then quashing</div><div class=\"line\">\t * that request later.</div><div class=\"line\">\t *</div><div class=\"line\">\t * The purpose of this field (and the associated codepaths) is to infer when we</div><div class=\"line\">\t * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class=\"line\">\t * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class=\"line\">\t * of spurious ASTs in the system, and let processors spend longer periods in</div><div class=\"line\">\t * IDLE.</div><div class=\"line\">\t */</div><div class=\"line\">\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */</div><div class=\"line\">\tstruct ipc_port *\tpset_name_self;\t/* port for information */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */</div><div class=\"line\">\tpset_node_t\t\t\tnode;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<hr>\n"},{"title":"Thrift的二进制数据编解码--以OC为例","date":"2016-04-16T14:56:14.000Z","_content":"\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","source":"_posts/Thrift的二进制数据编解码-以OC为例.md","raw":"---\ntitle: Thrift的二进制数据编解码--以OC为例\ndate: 2016-04-16 22:56:14\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","slug":"Thrift的二进制数据编解码-以OC为例","published":1,"updated":"2016-10-15T12:17:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2me1000i0k04aj4tpb7t","content":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\" target=\"_blank\" rel=\"external\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n"},{"title":"iOS中的MAX(A,B)，需要注意的点","date":"2016-04-19T03:22:30.000Z","_content":"\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","source":"_posts/iOS中的MAX-A-B-，需要注意的点.md","raw":"---\ntitle: iOS中的MAX(A,B)，需要注意的点\ndate: 2016-04-19 11:22:30\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","slug":"iOS中的MAX-A-B-，需要注意的点","published":1,"updated":"2016-10-15T11:24:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2me6000m0k04dbx0pc1e","content":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n"},{"title":"iOS引导页的镂空效果","date":"2016-04-29T14:06:55.000Z","_content":"\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","source":"_posts/iOS引导页的镂空效果.md","raw":"---\ntitle: iOS引导页的镂空效果\ndate: 2016-04-29 22:06:55\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","slug":"iOS引导页的镂空效果","published":1,"updated":"2016-10-15T11:29:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2meb000o0k04csycy2am","content":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n"},{"title":"iOS支持懒加载的PageViewController","date":"2016-09-01T16:12:18.000Z","_content":"\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","source":"_posts/iOS支持懒加载的PageViewController.md","raw":"---\ntitle: iOS支持懒加载的PageViewController\ndate: 2016-09-02 00:12:18\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","slug":"iOS支持懒加载的PageViewController","published":1,"updated":"2016-10-15T12:13:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mef000r0k04zggn7ir7","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n"},{"title":"iOS签名","_content":"\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","source":"_posts/iOS签名.md","raw":"---\ntitle: iOS签名\ncategories: \n - Apple Development \n - 安全\ntags:\n - 安全\n - JS\n---\n\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","slug":"iOS签名","published":1,"date":"2016-08-30T02:01:06.000Z","updated":"2016-10-17T05:11:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mek000t0k04g7s5kx2l","content":"<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\" target=\"_blank\" rel=\"external\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\" target=\"_blank\" rel=\"external\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\" target=\"_blank\" rel=\"external\">iOS Code Signing 学习笔记</a></p>\n","excerpt":"","more":"<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\">iOS Code Signing 学习笔记</a></p>\n"},{"title":"内核架构","comments":1,"description":"内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的...","_content":"\n# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","source":"_posts/内核架构.md","raw":"---\ntitle: 内核架构\ncomments: true\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n- 内核架构 \ndescription: \"内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的...\"\n---\n\n# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","slug":"内核架构","published":1,"date":"2016-09-04T14:42:35.000Z","updated":"2016-11-15T07:11:26.000Z","layout":"post","photos":[],"link":"","_id":"civja2meo000w0k04v495yfnk","content":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>","excerpt":"","more":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>"},{"title":"从code7到xcode8都有哪些坑?","date":"2016-10-22T02:08:17.000Z","description":"自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。","_content":"\n\n## 冲动的惩罚\n\n自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。\n\n## 坑与填平坑\n\n### Storyboard\n对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。\n\n#### 所有UI控件的宽高设定了同一个初始值：1000。\n在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。\n但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：\n - **将Storyboar的打开方式选择xcode7.x**（在右侧Show the file inspector->interface Builder Document->open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。\n - 在代码要使用UI宽高做些计算之前，调用一下**layoutIfNeeded**。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。\n\n#### cornerRadius\n本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。\n\n#### TableView static cells\n当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。\n\n#### 不支持iOS7，却可以提交iOS7应用\nXcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？\n\n#### 卡卡卡\n最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！\n\n## 最后\n这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？\n\n","source":"_posts/从code7到xcode8都有哪些坑？.md","raw":"---\ntitle: 从code7到xcode8都有哪些坑?\ncategories:\n  - Apple Development\n  - iOS开发笔记\ndate: 2016-10-22 10:08:17\ndescription: \"自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。\"\n\ntags:\n---\n\n\n## 冲动的惩罚\n\n自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。\n\n## 坑与填平坑\n\n### Storyboard\n对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。\n\n#### 所有UI控件的宽高设定了同一个初始值：1000。\n在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。\n但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：\n - **将Storyboar的打开方式选择xcode7.x**（在右侧Show the file inspector->interface Builder Document->open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。\n - 在代码要使用UI宽高做些计算之前，调用一下**layoutIfNeeded**。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。\n\n#### cornerRadius\n本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。\n\n#### TableView static cells\n当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。\n\n#### 不支持iOS7，却可以提交iOS7应用\nXcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？\n\n#### 卡卡卡\n最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！\n\n## 最后\n这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？\n\n","slug":"从code7到xcode8都有哪些坑？","published":1,"updated":"2016-11-15T07:08:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mer000y0k04hxn412hh","content":"<h2 id=\"冲动的惩罚\"><a href=\"#冲动的惩罚\" class=\"headerlink\" title=\"冲动的惩罚\"></a>冲动的惩罚</h2><p>自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。</p>\n<h2 id=\"坑与填平坑\"><a href=\"#坑与填平坑\" class=\"headerlink\" title=\"坑与填平坑\"></a>坑与填平坑</h2><h3 id=\"Storyboard\"><a href=\"#Storyboard\" class=\"headerlink\" title=\"Storyboard\"></a>Storyboard</h3><p>对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。</p>\n<h4 id=\"所有UI控件的宽高设定了同一个初始值：1000。\"><a href=\"#所有UI控件的宽高设定了同一个初始值：1000。\" class=\"headerlink\" title=\"所有UI控件的宽高设定了同一个初始值：1000。\"></a>所有UI控件的宽高设定了同一个初始值：1000。</h4><p>在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。<br>但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：</p>\n<ul>\n<li><strong>将Storyboar的打开方式选择xcode7.x</strong>（在右侧Show the file inspector-&gt;interface Builder Document-&gt;open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。</li>\n<li>在代码要使用UI宽高做些计算之前，调用一下<strong>layoutIfNeeded</strong>。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。</li>\n</ul>\n<h4 id=\"cornerRadius\"><a href=\"#cornerRadius\" class=\"headerlink\" title=\"cornerRadius\"></a>cornerRadius</h4><p>本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。</p>\n<h4 id=\"TableView-static-cells\"><a href=\"#TableView-static-cells\" class=\"headerlink\" title=\"TableView static cells\"></a>TableView static cells</h4><p>当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。</p>\n<h4 id=\"不支持iOS7，却可以提交iOS7应用\"><a href=\"#不支持iOS7，却可以提交iOS7应用\" class=\"headerlink\" title=\"不支持iOS7，却可以提交iOS7应用\"></a>不支持iOS7，却可以提交iOS7应用</h4><p>Xcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？</p>\n<h4 id=\"卡卡卡\"><a href=\"#卡卡卡\" class=\"headerlink\" title=\"卡卡卡\"></a>卡卡卡</h4><p>最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？</p>\n","excerpt":"","more":"<h2 id=\"冲动的惩罚\"><a href=\"#冲动的惩罚\" class=\"headerlink\" title=\"冲动的惩罚\"></a>冲动的惩罚</h2><p>自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。</p>\n<h2 id=\"坑与填平坑\"><a href=\"#坑与填平坑\" class=\"headerlink\" title=\"坑与填平坑\"></a>坑与填平坑</h2><h3 id=\"Storyboard\"><a href=\"#Storyboard\" class=\"headerlink\" title=\"Storyboard\"></a>Storyboard</h3><p>对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。</p>\n<h4 id=\"所有UI控件的宽高设定了同一个初始值：1000。\"><a href=\"#所有UI控件的宽高设定了同一个初始值：1000。\" class=\"headerlink\" title=\"所有UI控件的宽高设定了同一个初始值：1000。\"></a>所有UI控件的宽高设定了同一个初始值：1000。</h4><p>在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。<br>但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：</p>\n<ul>\n<li><strong>将Storyboar的打开方式选择xcode7.x</strong>（在右侧Show the file inspector-&gt;interface Builder Document-&gt;open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。</li>\n<li>在代码要使用UI宽高做些计算之前，调用一下<strong>layoutIfNeeded</strong>。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。</li>\n</ul>\n<h4 id=\"cornerRadius\"><a href=\"#cornerRadius\" class=\"headerlink\" title=\"cornerRadius\"></a>cornerRadius</h4><p>本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。</p>\n<h4 id=\"TableView-static-cells\"><a href=\"#TableView-static-cells\" class=\"headerlink\" title=\"TableView static cells\"></a>TableView static cells</h4><p>当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。</p>\n<h4 id=\"不支持iOS7，却可以提交iOS7应用\"><a href=\"#不支持iOS7，却可以提交iOS7应用\" class=\"headerlink\" title=\"不支持iOS7，却可以提交iOS7应用\"></a>不支持iOS7，却可以提交iOS7应用</h4><p>Xcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？</p>\n<h4 id=\"卡卡卡\"><a href=\"#卡卡卡\" class=\"headerlink\" title=\"卡卡卡\"></a>卡卡卡</h4><p>最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？</p>\n"},{"title":"创建pod库的步骤","_content":"\n标签（空格分隔）： 开发 iOS\n---\n## 注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n## 验证邮箱\n```\npod trunk me\n```\n## push源码到git仓库\n## 创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n## 编辑podspec文件\n## 检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n## 使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n## 成功后`pod setup`\n## 验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","source":"_posts/创建pod库的步骤.md","raw":"---\ntitle: 创建pod库的步骤\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n - Cocoapods\n---\n\n标签（空格分隔）： 开发 iOS\n---\n## 注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n## 验证邮箱\n```\npod trunk me\n```\n## push源码到git仓库\n## 创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n## 编辑podspec文件\n## 检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n## 使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n## 成功后`pod setup`\n## 验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","slug":"创建pod库的步骤","published":1,"date":"2016-08-30T02:02:32.000Z","updated":"2016-10-17T04:09:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mew00100k04mfl8b71s","content":"<h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><h2 id=\"注册Trunk\"><a href=\"#注册Trunk\" class=\"headerlink\" title=\"注册Trunk\"></a>注册Trunk</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure>\n<h2 id=\"push源码到git仓库\"><a href=\"#push源码到git仓库\" class=\"headerlink\" title=\"push源码到git仓库\"></a>push源码到git仓库</h2><h2 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>\n<h2 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h2><h2 id=\"检查podspec文件格式是否符合规则\"><a href=\"#检查podspec文件格式是否符合规则\" class=\"headerlink\" title=\"检查podspec文件格式是否符合规则\"></a>检查podspec文件格式是否符合规则</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<h2 id=\"使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\"><a href=\"#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\" class=\"headerlink\" title=\"使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>\n<h2 id=\"成功后pod-setup\"><a href=\"#成功后pod-setup\" class=\"headerlink\" title=\"成功后pod setup\"></a>成功后<code>pod setup</code></h2><h2 id=\"验证是否成功：\"><a href=\"#验证是否成功：\" class=\"headerlink\" title=\"验证是否成功：\"></a>验证是否成功：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><h2 id=\"注册Trunk\"><a href=\"#注册Trunk\" class=\"headerlink\" title=\"注册Trunk\"></a>注册Trunk</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure>\n<h2 id=\"push源码到git仓库\"><a href=\"#push源码到git仓库\" class=\"headerlink\" title=\"push源码到git仓库\"></a>push源码到git仓库</h2><h2 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>\n<h2 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h2><h2 id=\"检查podspec文件格式是否符合规则\"><a href=\"#检查podspec文件格式是否符合规则\" class=\"headerlink\" title=\"检查podspec文件格式是否符合规则\"></a>检查podspec文件格式是否符合规则</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<h2 id=\"使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\"><a href=\"#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\" class=\"headerlink\" title=\"使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>\n<h2 id=\"成功后pod-setup\"><a href=\"#成功后pod-setup\" class=\"headerlink\" title=\"成功后pod setup\"></a>成功后<code>pod setup</code></h2><h2 id=\"验证是否成功：\"><a href=\"#验证是否成功：\" class=\"headerlink\" title=\"验证是否成功：\"></a>验证是否成功：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n"},{"title":"文件系统和虚拟文件系统交换（VFS）","_content":"\n## 硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","source":"_posts/文件系统和虚拟文件系统交换（VFS）.md","raw":"---\ntitle: 文件系统和虚拟文件系统交换（VFS）\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 文件系统\n---\n\n## 硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","slug":"文件系统和虚拟文件系统交换（VFS）","published":1,"date":"2016-08-30T02:11:37.000Z","updated":"2016-10-18T13:05:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mf000130k04kpvole9u","content":"<h2 id=\"硬盘分区\"><a href=\"#硬盘分区\" class=\"headerlink\" title=\"硬盘分区\"></a>硬盘分区</h2><h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"硬盘分区\"><a href=\"#硬盘分区\" class=\"headerlink\" title=\"硬盘分区\"></a>硬盘分区</h2><h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n"},{"title":"由生到死--内核引导和内核崩溃","_content":"\n## XNU内核的编译\n参考[Building xnu for OS X 10.11 El Capitan][2],但是还没有成功编译通过。。。\n\n## 一个内核，支持多种架构\n- osfmk目录包含了架构相关的子目录（如：i386，x86_64）。\n- pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。\n- i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：\n ![pexpert结构][1]\n\n## 内核代码树\n- 可以使用[FXR浏览工具](http://fxr.watson.org)查看源码。\n- XNU主目录结构：\n\t![XNU主目录结构][3]\n\t\n- BSD目录结构：\n\t![BSD目录结构][4]\n\t\n- OSFMK目录结构：\n\t![OSFMK目录结构][5]\t\n\n## XNU的引导过程\n**XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。**\n\n### 从高层次看XNU的引导过程\n- 整个过程如下图，后面会介绍各个阶段的细节。\n\t![高层次看XNU的引导过程][6]\n- **OSX：vstart**\n\t- 如果是Debug环境初始化串口（pal_serial_init()）。\n\t- 开启NX/XD：防止代码注入。\n\t- 初始化主CPU的[GDT和LDT][7]，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）\n\t- 初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）\n\t- 主从CPU调用相应的i386_init/i386_init_slave。\n\t\n- **iOS：start**\n\n\t这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。\n\n- **[i386|arm]_init**（osfmk/i386/i386_init.c）\n\n\t*主要工作是初始化主CPU为可用状态，然后准备好内核引导。*\n\n- **i386_init_slave()**\n初始化从CPU。\n\n- **machine_startup**\n\n主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。\n\n- **kernel_bootstrap**\n这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：\n\t- **初始化虚拟内存**。\n\t- **IPC（进程间通信）**：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。\n\t- **时钟**：通过时钟实现闹铃、报时功能。 \n\t- **账本**：Mach系统的记账功能。\n\t- **任务**：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。\n\t- **线程**：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。\n其中调用的重要的函数有：\n\t- kernel_bootstrap_thread:他的工作如下\n\t\t1. 主线程开始以`kernel_bootstrap_thread`的身份运行，初始化各个子系统。\n\t\t2. 调用kernel_create_thread()派生辅助线程。第一个创建的线程是**idle线程**（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。\n\t\t3. 下-个创建线程就是**线程调度器**，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。\n\t\t4. OSX的XNU启动`mapping_replenish线程`，在iOS上是`zone_refill_thread线程`。\n\t\t5. 如果内核设置了**SERIAL_KDP**,那么调度器会调用`init_kdp()`初始化调试器。\n\t\t6. 初始化**IOKit**，如果没有**IOKit**，XNU将无法访问硬件设备。\n\t\t7. 启用**中断**。\n\t\t8. 初始化**共享区模块（shared region）**，dyld在加载共享库时会使用这个模块，内核本身的**commpage**也会使用这个模块，**commpage**指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。\n\t\t9. 如果编译时启动了**MAC（Mandatory Access Control）**，则会调用`mac_policy_initmach()`。\n\t\t10. 调用`bsd_init`初始化BSD子系统，这个函数最终会派生出init任务来执行`bin/launchd`，init任务是所有用户态进程的祖先。\n\t\t11. 如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。\n\n## 睡眠和唤醒\n睡眠流程一般如下：\n\n- 除了当前CPU外，停止其他的CPU。\n- 关闭本地的APIC，准备进入睡眠。\n- 输出一条kdebug消息。\n- 在x86_64平台上保留CR3。\n- 调用`acpi_sleep_cpu()`,将CPU设置为睡眠状态。\n- 将控制权交给固件。\n\n唤醒处理程序的工作是：\n\n- 切换回64位模式。\n- 恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。\n- 恢复所有保存的寄存器。\n\n\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\n[7]: http://blog.csdn.net/yleek/article/details/8204393\n","source":"_posts/由生到死--内核引导和内核崩溃.md","raw":"---\ntitle: 由生到死--内核引导和内核崩溃\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 内核\n---\n\n## XNU内核的编译\n参考[Building xnu for OS X 10.11 El Capitan][2],但是还没有成功编译通过。。。\n\n## 一个内核，支持多种架构\n- osfmk目录包含了架构相关的子目录（如：i386，x86_64）。\n- pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。\n- i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：\n ![pexpert结构][1]\n\n## 内核代码树\n- 可以使用[FXR浏览工具](http://fxr.watson.org)查看源码。\n- XNU主目录结构：\n\t![XNU主目录结构][3]\n\t\n- BSD目录结构：\n\t![BSD目录结构][4]\n\t\n- OSFMK目录结构：\n\t![OSFMK目录结构][5]\t\n\n## XNU的引导过程\n**XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。**\n\n### 从高层次看XNU的引导过程\n- 整个过程如下图，后面会介绍各个阶段的细节。\n\t![高层次看XNU的引导过程][6]\n- **OSX：vstart**\n\t- 如果是Debug环境初始化串口（pal_serial_init()）。\n\t- 开启NX/XD：防止代码注入。\n\t- 初始化主CPU的[GDT和LDT][7]，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）\n\t- 初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）\n\t- 主从CPU调用相应的i386_init/i386_init_slave。\n\t\n- **iOS：start**\n\n\t这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。\n\n- **[i386|arm]_init**（osfmk/i386/i386_init.c）\n\n\t*主要工作是初始化主CPU为可用状态，然后准备好内核引导。*\n\n- **i386_init_slave()**\n初始化从CPU。\n\n- **machine_startup**\n\n主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。\n\n- **kernel_bootstrap**\n这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：\n\t- **初始化虚拟内存**。\n\t- **IPC（进程间通信）**：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。\n\t- **时钟**：通过时钟实现闹铃、报时功能。 \n\t- **账本**：Mach系统的记账功能。\n\t- **任务**：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。\n\t- **线程**：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。\n其中调用的重要的函数有：\n\t- kernel_bootstrap_thread:他的工作如下\n\t\t1. 主线程开始以`kernel_bootstrap_thread`的身份运行，初始化各个子系统。\n\t\t2. 调用kernel_create_thread()派生辅助线程。第一个创建的线程是**idle线程**（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。\n\t\t3. 下-个创建线程就是**线程调度器**，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。\n\t\t4. OSX的XNU启动`mapping_replenish线程`，在iOS上是`zone_refill_thread线程`。\n\t\t5. 如果内核设置了**SERIAL_KDP**,那么调度器会调用`init_kdp()`初始化调试器。\n\t\t6. 初始化**IOKit**，如果没有**IOKit**，XNU将无法访问硬件设备。\n\t\t7. 启用**中断**。\n\t\t8. 初始化**共享区模块（shared region）**，dyld在加载共享库时会使用这个模块，内核本身的**commpage**也会使用这个模块，**commpage**指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。\n\t\t9. 如果编译时启动了**MAC（Mandatory Access Control）**，则会调用`mac_policy_initmach()`。\n\t\t10. 调用`bsd_init`初始化BSD子系统，这个函数最终会派生出init任务来执行`bin/launchd`，init任务是所有用户态进程的祖先。\n\t\t11. 如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。\n\n## 睡眠和唤醒\n睡眠流程一般如下：\n\n- 除了当前CPU外，停止其他的CPU。\n- 关闭本地的APIC，准备进入睡眠。\n- 输出一条kdebug消息。\n- 在x86_64平台上保留CR3。\n- 调用`acpi_sleep_cpu()`,将CPU设置为睡眠状态。\n- 将控制权交给固件。\n\n唤醒处理程序的工作是：\n\n- 切换回64位模式。\n- 恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。\n- 恢复所有保存的寄存器。\n\n\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\n[7]: http://blog.csdn.net/yleek/article/details/8204393\n","slug":"由生到死--内核引导和内核崩溃","published":1,"date":"2016-09-07T12:43:53.000Z","updated":"2016-10-18T13:05:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mf400160k04aa7wlwvh","content":"<h2 id=\"XNU内核的编译\"><a href=\"#XNU内核的编译\" class=\"headerlink\" title=\"XNU内核的编译\"></a>XNU内核的编译</h2><p>参考<a href=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>\n<h2 id=\"一个内核，支持多种架构\"><a href=\"#一个内核，支持多种架构\" class=\"headerlink\" title=\"一个内核，支持多种架构\"></a>一个内核，支持多种架构</h2><ul>\n<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>\n<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>\n<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\" alt=\"pexpert结构\"></li>\n</ul>\n<h2 id=\"内核代码树\"><a href=\"#内核代码树\" class=\"headerlink\" title=\"内核代码树\"></a>内核代码树</h2><ul>\n<li>可以使用<a href=\"http://fxr.watson.org\" target=\"_blank\" rel=\"external\">FXR浏览工具</a>查看源码。</li>\n<li><p>XNU主目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\" alt=\"XNU主目录结构\"></p>\n</li>\n<li><p>BSD目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\" alt=\"BSD目录结构\"></p>\n</li>\n<li><p>OSFMK目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\" alt=\"OSFMK目录结构\">    </p>\n</li>\n</ul>\n<h2 id=\"XNU的引导过程\"><a href=\"#XNU的引导过程\" class=\"headerlink\" title=\"XNU的引导过程\"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>\n<h3 id=\"从高层次看XNU的引导过程\"><a href=\"#从高层次看XNU的引导过程\" class=\"headerlink\" title=\"从高层次看XNU的引导过程\"></a>从高层次看XNU的引导过程</h3><ul>\n<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\" alt=\"高层次看XNU的引导过程\"></li>\n<li><p><strong>OSX：vstart</strong></p>\n<ul>\n<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>\n<li>开启NX/XD：防止代码注入。</li>\n<li>初始化主CPU的<a href=\"http://blog.csdn.net/yleek/article/details/8204393\" target=\"_blank\" rel=\"external\">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>\n<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>\n<li>主从CPU调用相应的i386_init/i386_init_slave。</li>\n</ul>\n</li>\n<li><p><strong>iOS：start</strong></p>\n<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>\n</li>\n<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>\n<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>\n</li>\n<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>\n</li>\n<li><p><strong>machine_startup</strong></p>\n</li>\n</ul>\n<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>\n<ul>\n<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>\n<li><strong>初始化虚拟内存</strong>。</li>\n<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>\n<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>\n<li><strong>账本</strong>：Mach系统的记账功能。</li>\n<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>\n<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>\n<li>kernel_bootstrap_thread:他的工作如下<ol>\n<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>\n<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>\n<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>\n<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>\n<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>\n<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>\n<li>启用<strong>中断</strong>。</li>\n<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>\n<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>\n<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>\n<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"睡眠和唤醒\"><a href=\"#睡眠和唤醒\" class=\"headerlink\" title=\"睡眠和唤醒\"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>\n<ul>\n<li>除了当前CPU外，停止其他的CPU。</li>\n<li>关闭本地的APIC，准备进入睡眠。</li>\n<li>输出一条kdebug消息。</li>\n<li>在x86_64平台上保留CR3。</li>\n<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>\n<li>将控制权交给固件。</li>\n</ul>\n<p>唤醒处理程序的工作是：</p>\n<ul>\n<li>切换回64位模式。</li>\n<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>\n<li>恢复所有保存的寄存器。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"XNU内核的编译\"><a href=\"#XNU内核的编译\" class=\"headerlink\" title=\"XNU内核的编译\"></a>XNU内核的编译</h2><p>参考<a href=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>\n<h2 id=\"一个内核，支持多种架构\"><a href=\"#一个内核，支持多种架构\" class=\"headerlink\" title=\"一个内核，支持多种架构\"></a>一个内核，支持多种架构</h2><ul>\n<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>\n<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>\n<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\" alt=\"pexpert结构\"></li>\n</ul>\n<h2 id=\"内核代码树\"><a href=\"#内核代码树\" class=\"headerlink\" title=\"内核代码树\"></a>内核代码树</h2><ul>\n<li>可以使用<a href=\"http://fxr.watson.org\">FXR浏览工具</a>查看源码。</li>\n<li><p>XNU主目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\" alt=\"XNU主目录结构\"></p>\n</li>\n<li><p>BSD目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\" alt=\"BSD目录结构\"></p>\n</li>\n<li><p>OSFMK目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\" alt=\"OSFMK目录结构\">    </p>\n</li>\n</ul>\n<h2 id=\"XNU的引导过程\"><a href=\"#XNU的引导过程\" class=\"headerlink\" title=\"XNU的引导过程\"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>\n<h3 id=\"从高层次看XNU的引导过程\"><a href=\"#从高层次看XNU的引导过程\" class=\"headerlink\" title=\"从高层次看XNU的引导过程\"></a>从高层次看XNU的引导过程</h3><ul>\n<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\" alt=\"高层次看XNU的引导过程\"></li>\n<li><p><strong>OSX：vstart</strong></p>\n<ul>\n<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>\n<li>开启NX/XD：防止代码注入。</li>\n<li>初始化主CPU的<a href=\"http://blog.csdn.net/yleek/article/details/8204393\">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>\n<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>\n<li>主从CPU调用相应的i386_init/i386_init_slave。</li>\n</ul>\n</li>\n<li><p><strong>iOS：start</strong></p>\n<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>\n</li>\n<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>\n<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>\n</li>\n<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>\n</li>\n<li><p><strong>machine_startup</strong></p>\n</li>\n</ul>\n<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>\n<ul>\n<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>\n<li><strong>初始化虚拟内存</strong>。</li>\n<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>\n<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>\n<li><strong>账本</strong>：Mach系统的记账功能。</li>\n<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>\n<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>\n<li>kernel_bootstrap_thread:他的工作如下<ol>\n<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>\n<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>\n<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>\n<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>\n<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>\n<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>\n<li>启用<strong>中断</strong>。</li>\n<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>\n<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>\n<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>\n<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"睡眠和唤醒\"><a href=\"#睡眠和唤醒\" class=\"headerlink\" title=\"睡眠和唤醒\"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>\n<ul>\n<li>除了当前CPU外，停止其他的CPU。</li>\n<li>关闭本地的APIC，准备进入睡眠。</li>\n<li>输出一条kdebug消息。</li>\n<li>在x86_64平台上保留CR3。</li>\n<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>\n<li>将控制权交给固件。</li>\n</ul>\n<p>唤醒处理程序的工作是：</p>\n<ul>\n<li>切换回64位模式。</li>\n<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>\n<li>恢复所有保存的寄存器。</li>\n</ul>\n<hr>\n"},{"title":"网络七层协议（结合操作系统来了解）","_content":"\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n##硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","source":"_posts/网络七层协议（结合操作系统来了解）.md","raw":"---\ntitle: 网络七层协议（结合操作系统来了解）\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 网络\n---\n\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n##硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","slug":"网络七层协议（结合操作系统来了解）","published":1,"date":"2016-08-30T02:09:57.000Z","updated":"2016-10-18T13:04:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mf700190k04acfe7qta","content":"<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<p>##硬件</p>\n<h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n","excerpt":"","more":"<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<p>##硬件</p>\n<h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n"},{"title":"简约的iOS音乐播放UI控件","date":"2016-05-24T10:46:59.000Z","_content":"\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","source":"_posts/简约的iOS音乐播放UI控件.md","raw":"---\ntitle: 简约的iOS音乐播放UI控件\ndate: 2016-05-24 18:46:59\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","slug":"简约的iOS音乐播放UI控件","published":1,"updated":"2016-10-15T11:35:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mfg001c0k04zebng5ck","content":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n"},{"title":"苹果文字系统","date":"2016-11-15T02:33:17.000Z","description":"对苹果关于文字处理部分的官方文档进行了总结，基本上涵盖了iOS开发中关于Text的所需了解的知识。","_content":"\n\n## 整体架构\n![文字系统架构][1]\n\n## 文字排版知识\n - 首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：\n![两个字符对应一个字形的例子][8]\n\n- 字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由`NSLayoutManager`来管理的。\n\n- 字形矩阵\n![字形矩阵][9]\n\n- 字距调整\n![kernig][10]\n\n- 一行文字\n![字形][6]\n由上图可见：\n\n- 一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。\n- LineHeight = Ascent + Descent + lineGap\n\n## Text Kit\n\n基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：\n![Text Kit所处位置][11]\n\n### Text Kit中的主要对象\n\n![Text Kit中的主要对象][12]\n\n- **Text container**: 通常是`NSTextContainer`对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。\n\n- **Layout manager**:通常是`NSLayoutManager`对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。\n  - 将字符跟字形进行映射。\n  - 根据NSTextContainer定义的区域来排版字形。\n\n- **Text storage**通常是`NSTextStorage`对象或者其子对象，`NSTextStorage`是`NSMutableAttributedString`的子对象，其包含多个`NSLayoutManager`，当有变动的时候，通知`NSLayoutManager`刷新\n\n- **对应关系**： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。\n\n## 直接绘制文字\n\n### NSString的UIStringDrawing category\n可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。\n\n### CATextLayer\nCATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。\n\n### Core Text\n- 通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。\n\n- Core Text框架综合了Core Foundation以及Core Graphics。\n\n- Core Text包含两个重要的部分：layout engine以及font technology。\n\n#### Layout engine\nCore Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：`CTFramesetterRef`、`CTFrameRef`、`CTTypesetterRef`、`CTLineRef`、`CTRunRef`这几个对象。如下图所示：\n\n![][14]\n\n- CTFramesetterRef\n- CTFrameRef\n- CTTypesetterRef\n- CTLineRef\n- CTRunRef\n\n#### Core Text Font Opaque Types\n通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。\n\n- CTFontRef：对应UIFont\n- CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef\n- CTFontCollectionRef：\n\n## 自定义可与键盘交互的Text View\n最重要的是要实现UIKeyInput协议。可参考apple[官方文档][13]的Simple Text Input章节以及[Custom Views for Data Input][7]。涉及到的对象或协议有：\n\n- UIKeyInput\n- UITextInput\n- UITextPosition\n- UITextRange\n- UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举`UITextGranularity`值来表示。默认的分词器是：`UITextInputStringTokenizer`。\n\n\n## 参考文档：\n[Typographical Concepts][2]\n[Text Attributes][3]\n[Introduction to Text Layout Programming Guide][4]\n[Introduction to Text System Storage Layer Overview][5]\n[Custom Views for Data Input][7]\n[Lower Level Text-Handling Technologies][13]\n\n---\n[1]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\n[2]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\n[3]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\n[4]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\n[5]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\n[6]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\n[7]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\n[8]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\n[9]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\n[10]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\n[11]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\n[12]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\n[13]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\n[14]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\n","source":"_posts/苹果的文字系统.md","raw":"---\ntitle: 苹果文字系统\ncategories: iOS开发笔记\ntags: CoreText\ndate: 2016-11-15 10:33:17\ndescription: \"对苹果关于文字处理部分的官方文档进行了总结，基本上涵盖了iOS开发中关于Text的所需了解的知识。\"\n---\n\n\n## 整体架构\n![文字系统架构][1]\n\n## 文字排版知识\n - 首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：\n![两个字符对应一个字形的例子][8]\n\n- 字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由`NSLayoutManager`来管理的。\n\n- 字形矩阵\n![字形矩阵][9]\n\n- 字距调整\n![kernig][10]\n\n- 一行文字\n![字形][6]\n由上图可见：\n\n- 一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。\n- LineHeight = Ascent + Descent + lineGap\n\n## Text Kit\n\n基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：\n![Text Kit所处位置][11]\n\n### Text Kit中的主要对象\n\n![Text Kit中的主要对象][12]\n\n- **Text container**: 通常是`NSTextContainer`对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。\n\n- **Layout manager**:通常是`NSLayoutManager`对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。\n  - 将字符跟字形进行映射。\n  - 根据NSTextContainer定义的区域来排版字形。\n\n- **Text storage**通常是`NSTextStorage`对象或者其子对象，`NSTextStorage`是`NSMutableAttributedString`的子对象，其包含多个`NSLayoutManager`，当有变动的时候，通知`NSLayoutManager`刷新\n\n- **对应关系**： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。\n\n## 直接绘制文字\n\n### NSString的UIStringDrawing category\n可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。\n\n### CATextLayer\nCATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。\n\n### Core Text\n- 通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。\n\n- Core Text框架综合了Core Foundation以及Core Graphics。\n\n- Core Text包含两个重要的部分：layout engine以及font technology。\n\n#### Layout engine\nCore Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：`CTFramesetterRef`、`CTFrameRef`、`CTTypesetterRef`、`CTLineRef`、`CTRunRef`这几个对象。如下图所示：\n\n![][14]\n\n- CTFramesetterRef\n- CTFrameRef\n- CTTypesetterRef\n- CTLineRef\n- CTRunRef\n\n#### Core Text Font Opaque Types\n通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。\n\n- CTFontRef：对应UIFont\n- CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef\n- CTFontCollectionRef：\n\n## 自定义可与键盘交互的Text View\n最重要的是要实现UIKeyInput协议。可参考apple[官方文档][13]的Simple Text Input章节以及[Custom Views for Data Input][7]。涉及到的对象或协议有：\n\n- UIKeyInput\n- UITextInput\n- UITextPosition\n- UITextRange\n- UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举`UITextGranularity`值来表示。默认的分词器是：`UITextInputStringTokenizer`。\n\n\n## 参考文档：\n[Typographical Concepts][2]\n[Text Attributes][3]\n[Introduction to Text Layout Programming Guide][4]\n[Introduction to Text System Storage Layer Overview][5]\n[Custom Views for Data Input][7]\n[Lower Level Text-Handling Technologies][13]\n\n---\n[1]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\n[2]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\n[3]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\n[4]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\n[5]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\n[6]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\n[7]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\n[8]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\n[9]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\n[10]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\n[11]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\n[12]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\n[13]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\n[14]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\n","slug":"苹果的文字系统","published":1,"updated":"2016-11-15T07:01:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mfl001h0k04w7ucqjg8","content":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\" alt=\"文字系统架构\"></p>\n<h2 id=\"文字排版知识\"><a href=\"#文字排版知识\" class=\"headerlink\" title=\"文字排版知识\"></a>文字排版知识</h2><ul>\n<li>首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\" alt=\"两个字符对应一个字形的例子\"></li>\n</ul>\n<ul>\n<li><p>字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由<code>NSLayoutManager</code>来管理的。</p>\n</li>\n<li><p>字形矩阵<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\" alt=\"字形矩阵\"></p>\n</li>\n<li><p>字距调整<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\" alt=\"kernig\"></p>\n</li>\n<li><p>一行文字<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\" alt=\"字形\"><br>由上图可见：</p>\n</li>\n<li><p>一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。</p>\n</li>\n<li>LineHeight = Ascent + Descent + lineGap</li>\n</ul>\n<h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p>基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\" alt=\"Text Kit所处位置\"></p>\n<h3 id=\"Text-Kit中的主要对象\"><a href=\"#Text-Kit中的主要对象\" class=\"headerlink\" title=\"Text Kit中的主要对象\"></a>Text Kit中的主要对象</h3><p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\" alt=\"Text Kit中的主要对象\"></p>\n<ul>\n<li><p><strong>Text container</strong>: 通常是<code>NSTextContainer</code>对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。</p>\n</li>\n<li><p><strong>Layout manager</strong>:通常是<code>NSLayoutManager</code>对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。</p>\n<ul>\n<li>将字符跟字形进行映射。</li>\n<li>根据NSTextContainer定义的区域来排版字形。</li>\n</ul>\n</li>\n<li><p><strong>Text storage</strong>通常是<code>NSTextStorage</code>对象或者其子对象，<code>NSTextStorage</code>是<code>NSMutableAttributedString</code>的子对象，其包含多个<code>NSLayoutManager</code>，当有变动的时候，通知<code>NSLayoutManager</code>刷新</p>\n</li>\n<li><p><strong>对应关系</strong>： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。</p>\n</li>\n</ul>\n<h2 id=\"直接绘制文字\"><a href=\"#直接绘制文字\" class=\"headerlink\" title=\"直接绘制文字\"></a>直接绘制文字</h2><h3 id=\"NSString的UIStringDrawing-category\"><a href=\"#NSString的UIStringDrawing-category\" class=\"headerlink\" title=\"NSString的UIStringDrawing category\"></a>NSString的UIStringDrawing category</h3><p>可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。</p>\n<h3 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h3><p>CATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。</p>\n<h3 id=\"Core-Text\"><a href=\"#Core-Text\" class=\"headerlink\" title=\"Core Text\"></a>Core Text</h3><ul>\n<li><p>通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。</p>\n</li>\n<li><p>Core Text框架综合了Core Foundation以及Core Graphics。</p>\n</li>\n<li><p>Core Text包含两个重要的部分：layout engine以及font technology。</p>\n</li>\n</ul>\n<h4 id=\"Layout-engine\"><a href=\"#Layout-engine\" class=\"headerlink\" title=\"Layout engine\"></a>Layout engine</h4><p>Core Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：<code>CTFramesetterRef</code>、<code>CTFrameRef</code>、<code>CTTypesetterRef</code>、<code>CTLineRef</code>、<code>CTRunRef</code>这几个对象。如下图所示：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\" alt=\"\"></p>\n<ul>\n<li>CTFramesetterRef</li>\n<li>CTFrameRef</li>\n<li>CTTypesetterRef</li>\n<li>CTLineRef</li>\n<li>CTRunRef</li>\n</ul>\n<h4 id=\"Core-Text-Font-Opaque-Types\"><a href=\"#Core-Text-Font-Opaque-Types\" class=\"headerlink\" title=\"Core Text Font Opaque Types\"></a>Core Text Font Opaque Types</h4><p>通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。</p>\n<ul>\n<li>CTFontRef：对应UIFont</li>\n<li>CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef</li>\n<li>CTFontCollectionRef：</li>\n</ul>\n<h2 id=\"自定义可与键盘交互的Text-View\"><a href=\"#自定义可与键盘交互的Text-View\" class=\"headerlink\" title=\"自定义可与键盘交互的Text View\"></a>自定义可与键盘交互的Text View</h2><p>最重要的是要实现UIKeyInput协议。可参考apple<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\" target=\"_blank\" rel=\"external\">官方文档</a>的Simple Text Input章节以及<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\" target=\"_blank\" rel=\"external\">Custom Views for Data Input</a>。涉及到的对象或协议有：</p>\n<ul>\n<li>UIKeyInput</li>\n<li>UITextInput</li>\n<li>UITextPosition</li>\n<li>UITextRange</li>\n<li>UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举<code>UITextGranularity</code>值来表示。默认的分词器是：<code>UITextInputStringTokenizer</code>。</li>\n</ul>\n<h2 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h2><p><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\" target=\"_blank\" rel=\"external\">Typographical Concepts</a><br><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\" target=\"_blank\" rel=\"external\">Text Attributes</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\" target=\"_blank\" rel=\"external\">Introduction to Text Layout Programming Guide</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\" target=\"_blank\" rel=\"external\">Introduction to Text System Storage Layer Overview</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\" target=\"_blank\" rel=\"external\">Custom Views for Data Input</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\" target=\"_blank\" rel=\"external\">Lower Level Text-Handling Technologies</a></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\" alt=\"文字系统架构\"></p>\n<h2 id=\"文字排版知识\"><a href=\"#文字排版知识\" class=\"headerlink\" title=\"文字排版知识\"></a>文字排版知识</h2><ul>\n<li>首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\" alt=\"两个字符对应一个字形的例子\"></li>\n</ul>\n<ul>\n<li><p>字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由<code>NSLayoutManager</code>来管理的。</p>\n</li>\n<li><p>字形矩阵<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\" alt=\"字形矩阵\"></p>\n</li>\n<li><p>字距调整<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\" alt=\"kernig\"></p>\n</li>\n<li><p>一行文字<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\" alt=\"字形\"><br>由上图可见：</p>\n</li>\n<li><p>一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。</p>\n</li>\n<li>LineHeight = Ascent + Descent + lineGap</li>\n</ul>\n<h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p>基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\" alt=\"Text Kit所处位置\"></p>\n<h3 id=\"Text-Kit中的主要对象\"><a href=\"#Text-Kit中的主要对象\" class=\"headerlink\" title=\"Text Kit中的主要对象\"></a>Text Kit中的主要对象</h3><p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\" alt=\"Text Kit中的主要对象\"></p>\n<ul>\n<li><p><strong>Text container</strong>: 通常是<code>NSTextContainer</code>对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。</p>\n</li>\n<li><p><strong>Layout manager</strong>:通常是<code>NSLayoutManager</code>对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。</p>\n<ul>\n<li>将字符跟字形进行映射。</li>\n<li>根据NSTextContainer定义的区域来排版字形。</li>\n</ul>\n</li>\n<li><p><strong>Text storage</strong>通常是<code>NSTextStorage</code>对象或者其子对象，<code>NSTextStorage</code>是<code>NSMutableAttributedString</code>的子对象，其包含多个<code>NSLayoutManager</code>，当有变动的时候，通知<code>NSLayoutManager</code>刷新</p>\n</li>\n<li><p><strong>对应关系</strong>： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。</p>\n</li>\n</ul>\n<h2 id=\"直接绘制文字\"><a href=\"#直接绘制文字\" class=\"headerlink\" title=\"直接绘制文字\"></a>直接绘制文字</h2><h3 id=\"NSString的UIStringDrawing-category\"><a href=\"#NSString的UIStringDrawing-category\" class=\"headerlink\" title=\"NSString的UIStringDrawing category\"></a>NSString的UIStringDrawing category</h3><p>可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。</p>\n<h3 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h3><p>CATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。</p>\n<h3 id=\"Core-Text\"><a href=\"#Core-Text\" class=\"headerlink\" title=\"Core Text\"></a>Core Text</h3><ul>\n<li><p>通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。</p>\n</li>\n<li><p>Core Text框架综合了Core Foundation以及Core Graphics。</p>\n</li>\n<li><p>Core Text包含两个重要的部分：layout engine以及font technology。</p>\n</li>\n</ul>\n<h4 id=\"Layout-engine\"><a href=\"#Layout-engine\" class=\"headerlink\" title=\"Layout engine\"></a>Layout engine</h4><p>Core Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：<code>CTFramesetterRef</code>、<code>CTFrameRef</code>、<code>CTTypesetterRef</code>、<code>CTLineRef</code>、<code>CTRunRef</code>这几个对象。如下图所示：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\" alt=\"\"></p>\n<ul>\n<li>CTFramesetterRef</li>\n<li>CTFrameRef</li>\n<li>CTTypesetterRef</li>\n<li>CTLineRef</li>\n<li>CTRunRef</li>\n</ul>\n<h4 id=\"Core-Text-Font-Opaque-Types\"><a href=\"#Core-Text-Font-Opaque-Types\" class=\"headerlink\" title=\"Core Text Font Opaque Types\"></a>Core Text Font Opaque Types</h4><p>通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。</p>\n<ul>\n<li>CTFontRef：对应UIFont</li>\n<li>CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef</li>\n<li>CTFontCollectionRef：</li>\n</ul>\n<h2 id=\"自定义可与键盘交互的Text-View\"><a href=\"#自定义可与键盘交互的Text-View\" class=\"headerlink\" title=\"自定义可与键盘交互的Text View\"></a>自定义可与键盘交互的Text View</h2><p>最重要的是要实现UIKeyInput协议。可参考apple<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\">官方文档</a>的Simple Text Input章节以及<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\">Custom Views for Data Input</a>。涉及到的对象或协议有：</p>\n<ul>\n<li>UIKeyInput</li>\n<li>UITextInput</li>\n<li>UITextPosition</li>\n<li>UITextRange</li>\n<li>UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举<code>UITextGranularity</code>值来表示。默认的分词器是：<code>UITextInputStringTokenizer</code>。</li>\n</ul>\n<h2 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h2><p><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\">Typographical Concepts</a><br><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\">Text Attributes</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\">Introduction to Text Layout Programming Guide</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\">Introduction to Text System Storage Layer Overview</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\">Custom Views for Data Input</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\">Lower Level Text-Handling Technologies</a></p>\n<hr>\n"},{"title":"读书笔记之《如何阅读一本书》","_content":"\n## 阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n## 基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n## 检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","source":"_posts/读书笔记之《如何阅读一本书》.md","raw":"---\ntitle: 读书笔记之《如何阅读一本书》\ncategories: \n - 方法论\ntags:\n - 学习方法\n---\n\n## 阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n## 基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n## 检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","slug":"读书笔记之《如何阅读一本书》","published":1,"date":"2016-08-30T01:57:32.000Z","updated":"2016-10-20T10:48:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mfo001k0k04emyl2h7o","content":"<h2 id=\"阅读的四个层次\"><a href=\"#阅读的四个层次\" class=\"headerlink\" title=\"阅读的四个层次\"></a>阅读的四个层次</h2><ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<h2 id=\"基础阅读（四个阶段）\"><a href=\"#基础阅读（四个阶段）\" class=\"headerlink\" title=\"基础阅读（四个阶段）\"></a>基础阅读（四个阶段）</h2><ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<h2 id=\"检视阅读（如何做）\"><a href=\"#检视阅读（如何做）\" class=\"headerlink\" title=\"检视阅读（如何做）\"></a>检视阅读（如何做）</h2><ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"阅读的四个层次\"><a href=\"#阅读的四个层次\" class=\"headerlink\" title=\"阅读的四个层次\"></a>阅读的四个层次</h2><ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<h2 id=\"基础阅读（四个阶段）\"><a href=\"#基础阅读（四个阶段）\" class=\"headerlink\" title=\"基础阅读（四个阶段）\"></a>基础阅读（四个阶段）</h2><ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<h2 id=\"检视阅读（如何做）\"><a href=\"#检视阅读（如何做）\" class=\"headerlink\" title=\"检视阅读（如何做）\"></a>检视阅读（如何做）</h2><ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n"},{"title":"贯穿始终-launchd","_content":"\n## launchd\nlaunchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。\nlaunchd分为两种类型的后台作业：\n\n- **守护程序**（daemon），不可和用户交互。\n- **代理程序**（agent），特殊的守护程序，可以和用户交互。\n\n## launchd的职责\n\n### 运行定时作业\n指定时间运行指定的命令。\n\n### 启动网络服务\n绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。\n\n### 提供自举服务<servers/bootstrap.h>\n- launchd在启动的时候声明一个端口（**bootstrap_port**）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个**bootstrap_port**来访问自举服务器来查询某个服务，并且匹配服务程序的端口。\n- 如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数`bootstrap_check_in()`来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。\n\n### 事物支持\n`vproc_transaction_begi`n和`vproc_transaction_end`之间的操作称为**未决事物**，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。\n\n### 资源限制和遏制\niOS Jetsam机制，可以强制施行虚拟内存使用率限制。\n\n### Autorun模拟和文件系统观察\n- launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。\n- 通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。\n\n### 整合了I/O Kit\n\n## iOS的launchDeamon\niOS包含的launchDeamon列表如下图所示：\n![launchDeamon][1]\n\n**其中最重要的两个守护进程是lockdownd和SpringBoard**\n\n### lockdownd\nlockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。\n\n### SpringBoard\n- 创建GUI\n- 处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。\n- SpringBoard包含大量的线程，比如：\n\t- 有Web相关的线程（WebCore和WebThread）\n\t- WiFiManager\n\t- CoreAnimation\n- SpringBoard通过launchd注册了很多Mach端口，其中最重要的是`PurpleSystemEventPort`，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。\n\n## XPC\n- XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：\n\n```\nxpc_connection_send_message\n(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.\n```\n```\nxpc_connection_send_barrier\n(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.\n```\n```\nxpc_connection_send_message_with_reply\n(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.\n```\n```\nxpc_object_t\nxpc_connection_send_message_with_reply_sync\n(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value\n```\n- XPC的例子可以参照：苹果官方的[SandboxedFetch][2]\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\n[2]: https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/贯穿始终-launchd.md","raw":"---\ntitle: 贯穿始终-launchd\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n - launchd\n---\n\n## launchd\nlaunchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。\nlaunchd分为两种类型的后台作业：\n\n- **守护程序**（daemon），不可和用户交互。\n- **代理程序**（agent），特殊的守护程序，可以和用户交互。\n\n## launchd的职责\n\n### 运行定时作业\n指定时间运行指定的命令。\n\n### 启动网络服务\n绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。\n\n### 提供自举服务<servers/bootstrap.h>\n- launchd在启动的时候声明一个端口（**bootstrap_port**）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个**bootstrap_port**来访问自举服务器来查询某个服务，并且匹配服务程序的端口。\n- 如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数`bootstrap_check_in()`来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。\n\n### 事物支持\n`vproc_transaction_begi`n和`vproc_transaction_end`之间的操作称为**未决事物**，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。\n\n### 资源限制和遏制\niOS Jetsam机制，可以强制施行虚拟内存使用率限制。\n\n### Autorun模拟和文件系统观察\n- launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。\n- 通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。\n\n### 整合了I/O Kit\n\n## iOS的launchDeamon\niOS包含的launchDeamon列表如下图所示：\n![launchDeamon][1]\n\n**其中最重要的两个守护进程是lockdownd和SpringBoard**\n\n### lockdownd\nlockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。\n\n### SpringBoard\n- 创建GUI\n- 处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。\n- SpringBoard包含大量的线程，比如：\n\t- 有Web相关的线程（WebCore和WebThread）\n\t- WiFiManager\n\t- CoreAnimation\n- SpringBoard通过launchd注册了很多Mach端口，其中最重要的是`PurpleSystemEventPort`，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。\n\n## XPC\n- XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：\n\n```\nxpc_connection_send_message\n(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.\n```\n```\nxpc_connection_send_barrier\n(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.\n```\n```\nxpc_connection_send_message_with_reply\n(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.\n```\n```\nxpc_object_t\nxpc_connection_send_message_with_reply_sync\n(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value\n```\n- XPC的例子可以参照：苹果官方的[SandboxedFetch][2]\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\n[2]: https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"贯穿始终-launchd","published":1,"date":"2016-09-02T13:22:44.000Z","updated":"2016-10-18T13:04:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mft001o0k04lgzbwp1i","content":"<h2 id=\"launchd\"><a href=\"#launchd\" class=\"headerlink\" title=\"launchd\"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>\n<ul>\n<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>\n<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>\n</ul>\n<h2 id=\"launchd的职责\"><a href=\"#launchd的职责\" class=\"headerlink\" title=\"launchd的职责\"></a>launchd的职责</h2><h3 id=\"运行定时作业\"><a href=\"#运行定时作业\" class=\"headerlink\" title=\"运行定时作业\"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>\n<h3 id=\"提供自举服务\"><a href=\"#提供自举服务\" class=\"headerlink\" title=\"提供自举服务\"></a>提供自举服务<servers bootstrap.h=\"\"></servers></h3><ul>\n<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>\n<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers bootstrap.h=\"\">中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</servers></li>\n</ul>\n<h3 id=\"事物支持\"><a href=\"#事物支持\" class=\"headerlink\" title=\"事物支持\"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>\n<h3 id=\"资源限制和遏制\"><a href=\"#资源限制和遏制\" class=\"headerlink\" title=\"资源限制和遏制\"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>\n<h3 id=\"Autorun模拟和文件系统观察\"><a href=\"#Autorun模拟和文件系统观察\" class=\"headerlink\" title=\"Autorun模拟和文件系统观察\"></a>Autorun模拟和文件系统观察</h3><ul>\n<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>\n<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>\n</ul>\n<h3 id=\"整合了I-O-Kit\"><a href=\"#整合了I-O-Kit\" class=\"headerlink\" title=\"整合了I/O Kit\"></a>整合了I/O Kit</h3><h2 id=\"iOS的launchDeamon\"><a href=\"#iOS的launchDeamon\" class=\"headerlink\" title=\"iOS的launchDeamon\"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\" alt=\"launchDeamon\"></p>\n<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>\n<h3 id=\"lockdownd\"><a href=\"#lockdownd\" class=\"headerlink\" title=\"lockdownd\"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>\n<h3 id=\"SpringBoard\"><a href=\"#SpringBoard\" class=\"headerlink\" title=\"SpringBoard\"></a>SpringBoard</h3><ul>\n<li>创建GUI</li>\n<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>\n<li>SpringBoard包含大量的线程，比如：<ul>\n<li>有Web相关的线程（WebCore和WebThread）</li>\n<li>WiFiManager</li>\n<li>CoreAnimation</li>\n</ul>\n</li>\n<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>\n</ul>\n<h2 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h2><ul>\n<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_barrier</div><div class=\"line\">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message_with_reply</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_object_t</div><div class=\"line\">xpc_connection_send_message_with_reply_sync</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>\n<ul>\n<li>XPC的例子可以参照：苹果官方的<a href=\"https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\" target=\"_blank\" rel=\"external\">SandboxedFetch</a></li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"launchd\"><a href=\"#launchd\" class=\"headerlink\" title=\"launchd\"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>\n<ul>\n<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>\n<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>\n</ul>\n<h2 id=\"launchd的职责\"><a href=\"#launchd的职责\" class=\"headerlink\" title=\"launchd的职责\"></a>launchd的职责</h2><h3 id=\"运行定时作业\"><a href=\"#运行定时作业\" class=\"headerlink\" title=\"运行定时作业\"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>\n<h3 id=\"提供自举服务\"><a href=\"#提供自举服务\" class=\"headerlink\" title=\"提供自举服务\"></a>提供自举服务<servers/bootstrap.h></h3><ul>\n<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>\n<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</li>\n</ul>\n<h3 id=\"事物支持\"><a href=\"#事物支持\" class=\"headerlink\" title=\"事物支持\"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>\n<h3 id=\"资源限制和遏制\"><a href=\"#资源限制和遏制\" class=\"headerlink\" title=\"资源限制和遏制\"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>\n<h3 id=\"Autorun模拟和文件系统观察\"><a href=\"#Autorun模拟和文件系统观察\" class=\"headerlink\" title=\"Autorun模拟和文件系统观察\"></a>Autorun模拟和文件系统观察</h3><ul>\n<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>\n<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>\n</ul>\n<h3 id=\"整合了I-O-Kit\"><a href=\"#整合了I-O-Kit\" class=\"headerlink\" title=\"整合了I/O Kit\"></a>整合了I/O Kit</h3><h2 id=\"iOS的launchDeamon\"><a href=\"#iOS的launchDeamon\" class=\"headerlink\" title=\"iOS的launchDeamon\"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\" alt=\"launchDeamon\"></p>\n<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>\n<h3 id=\"lockdownd\"><a href=\"#lockdownd\" class=\"headerlink\" title=\"lockdownd\"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>\n<h3 id=\"SpringBoard\"><a href=\"#SpringBoard\" class=\"headerlink\" title=\"SpringBoard\"></a>SpringBoard</h3><ul>\n<li>创建GUI</li>\n<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>\n<li>SpringBoard包含大量的线程，比如：<ul>\n<li>有Web相关的线程（WebCore和WebThread）</li>\n<li>WiFiManager</li>\n<li>CoreAnimation</li>\n</ul>\n</li>\n<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>\n</ul>\n<h2 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h2><ul>\n<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_barrier</div><div class=\"line\">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message_with_reply</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_object_t</div><div class=\"line\">xpc_connection_send_message_with_reply_sync</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>\n<ul>\n<li>XPC的例子可以参照：苹果官方的<a href=\"https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\">SandboxedFetch</a></li>\n</ul>\n<hr>\n"},{"title":"高效学习法","date":"2016-10-23T09:26:51.000Z","description":"本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。","_content":"\n\n## 方法来源\n本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。\n\n## 我要学什么\n要学习的主题是什么，比如是摄影，还是iOS开发？\n\n## 筛选出我们想要学习的目标资源\n互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。\n\n## 制定明确的、具体的、无二义性的目标\n请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：\n\n - 目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。\n - 将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。\n\n## 学习任何知识都要先从全局出发\n当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。\n\n## 拆解成小任务\n将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。\n\n## 专注主线知识，不要被分支知识所诱惑\n如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在**遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它**。\n\n## 不只是眼睛读，手还要动\n我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。\n\n\n## 分享\n其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。\n\n## 最后\n这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。\n","source":"_posts/高效学习法.md","raw":"---\ntitle: 高效学习法\ncategories: 方法论\ntags: 学习方法\ndate: 2016-10-23 17:26:51\ndescription: \"本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。\"\n---\n\n\n## 方法来源\n本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。\n\n## 我要学什么\n要学习的主题是什么，比如是摄影，还是iOS开发？\n\n## 筛选出我们想要学习的目标资源\n互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。\n\n## 制定明确的、具体的、无二义性的目标\n请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：\n\n - 目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。\n - 将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。\n\n## 学习任何知识都要先从全局出发\n当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。\n\n## 拆解成小任务\n将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。\n\n## 专注主线知识，不要被分支知识所诱惑\n如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在**遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它**。\n\n## 不只是眼睛读，手还要动\n我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。\n\n\n## 分享\n其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。\n\n## 最后\n这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。\n","slug":"高效学习法","published":1,"updated":"2016-11-15T09:07:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mfw001r0k04033izuyx","content":"<h2 id=\"方法来源\"><a href=\"#方法来源\" class=\"headerlink\" title=\"方法来源\"></a>方法来源</h2><p>本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。</p>\n<h2 id=\"我要学什么\"><a href=\"#我要学什么\" class=\"headerlink\" title=\"我要学什么\"></a>我要学什么</h2><p>要学习的主题是什么，比如是摄影，还是iOS开发？</p>\n<h2 id=\"筛选出我们想要学习的目标资源\"><a href=\"#筛选出我们想要学习的目标资源\" class=\"headerlink\" title=\"筛选出我们想要学习的目标资源\"></a>筛选出我们想要学习的目标资源</h2><p>互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。</p>\n<h2 id=\"制定明确的、具体的、无二义性的目标\"><a href=\"#制定明确的、具体的、无二义性的目标\" class=\"headerlink\" title=\"制定明确的、具体的、无二义性的目标\"></a>制定明确的、具体的、无二义性的目标</h2><p>请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：</p>\n<ul>\n<li>目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。</li>\n<li>将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。</li>\n</ul>\n<h2 id=\"学习任何知识都要先从全局出发\"><a href=\"#学习任何知识都要先从全局出发\" class=\"headerlink\" title=\"学习任何知识都要先从全局出发\"></a>学习任何知识都要先从全局出发</h2><p>当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。</p>\n<h2 id=\"拆解成小任务\"><a href=\"#拆解成小任务\" class=\"headerlink\" title=\"拆解成小任务\"></a>拆解成小任务</h2><p>将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。</p>\n<h2 id=\"专注主线知识，不要被分支知识所诱惑\"><a href=\"#专注主线知识，不要被分支知识所诱惑\" class=\"headerlink\" title=\"专注主线知识，不要被分支知识所诱惑\"></a>专注主线知识，不要被分支知识所诱惑</h2><p>如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在<strong>遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它</strong>。</p>\n<h2 id=\"不只是眼睛读，手还要动\"><a href=\"#不只是眼睛读，手还要动\" class=\"headerlink\" title=\"不只是眼睛读，手还要动\"></a>不只是眼睛读，手还要动</h2><p>我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。</p>\n<h2 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h2><p>其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。</p>\n","excerpt":"","more":"<h2 id=\"方法来源\"><a href=\"#方法来源\" class=\"headerlink\" title=\"方法来源\"></a>方法来源</h2><p>本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。</p>\n<h2 id=\"我要学什么\"><a href=\"#我要学什么\" class=\"headerlink\" title=\"我要学什么\"></a>我要学什么</h2><p>要学习的主题是什么，比如是摄影，还是iOS开发？</p>\n<h2 id=\"筛选出我们想要学习的目标资源\"><a href=\"#筛选出我们想要学习的目标资源\" class=\"headerlink\" title=\"筛选出我们想要学习的目标资源\"></a>筛选出我们想要学习的目标资源</h2><p>互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。</p>\n<h2 id=\"制定明确的、具体的、无二义性的目标\"><a href=\"#制定明确的、具体的、无二义性的目标\" class=\"headerlink\" title=\"制定明确的、具体的、无二义性的目标\"></a>制定明确的、具体的、无二义性的目标</h2><p>请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：</p>\n<ul>\n<li>目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。</li>\n<li>将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。</li>\n</ul>\n<h2 id=\"学习任何知识都要先从全局出发\"><a href=\"#学习任何知识都要先从全局出发\" class=\"headerlink\" title=\"学习任何知识都要先从全局出发\"></a>学习任何知识都要先从全局出发</h2><p>当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。</p>\n<h2 id=\"拆解成小任务\"><a href=\"#拆解成小任务\" class=\"headerlink\" title=\"拆解成小任务\"></a>拆解成小任务</h2><p>将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。</p>\n<h2 id=\"专注主线知识，不要被分支知识所诱惑\"><a href=\"#专注主线知识，不要被分支知识所诱惑\" class=\"headerlink\" title=\"专注主线知识，不要被分支知识所诱惑\"></a>专注主线知识，不要被分支知识所诱惑</h2><p>如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在<strong>遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它</strong>。</p>\n<h2 id=\"不只是眼睛读，手还要动\"><a href=\"#不只是眼睛读，手还要动\" class=\"headerlink\" title=\"不只是眼睛读，手还要动\"></a>不只是眼睛读，手还要动</h2><p>我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。</p>\n<h2 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h2><p>其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。</p>\n"},{"title":"swift 100 tips笔记.md","_content":"## 笔记来源\n来自喵神的[《swifter》][1]的要点记录。\n\n## 要点\n1. 柯里化，即将接受**多个参数**的方法转换成接受**一个参数**的的方法。\n2. Struct `Mutating`关键字，由于Struct是immutable的数据结构，如果想**在方法体中修改局部变量的值**，则需要在func 前面加上`Mutating`关键字。\n3. Protocol方法的`Mutating`关键字，为了**能使Struct、enum能在方法中修改它们的局部变量的值**，多考虑在func 前面加上`Mutating`关键字。`Class`方法的前面不需要加`Mutating`关键字。\n4. \n\n\n---\n[1]: https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&qid=1477880062&sr=8-1&keywords=swifter\n\n","source":"_drafts/swift_100_tips笔记.md","raw":"---\ntitle: swift 100 tips笔记.md\ncategories:\n- Apple Development\n- iOS开发笔记\ntags:\n- swift\n---\n## 笔记来源\n来自喵神的[《swifter》][1]的要点记录。\n\n## 要点\n1. 柯里化，即将接受**多个参数**的方法转换成接受**一个参数**的的方法。\n2. Struct `Mutating`关键字，由于Struct是immutable的数据结构，如果想**在方法体中修改局部变量的值**，则需要在func 前面加上`Mutating`关键字。\n3. Protocol方法的`Mutating`关键字，为了**能使Struct、enum能在方法中修改它们的局部变量的值**，多考虑在func 前面加上`Mutating`关键字。`Class`方法的前面不需要加`Mutating`关键字。\n4. \n\n\n---\n[1]: https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&qid=1477880062&sr=8-1&keywords=swifter\n\n","slug":"swift_100_tips笔记","published":0,"date":"2016-10-31T02:10:35.000Z","updated":"2016-10-31T02:25:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mg1001w0k04ypi16hcm","content":"<h2 id=\"笔记来源\"><a href=\"#笔记来源\" class=\"headerlink\" title=\"笔记来源\"></a>笔记来源</h2><p>来自喵神的<a href=\"https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&amp;qid=1477880062&amp;sr=8-1&amp;keywords=swifter\" target=\"_blank\" rel=\"external\">《swifter》</a>的要点记录。</p>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li>柯里化，即将接受<strong>多个参数</strong>的方法转换成接受<strong>一个参数</strong>的的方法。</li>\n<li>Struct <code>Mutating</code>关键字，由于Struct是immutable的数据结构，如果想<strong>在方法体中修改局部变量的值</strong>，则需要在func 前面加上<code>Mutating</code>关键字。</li>\n<li>Protocol方法的<code>Mutating</code>关键字，为了<strong>能使Struct、enum能在方法中修改它们的局部变量的值</strong>，多考虑在func 前面加上<code>Mutating</code>关键字。<code>Class</code>方法的前面不需要加<code>Mutating</code>关键字。</li>\n<li></li>\n</ol>\n<hr>\n","excerpt":"","more":"<h2 id=\"笔记来源\"><a href=\"#笔记来源\" class=\"headerlink\" title=\"笔记来源\"></a>笔记来源</h2><p>来自喵神的<a href=\"https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&amp;qid=1477880062&amp;sr=8-1&amp;keywords=swifter\">《swifter》</a>的要点记录。</p>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li>柯里化，即将接受<strong>多个参数</strong>的方法转换成接受<strong>一个参数</strong>的的方法。</li>\n<li>Struct <code>Mutating</code>关键字，由于Struct是immutable的数据结构，如果想<strong>在方法体中修改局部变量的值</strong>，则需要在func 前面加上<code>Mutating</code>关键字。</li>\n<li>Protocol方法的<code>Mutating</code>关键字，为了<strong>能使Struct、enum能在方法中修改它们的局部变量的值</strong>，多考虑在func 前面加上<code>Mutating</code>关键字。<code>Class</code>方法的前面不需要加<code>Mutating</code>关键字。</li>\n<li></li>\n</ol>\n<hr>\n"},{"title":"时间管理","_content":"\n习惯的三要素：暗示、惯例、奖励。","source":"_drafts/时间管理.md","raw":"---\ntitle: 时间管理\ncategories:\ntags: 方法论\n---\n\n习惯的三要素：暗示、惯例、奖励。","slug":"时间管理","published":0,"date":"2016-10-21T02:18:10.000Z","updated":"2016-10-21T02:18:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mg5001z0k04skx6awbx","content":"<p>习惯的三要素：暗示、惯例、奖励。</p>\n","excerpt":"","more":"<p>习惯的三要素：暗示、惯例、奖励。</p>\n"},{"title":"编译过程预览","_content":"\n","source":"_drafts/编译过程预览.md","raw":"---\ntitle: 编译过程预览\ncategories: \n- 编译系统\ntags: \n- 编译 \n- 汇编\n---\n\n","slug":"编译过程预览","published":0,"date":"2016-11-08T01:51:30.000Z","updated":"2016-11-08T01:52:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civja2mgc00220k04v890d4sw","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"civja2mcp00010k04vw7p1xh7","category_id":"civja2md300040k04lhltcln7","_id":"civja2mdr000c0k04695s7c9v"},{"post_id":"civja2mdo000b0k04b6w514mk","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mf200140k0477njfp9q"},{"post_id":"civja2mdo000b0k04b6w514mk","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mf600170k04q9l241u5"},{"post_id":"civja2mer000y0k04hxn412hh","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mfe001b0k040ofuwtfp"},{"post_id":"civja2mer000y0k04hxn412hh","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mfk001f0k04a5qxdt83"},{"post_id":"civja2mew00100k04mfl8b71s","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mfn001j0k046enz70uf"},{"post_id":"civja2mew00100k04mfl8b71s","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mft001m0k04lqlrluqk"},{"post_id":"civja2md000030k04tn2vbl0o","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mfw001p0k042e3otv9l"},{"post_id":"civja2md000030k04tn2vbl0o","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mg0001t0k04899zsie0"},{"post_id":"civja2mf000130k04kpvole9u","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mg3001x0k04mt7xsg7z"},{"post_id":"civja2mf000130k04kpvole9u","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mgb00210k04dz0e2w4z"},{"post_id":"civja2mf400160k04aa7wlwvh","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgg00240k04fiuryyru"},{"post_id":"civja2mf400160k04aa7wlwvh","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mgi00270k0414s6ch2f"},{"post_id":"civja2mf700190k04acfe7qta","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgi00280k04cba6tict"},{"post_id":"civja2mf700190k04acfe7qta","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mgk002c0k041bd3xl74"},{"post_id":"civja2mfg001c0k04zebng5ck","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgk002d0k04918jtask"},{"post_id":"civja2mfg001c0k04zebng5ck","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mgm002g0k04kyxmr7k9"},{"post_id":"civja2mdy000g0k04y374v1ri","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgm002i0k04smzk33ve"},{"post_id":"civja2mdy000g0k04y374v1ri","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mgo002l0k04m56tm4do"},{"post_id":"civja2mdb00060k04d1svr98v","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgo002n0k04zr1dbswn"},{"post_id":"civja2mdb00060k04d1svr98v","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mgp002q0k04bp2i0bm2"},{"post_id":"civja2mft001o0k04lgzbwp1i","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgq002s0k04krf37ial"},{"post_id":"civja2mft001o0k04lgzbwp1i","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mgr002u0k04pevaxjrq"},{"post_id":"civja2me1000i0k04aj4tpb7t","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgr002x0k046wj2mqqz"},{"post_id":"civja2me1000i0k04aj4tpb7t","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mgs002z0k0473wv46a6"},{"post_id":"civja2mg1001w0k04ypi16hcm","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgt00310k04xe7xcfxu"},{"post_id":"civja2mg1001w0k04ypi16hcm","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mgt00330k04560qxqb1"},{"post_id":"civja2me6000m0k04dbx0pc1e","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mgu00360k045rlyfoz7"},{"post_id":"civja2me6000m0k04dbx0pc1e","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mgu00380k04zle8rq6i"},{"post_id":"civja2mdf00070k042u8ha6ff","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mh5003b0k04wnp7bgvr"},{"post_id":"civja2mdf00070k042u8ha6ff","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mh6003d0k04cowii121"},{"post_id":"civja2meb000o0k04csycy2am","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mh7003g0k04eslojh7q"},{"post_id":"civja2meb000o0k04csycy2am","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mh7003i0k04devemqc9"},{"post_id":"civja2mef000r0k04zggn7ir7","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mh8003k0k04znbgew63"},{"post_id":"civja2mef000r0k04zggn7ir7","category_id":"civja2mem000u0k04tcbdh92i","_id":"civja2mh9003m0k04wxu6j447"},{"post_id":"civja2mdi00080k04n8ihhe7c","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mha003n0k046q8i1hv4"},{"post_id":"civja2mdi00080k04n8ihhe7c","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mhb003o0k046x3vdeax"},{"post_id":"civja2mek000t0k04g7s5kx2l","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mhb003q0k046jph56uv"},{"post_id":"civja2mek000t0k04g7s5kx2l","category_id":"civja2mgp002o0k04exoi7utc","_id":"civja2mhb003s0k04ydgjf1wv"},{"post_id":"civja2meo000w0k04v495yfnk","category_id":"civja2mdl00090k04q35zny8f","_id":"civja2mhb003t0k049k4leor3"},{"post_id":"civja2meo000w0k04v495yfnk","category_id":"civja2mev000z0k04ighzgdiz","_id":"civja2mhd003u0k04ujum8j3i"},{"post_id":"civja2mds000d0k04f7iax04g","category_id":"civja2mf300150k04yx0blabq","_id":"civja2mhd003v0k04ic3e5sq6"},{"post_id":"civja2mds000d0k04f7iax04g","category_id":"civja2mgs002y0k04ejlsf3ct","_id":"civja2mhd003w0k04pped3gdt"},{"post_id":"civja2mfl001h0k04w7ucqjg8","category_id":"civja2mgt00340k049dd1glih","_id":"civja2mhe003x0k04efe8o74e"},{"post_id":"civja2mfo001k0k04emyl2h7o","category_id":"civja2mgv00390k04r0k4ey0n","_id":"civja2mhe003y0k04yvatpyl4"},{"post_id":"civja2mfw001r0k04033izuyx","category_id":"civja2mgv00390k04r0k4ey0n","_id":"civja2mhe003z0k048w6ylmx4"},{"post_id":"civja2mgc00220k04v890d4sw","category_id":"civja2mh7003j0k04ocia4zrd","_id":"civja2mhe00400k04c3175zn0"}],"PostTag":[{"post_id":"civja2mcp00010k04vw7p1xh7","tag_id":"civja2mda00050k041s02ddke","_id":"civja2me0000h0k04n1tvniwj"},{"post_id":"civja2mcp00010k04vw7p1xh7","tag_id":"civja2mdm000a0k04j3oyc9n9","_id":"civja2me4000j0k04vgp5aad4"},{"post_id":"civja2md000030k04tn2vbl0o","tag_id":"civja2mdv000f0k04ptwyytan","_id":"civja2me9000n0k046azrz36i"},{"post_id":"civja2mdf00070k042u8ha6ff","tag_id":"civja2me5000l0k04rr1tosf3","_id":"civja2mej000s0k04vt92kn1k"},{"post_id":"civja2mdi00080k04n8ihhe7c","tag_id":"civja2me5000l0k04rr1tosf3","_id":"civja2meq000x0k045nuj5ph9"},{"post_id":"civja2mdo000b0k04b6w514mk","tag_id":"civja2men000v0k04il45oi12","_id":"civja2mf000120k04zedc5y0i"},{"post_id":"civja2mds000d0k04f7iax04g","tag_id":"civja2mez00110k04b5psikzm","_id":"civja2mfd001a0k04xt1zirdx"},{"post_id":"civja2mds000d0k04f7iax04g","tag_id":"civja2mdm000a0k04j3oyc9n9","_id":"civja2mfk001e0k04hyb7ewbr"},{"post_id":"civja2mdy000g0k04y374v1ri","tag_id":"civja2me5000l0k04rr1tosf3","_id":"civja2mfn001i0k04h2hivq4b"},{"post_id":"civja2mek000t0k04g7s5kx2l","tag_id":"civja2mfl001g0k04bgn4ob7e","_id":"civja2mfw001q0k04wcr2a7if"},{"post_id":"civja2mek000t0k04g7s5kx2l","tag_id":"civja2mdm000a0k04j3oyc9n9","_id":"civja2mg0001u0k044r338uz3"},{"post_id":"civja2meo000w0k04v495yfnk","tag_id":"civja2mft001n0k043rm1mxtc","_id":"civja2mg4001y0k04zap12heg"},{"post_id":"civja2mew00100k04mfl8b71s","tag_id":"civja2mg0001v0k04dqr5x2z6","_id":"civja2mgg00250k042pjr50cy"},{"post_id":"civja2mf000130k04kpvole9u","tag_id":"civja2mgf00230k04plp4pe4b","_id":"civja2mgk002b0k04mxts3ymb"},{"post_id":"civja2mf400160k04aa7wlwvh","tag_id":"civja2mgj00290k04lk8o2sdj","_id":"civja2mgm002h0k04r5w9oxgw"},{"post_id":"civja2mf700190k04acfe7qta","tag_id":"civja2mgl002e0k047czqs04l","_id":"civja2mgo002m0k04d45pu5wk"},{"post_id":"civja2mfl001h0k04w7ucqjg8","tag_id":"civja2mgm002j0k04jsnidloj","_id":"civja2mgp002r0k04kyvqq8yy"},{"post_id":"civja2mfo001k0k04emyl2h7o","tag_id":"civja2mgp002p0k04jpnzvdm5","_id":"civja2mgr002w0k04degcwmu0"},{"post_id":"civja2mft001o0k04lgzbwp1i","tag_id":"civja2mgr002v0k04mka2n7kd","_id":"civja2mgt00320k04wnfgpo32"},{"post_id":"civja2mfw001r0k04033izuyx","tag_id":"civja2mgp002p0k04jpnzvdm5","_id":"civja2mgu00370k04tyfkal3g"},{"post_id":"civja2mg1001w0k04ypi16hcm","tag_id":"civja2mgu00350k04p7wwz4vv","_id":"civja2mh6003c0k044cgrsziw"},{"post_id":"civja2mg5001z0k04skx6awbx","tag_id":"civja2mgv003a0k040eu5g8qr","_id":"civja2mh7003h0k046atbgc89"},{"post_id":"civja2mgc00220k04v890d4sw","tag_id":"civja2mh6003f0k04no3bff2y","_id":"civja2mhb003p0k04utmt4u5x"},{"post_id":"civja2mgc00220k04v890d4sw","tag_id":"civja2mh8003l0k047slrqfmj","_id":"civja2mhb003r0k04mckq4s2y"}],"Tag":[{"name":"H5","_id":"civja2mda00050k041s02ddke"},{"name":"JS","_id":"civja2mdm000a0k04j3oyc9n9"},{"name":"XNU","_id":"civja2mdv000f0k04ptwyytan"},{"name":"Mach","_id":"civja2me5000l0k04rr1tosf3"},{"name":"事件响应链","_id":"civja2men000v0k04il45oi12"},{"name":"React","_id":"civja2mez00110k04b5psikzm"},{"name":"安全","_id":"civja2mfl001g0k04bgn4ob7e"},{"name":"内核架构","_id":"civja2mft001n0k043rm1mxtc"},{"name":"Cocoapods","_id":"civja2mg0001v0k04dqr5x2z6"},{"name":"文件系统","_id":"civja2mgf00230k04plp4pe4b"},{"name":"内核","_id":"civja2mgj00290k04lk8o2sdj"},{"name":"网络","_id":"civja2mgl002e0k047czqs04l"},{"name":"CoreText","_id":"civja2mgm002j0k04jsnidloj"},{"name":"学习方法","_id":"civja2mgp002p0k04jpnzvdm5"},{"name":"launchd","_id":"civja2mgr002v0k04mka2n7kd"},{"name":"swift","_id":"civja2mgu00350k04p7wwz4vv"},{"name":"方法论","_id":"civja2mgv003a0k040eu5g8qr"},{"name":"编译","_id":"civja2mh6003f0k04no3bff2y"},{"name":"汇编","_id":"civja2mh8003l0k047slrqfmj"}]}}