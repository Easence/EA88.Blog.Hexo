{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/TLS_Record_Struct.png","path":"images/TLS_Record_Struct.png","modified":0,"renderable":0},{"_id":"source/images/cloud_campus.png","path":"images/cloud_campus.png","modified":0,"renderable":0},{"_id":"source/images/moka.png","path":"images/moka.png","modified":0,"renderable":0},{"_id":"source/images/questopia.png","path":"images/questopia.png","modified":0,"renderable":0},{"_id":"source/images/TLS_cer_sample.png","path":"images/TLS_cer_sample.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"source/images/TLS_in_OSI.png","path":"images/TLS_in_OSI.png","modified":0,"renderable":0},{"_id":"source/images/TLS_Cer_auth.png","path":"images/TLS_Cer_auth.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"source/images/TCP_HOL.png","path":"images/TCP_HOL.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/images/shake_hand.png","path":"images/shake_hand.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"source/images/TLS_Handshare_simple.png","path":"images/TLS_Handshare_simple.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/TLS_HandShake.png","path":"images/TLS_HandShake.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1479196756000},{"_id":"themes/next/.DS_Store","hash":"2b957ba69ebecc08b91958f16d6d125de746126e","modified":1483600476000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1479196756000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1479196756000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1479196756000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1479196756000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1479196756000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1479196756000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1479196756000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1479196756000},{"_id":"themes/next/_config.yml","hash":"02ac9bd4d4fb2c0064cd5bf13600a5899e1e1768","modified":1482372105000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1479196756000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1479196756000},{"_id":"source/.DS_Store","hash":"d0c06d4b523512ffceacaffaef4a4b9a12dcc7bd","modified":1482372034000},{"_id":"themes/next/.git/ORIG_HEAD","hash":"776e91b78b954875a8d38297e05b80eab20df4b9","modified":1480602889000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1479196756000},{"_id":"themes/next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1479196756000},{"_id":"themes/next/.git/FETCH_HEAD","hash":"564099277357ec120bdcfec66aa6316948737923","modified":1480602888000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1479196578000},{"_id":"themes/next/.git/index","hash":"0ad166a2cb8c7300a307887bda8b669de8ebbdcd","modified":1480602876000},{"_id":"themes/next/.git/packed-refs","hash":"7ad631fcd1c8e21b38e561b9ff6f43d2e57ef0bd","modified":1479196756000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1479196756000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1479196756000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1479196756000},{"_id":"themes/next/source/.DS_Store","hash":"2e8212642832582571841d931c320b559103bdb5","modified":1482371762000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1479196756000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1479196756000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1479196756000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1479196756000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1479196756000},{"_id":"themes/next/layout/_layout.swig","hash":"7a1e4443c3ba1e08c20e64ddbf0b8255d034dab0","modified":1479196756000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1479196756000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1479196756000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1479196756000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1479196756000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1479196756000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1479196756000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1479196756000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1479196756000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1479196756000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1479196756000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1479196756000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1479196756000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1479196756000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1479196756000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1479196756000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1479196756000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1479196756000},{"_id":"source/_drafts/OpenGL_Conception.md","hash":"fdb8517e7ce904884fd62f91589db9373c44f200","modified":1489630191000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1479196756000},{"_id":"source/_drafts/swift_100_tips笔记.md","hash":"9a44392c1c5e69db863d147b0059ab912ded1d26","modified":1487213910000},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1482465145000},{"_id":"source/_drafts/AsyncDisplayKit笔记.md","hash":"1c1a0b0c687e640d2e8d34a37ce470df17c5d54b","modified":1481782191000},{"_id":"source/_drafts/时间管理.md","hash":"b6209eaef5753a24ff746b05f1dcc2a21b698444","modified":1477016327000},{"_id":"source/_drafts/Mach调度.md","hash":"b5b65197cee315484b3a96a3adfde4bb87e5f782","modified":1479202249000},{"_id":"source/_drafts/编译过程预览.md","hash":"f334a0bb07e6e5f6bdb98ec5573951c2b913ce70","modified":1478569943000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1482910631000},{"_id":"source/_posts/Building xnu for OS X 10.11 El Capitan.md","hash":"95180407f8597ef39ef564865da009b009af6dda","modified":1479202187000},{"_id":"source/_posts/B-Tree_and_HFS+.md","hash":"92549825dbe4c86b79beada125e0b965d3044d3b","modified":1482307778000},{"_id":"source/_posts/H5的体验优化.md","hash":"e1dd5873f923257355cd9a6e4851528bf434bd19","modified":1479202196000},{"_id":"source/_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","hash":"fd1cb890aeb1b4e9f59f59a5d7d654c70683b92b","modified":1479202233000},{"_id":"source/_posts/Mach原语：一起以消息为媒介.md","hash":"49a451100866aeedb9daadc1ab3b40447dd8db47","modified":1479202240000},{"_id":"source/_posts/Mach-O格式文件(用户态下的进程加载).md","hash":"de46ca0fbdc156ba7e930a26d67731ce7dcbe153","modified":1479202261000},{"_id":"source/_posts/React Native笔记.md","hash":"a202866e9d7ab10a6c2801cef4047e51a09378da","modified":1476689066000},{"_id":"source/_posts/TCP-IP-detail.md","hash":"837d500dba118773de358fd17ac41e0817343400","modified":1482371218000},{"_id":"source/about/index.md","hash":"e710d1289286523d5ffcfb35b0c2e280c125ebdb","modified":1482977108000},{"_id":"source/_posts/TheResponderChain.md","hash":"c39c43d6b94a65939f990d7bba7a12c7ac3a3a46","modified":1479193674000},{"_id":"source/_posts/TLS.md","hash":"0e1539f7fe5f9ecea6139c02f551171231b06310","modified":1482465305000},{"_id":"source/_posts/Thrift的二进制数据编解码-以OC为例.md","hash":"f8d1772c09eeaa992c3766e111d4116bd377d47a","modified":1479202277000},{"_id":"source/_posts/iOS引导页的镂空效果.md","hash":"d6114d42f4d9d71693d59f19e7d88d2745e3cdaa","modified":1479202205000},{"_id":"source/_posts/iOS中的MAX-A-B-，需要注意的点.md","hash":"b5d581bd281ad1c19e52e7d40ea8faba21c8dd3c","modified":1476530655000},{"_id":"source/_posts/iOS_APNs.md","hash":"565c159bc28632a7ca255c938f6db420ac0648b7","modified":1482291028000},{"_id":"source/_posts/iOS支持懒加载的PageViewController.md","hash":"46866f6dfdef06443763ce204c6336570a29724e","modified":1479202212000},{"_id":"source/_posts/iOS签名.md","hash":"a80eedec1dec6f34cbd01a9b5fc776d221da5964","modified":1476681114000},{"_id":"source/_posts/创建pod库的步骤.md","hash":"945e342f28e7cec38f5df4a682c7089352c85cca","modified":1476677365000},{"_id":"source/_posts/内核架构.md","hash":"071fc26ff6ee7158908cb64450aa971dcc6a14c4","modified":1479202135000},{"_id":"source/_posts/引导过程：EFI和iBoot.md","hash":"639e472b3f6852b0a16276da119436ac43a679ba","modified":1479202148000},{"_id":"source/_posts/从code7到xcode8都有哪些坑？.md","hash":"76ed5ec972c7dbf7372fb51200e1ba475a565c50","modified":1479193718000},{"_id":"source/_posts/文件系统和虚拟文件系统交换（VFS）.md","hash":"811a48eb64ce54bf4897de4903d485da19404844","modified":1476795919000},{"_id":"source/_posts/由生到死--内核引导和内核崩溃.md","hash":"08de46ed7e3c83743b2f11504a6688e199aced65","modified":1479202158000},{"_id":"source/_posts/简约的iOS音乐播放UI控件.md","hash":"d5cd4d3a4983a423d4e8bb9045f85b3d77781a4f","modified":1479202166000},{"_id":"source/_posts/经典排序算法.md","hash":"328d3a07076c77ffc6a00671d5e9ddd72ef31a51","modified":1486712606000},{"_id":"source/_posts/网络七层协议（结合操作系统来了解）.md","hash":"97772fc037d9daf2671b64c215ae803fe069616a","modified":1482910882000},{"_id":"source/_posts/苹果的文字系统.md","hash":"43dc205554a1e2c2c3fd92868cd1e8fe272ba04b","modified":1479201371000},{"_id":"source/_posts/贯穿始终-launchd.md","hash":"92237464811872f1a9562ae2c1d4e0dab033f8bb","modified":1479202102000},{"_id":"source/_posts/读书笔记之《如何阅读一本书》.md","hash":"ebc04a95b9170720e34dd48911384a6e99634bbf","modified":1479202176000},{"_id":"source/_posts/高效学习法.md","hash":"7b4fa414c7c7ee0738b6c56b6f12b01966ef872c","modified":1479201435000},{"_id":"source/images/TLS_Record_Struct.png","hash":"63af9f949f299c0ab2a4565776c866381afc247d","modified":1482464525000},{"_id":"source/images/cloud_campus.png","hash":"180492259d3e842efdf3dd8ad6436e2f513ee083","modified":1482973270000},{"_id":"source/images/moka.png","hash":"bc7b006612c6727c6427fedb09666277e7762beb","modified":1482973938000},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1482973761000},{"_id":"source/images/questopia.png","hash":"e71ad6598c9ab4ed08c50031eb26c0ed0ccaa748","modified":1482974366000},{"_id":"source/categories/index.md","hash":"6c08bfbf9f2886cb743d160ea4cfb7d49eb93180","modified":1476677263000},{"_id":"source/tags/index.md","hash":"24d4749d12b9eeb9d94b622d1082ffded236272a","modified":1476677252000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1479196578000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1479196578000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1479196578000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1479196578000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1479196578000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1479196578000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1479196578000},{"_id":"themes/next/.git/logs/HEAD","hash":"25bc01340924c4b73a36830ea6f6adb40b828450","modified":1480601458000},{"_id":"source/images/TLS_cer_sample.png","hash":"056ec35559e1e0d8b0a387fa0ca3c1cdd71f4cb2","modified":1482463410000},{"_id":"source/images/avatar.jpg","hash":"36db1779bb7cccbd55d8af4c52db5623815a26f4","modified":1476675371000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1479196756000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1479196756000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1479196756000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1479196756000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1479196756000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1479196756000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1479196756000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1479196756000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1479196756000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1479196756000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1479196756000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1479196756000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1479196756000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1479196756000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1479196756000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1479196756000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"7a3ef28678467c45ee9416b41b943252e8036285","modified":1479196756000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1479196756000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1a43dde8c7bc53891be26b915a172b1f01e6bc26","modified":1479196756000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1479196756000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1479196756000},{"_id":"themes/next/layout/_partials/header.swig","hash":"f3627f51810bc906e4020a3fef61bc3629b63581","modified":1479196756000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1479196756000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1479196756000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1479196756000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1479196756000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1479196756000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1479196756000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1479196756000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1479196756000},{"_id":"themes/next/layout/_macro/post.swig","hash":"f12f108c1f8e91cc55d49805d42c1fd96cdf51a6","modified":1479196756000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1479196756000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1479196756000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b8aaa008aafe4c6e325f7513719e1c251430883e","modified":1479196756000},{"_id":"source/images/TLS_in_OSI.png","hash":"d678818db3ef20fcb08839af13715a387cd79d7d","modified":1482459020000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479196756000},{"_id":"themes/next/.git/objects/1e/b53ecd31047d73027f22e7a2c345b925c911dc","hash":"27d43a2dfb7eb5f0c95f88e0b89246faf7b2e543","modified":1479199064000},{"_id":"themes/next/.git/objects/24/6932a69effd7df0afa78d6a53759864aac6f46","hash":"00a2e388bd7388f619bdf3971782ff41984dfd31","modified":1480601457000},{"_id":"themes/next/.git/objects/43/c060e63b216c0b5f320169ffc212840850a006","hash":"d1bbcb8324fb77ff35731c7534eb725f9b0770b5","modified":1479199064000},{"_id":"themes/next/.git/objects/3e/be8314ef745baec2dc7190230a70a6d0aa7256","hash":"a83c2839bce43f36fc87b4f0c986c3e5e5611b7f","modified":1480601457000},{"_id":"themes/next/.git/objects/45/ec67b62c7eb2ac736b710332c4f31f95bf5041","hash":"5a5e314d5b28933c893b5c712eae64a2f13ce816","modified":1479199064000},{"_id":"themes/next/.git/objects/54/ff1d7576540fb9d1c77229f216df993da9ebf7","hash":"b7e9978df43fefb700a7b1592aea1215ee0268ce","modified":1479199064000},{"_id":"themes/next/.git/objects/6a/1a156140fa9da74c7c462dbcb9143744a5628b","hash":"e3bbc869a3f0c2c90f58a5defc3ce02108b721e9","modified":1480601457000},{"_id":"themes/next/.git/objects/50/dd6a5b8952b1d1ca6883bb461e99f744604637","hash":"9004ed2ab9a0735c07b1fc4c11a62add709670f8","modified":1479199064000},{"_id":"themes/next/.git/objects/b4/55b9ae73cfe3aeda070f447861982bbb89283c","hash":"c771a84a14f82455f26eb37b235329b4c75adc2d","modified":1480601457000},{"_id":"themes/next/.git/objects/78/f6a6e1bee87a98e9c4df8474385a39403037cd","hash":"cd22d30fea55f48c1d92c6698439820bbf4a684b","modified":1480601457000},{"_id":"themes/next/.git/objects/7d/26849a2097ef47d3b3c1212bc9c4f9deb3438a","hash":"fab1dfcfa4bb6a567e2f456c2e2ae49a1c25fc6d","modified":1479199064000},{"_id":"themes/next/.git/objects/e8/2a9302e411e13fec82e581d50ccb84f0356d87","hash":"dddbee2ec57e3e6505342459dbd78e9f9292cbf3","modified":1480601457000},{"_id":"themes/next/.git/objects/ab/a53d233d1caaf8cb7eb8faa875d077d6474e14","hash":"e6ceca52d1d3ed907707b1ee6f19af0dd85b15ae","modified":1480601457000},{"_id":"themes/next/.git/objects/fd/3e86b3b1b8b1e6136e6887178dc1ae8aa7061c","hash":"7a8e3bc67eadd84dd998831de7854ef8467d30d0","modified":1480601457000},{"_id":"themes/next/.git/objects/f8/4f41f7450a75f271f8f43ef0f31e4c11c011cc","hash":"88e6de6afb581770b1a91c74e34455b9420deaff","modified":1480601457000},{"_id":"themes/next/.git/refs/heads/master","hash":"776e91b78b954875a8d38297e05b80eab20df4b9","modified":1480601458000},{"_id":"source/images/TLS_Cer_auth.png","hash":"9b43d0aa249be93b844630fcbb6b333990ce9d9a","modified":1482463458000},{"_id":"themes/next/.git/refs/tags/v5.1.0","hash":"cabf39f34bb81548f82c93481989ec34274873a1","modified":1480601458000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1479196756000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c5b28519b446c2af1e8754a6ae4d766823e6b348","modified":1479199064000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3f0d6aa424f434e82ea507f740eeff110f996269","modified":1479196756000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1479196756000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1479196756000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1479196756000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1479196756000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1479196756000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1479196756000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1479196756000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1479196756000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1479196756000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1479196756000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1479196756000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1479196756000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1479196756000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1479196756000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1479196756000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1479196756000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1479196756000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1479196756000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1479196756000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1479196756000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"82a2ac14d4200480a36bf10abcc3cc554ad744d6","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1479196756000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1479196756000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1479196756000},{"_id":"source/images/TCP_HOL.png","hash":"20de62b908a25836eff6b2dfdc7f20e2b72612da","modified":1482329643000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1479196756000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"25bc01340924c4b73a36830ea6f6adb40b828450","modified":1480601458000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1479196756000},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"776e91b78b954875a8d38297e05b80eab20df4b9","modified":1480601458000},{"_id":"source/images/shake_hand.png","hash":"4531d58948a94deab672dccb40dfa14d655e36d6","modified":1482307579000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1479196756000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1479196756000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1480601458000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1479196756000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1479196756000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1479196756000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1479196756000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1479196756000},{"_id":"themes/next/.git/objects/pack/pack-2d45224840110dc56fda8ece871300ad228db9e7.idx","hash":"89d97b90daa231249711a5269fb2e06c8b8499aa","modified":1479196755000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1479196756000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1479196756000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1479196756000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"f043b2ebf4717652c9a95cae513d9abc75cb21a0","modified":1479196756000},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"f549603076b05cbd30c643c70984fd904c235c20","modified":1480601458000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"5357db10656b260f8b332c67bb06e486bc64a4ad","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1479196756000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"5433b6bc9d8f0c4685e760b326445ac51245b0a8","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1479196756000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1479196756000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1479196756000},{"_id":"source/images/TLS_Handshare_simple.png","hash":"61090b5997b90b2b273375e3220f0ae0d3e72f42","modified":1482401928000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1479196756000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1479196756000},{"_id":"source/images/TLS_HandShake.png","hash":"55d852c318e9c72be432160a2714fe1e7c92cb01","modified":1482401741000},{"_id":"themes/next/.git/objects/pack/pack-2d45224840110dc56fda8ece871300ad228db9e7.pack","hash":"45318f9038e59f721a9dba3087f3991e71fc0808","modified":1479196755000}],"Category":[{"name":"OpenGL","_id":"cj0brth3g0004givb5una2gxu"},{"name":"Apple Development","_id":"cj0brth3n000agivbusfwnolu"},{"name":"编译系统","_id":"cj0brth3w000qgivbiv1fi9t5"},{"name":"iOS开发笔记","parent":"cj0brth3n000agivbusfwnolu","_id":"cj0brth41000vgivbr3bwh4x2"},{"name":"深入解析Mac OS X && iOS操作系统笔记","parent":"cj0brth3n000agivbusfwnolu","_id":"cj0brth450011givbueqt41zp"},{"name":"Web","_id":"cj0brth4e001mgivbbar1gbki"},{"name":"JS","_id":"cj0brth4s002lgivbjxtmpx85"},{"name":"Web性能调优","_id":"cj0brth4x002sgivb3v8bizjo"},{"name":"安全","parent":"cj0brth3n000agivbusfwnolu","_id":"cj0brth520034givbtc75umc6"},{"name":"算法","_id":"cj0brth530039givbqa4hmv94"},{"name":"iOS开发笔记","_id":"cj0brth54003egivbgzda0zi8"},{"name":"React Native","parent":"cj0brth4s002lgivbjxtmpx85","_id":"cj0brth55003igivb6cbuftxu"},{"name":"方法论","_id":"cj0brth56003ogivb7qc85rb6"}],"Data":[],"Page":[{"title":"关于我","date":"2016-12-21T04:04:17.000Z","type":"about","_content":"\n## 个人信息\n\n- 姓名：**EA.Huang**\n- 职业：iOS开发者，目前Html5也有所涉猎。\n- Github：[https://github.com/easence](https://github.com/easence)\n- Email：yiyunhzy@163.com\n- 工龄：2011年 - 现在\n- 居住地：深圳\n\n## 参与项目\n\n### 云校园\n\n![云校园](../images/cloud_campus.png)\n\n[云校园][1]是一个中小学家校共育平台，搭建起老师与家长沟通的桥梁，让家校沟通更便捷，做老师的好助手；运用本地化家长社区推荐海量教育资讯，让家庭教育更信息化，做家长的好帮手。关爱孩子，从云校园开始。\n \n#### 主要功能：\n**校务管理**：高效实现家校互通，学校领导、老师轻松发布，家长、学生随时接收学校讯息。 \n\n**家校社区**：资讯—为您提供成长教育内容，帮助孩子走更少的弯路；班级圈—校园互动空间，记录孩子成长精彩瞬间；有问必答—家庭教育难题，专家团队为您在线解答；活动墙—不定期更新评选活动，给孩子更多展现自我的机会！\n\n**学习中心**：根据学生的不同学年、学习能力、兴趣，为学生定制化提供精品线上课程及优质教学资源，真正实现因材施教。\n\n### Questopia\n\n![Questopia](../images/questopia.png)\n\n[Questopia][2] is a top social quiz game which’ll help you find your best Facebook friend! \nTest your Facebook friends’ knowledge about yourself and find the answer! \n \nHow well do your Facebook friends know you and how much do you know about your friends? \nFind out as you answer questions about yourself and guess your friends' answers. \n \nMake Questopia a wonderful place! Earn gold bricks to build a thriving city. Surprise your friends by giving them decorations for their cities like trees, lights and trash cans. The more you know, the more your city will grow! \n \nHow to Play \n\n1. Answer 4 questions about yourself \n2. Answer 4 questions about a friend \n3. Earn gold bricks to buy decorations for your city \n4. Unlock new areas to expand Questopia \n \n### 摩卡时光\n![摩卡时光](../images/moka.png)\n\n[摩卡时光][3]首创以时光轴管理手机图片，快速管理手机图片；三十多种摩卡特色滤镜，让图片更完美；强大的分享功能，一键分享到多平台，新推摩卡时光社区，摩卡生活不再孤单 \n摩卡一下，生活可以如此不同。 \n\n#### 特色功能 \n\n- **摩卡相机**：所拍即所得，多种摩卡滤镜让你的图片更精彩； \n- **时光相册**：以时光轴管理方式管理图片，串联美好生活。 \n- **时光广场**：独乐乐，不如众乐乐，摩卡生活不再孤单。 \n- **一键分享**：强大的分享功能，支持各种社交平台一键分享。 \n- **有声日记**：用声音和图片写日记，体验不一样的生活 \n- **摩卡眼缘**：与爱有关，测试你和TA命中注定的缘分 \n- **素材中心**：多种滤镜，边框，潘多拉素材下载 \n\n摩卡时光收费版，更多滤镜效果：中国画、卡通画、铅笔淡彩、素描、粗布画。 \n\n### 其他参与开发的产品\nMTK版本《悠米音乐播放器》、《Task Labels》、《LoloFurs》、在校期间开发过Android版本《泰康人寿移动端》。\n\n## 擅长语言\nObjective-C、Swift、JavaScript。\n\n\n[1]: https://itunes.apple.com/cn/app/yun-xiao-yuan-zai-xian-jiao/id962615292?l=en&mt=8\n[2]: https://itunes.apple.com/cn/app/questopia-trivia-game-about/id731738635?l=en&mt=8\n[3]: https://itunes.apple.com/cn/app/mo-ka-shi-guang-mian-fei-ban/id560481751?l=en&mt=8\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2016-12-21 12:04:17\ntype: \"about\"\n---\n\n## 个人信息\n\n- 姓名：**EA.Huang**\n- 职业：iOS开发者，目前Html5也有所涉猎。\n- Github：[https://github.com/easence](https://github.com/easence)\n- Email：yiyunhzy@163.com\n- 工龄：2011年 - 现在\n- 居住地：深圳\n\n## 参与项目\n\n### 云校园\n\n![云校园](../images/cloud_campus.png)\n\n[云校园][1]是一个中小学家校共育平台，搭建起老师与家长沟通的桥梁，让家校沟通更便捷，做老师的好助手；运用本地化家长社区推荐海量教育资讯，让家庭教育更信息化，做家长的好帮手。关爱孩子，从云校园开始。\n \n#### 主要功能：\n**校务管理**：高效实现家校互通，学校领导、老师轻松发布，家长、学生随时接收学校讯息。 \n\n**家校社区**：资讯—为您提供成长教育内容，帮助孩子走更少的弯路；班级圈—校园互动空间，记录孩子成长精彩瞬间；有问必答—家庭教育难题，专家团队为您在线解答；活动墙—不定期更新评选活动，给孩子更多展现自我的机会！\n\n**学习中心**：根据学生的不同学年、学习能力、兴趣，为学生定制化提供精品线上课程及优质教学资源，真正实现因材施教。\n\n### Questopia\n\n![Questopia](../images/questopia.png)\n\n[Questopia][2] is a top social quiz game which’ll help you find your best Facebook friend! \nTest your Facebook friends’ knowledge about yourself and find the answer! \n \nHow well do your Facebook friends know you and how much do you know about your friends? \nFind out as you answer questions about yourself and guess your friends' answers. \n \nMake Questopia a wonderful place! Earn gold bricks to build a thriving city. Surprise your friends by giving them decorations for their cities like trees, lights and trash cans. The more you know, the more your city will grow! \n \nHow to Play \n\n1. Answer 4 questions about yourself \n2. Answer 4 questions about a friend \n3. Earn gold bricks to buy decorations for your city \n4. Unlock new areas to expand Questopia \n \n### 摩卡时光\n![摩卡时光](../images/moka.png)\n\n[摩卡时光][3]首创以时光轴管理手机图片，快速管理手机图片；三十多种摩卡特色滤镜，让图片更完美；强大的分享功能，一键分享到多平台，新推摩卡时光社区，摩卡生活不再孤单 \n摩卡一下，生活可以如此不同。 \n\n#### 特色功能 \n\n- **摩卡相机**：所拍即所得，多种摩卡滤镜让你的图片更精彩； \n- **时光相册**：以时光轴管理方式管理图片，串联美好生活。 \n- **时光广场**：独乐乐，不如众乐乐，摩卡生活不再孤单。 \n- **一键分享**：强大的分享功能，支持各种社交平台一键分享。 \n- **有声日记**：用声音和图片写日记，体验不一样的生活 \n- **摩卡眼缘**：与爱有关，测试你和TA命中注定的缘分 \n- **素材中心**：多种滤镜，边框，潘多拉素材下载 \n\n摩卡时光收费版，更多滤镜效果：中国画、卡通画、铅笔淡彩、素描、粗布画。 \n\n### 其他参与开发的产品\nMTK版本《悠米音乐播放器》、《Task Labels》、《LoloFurs》、在校期间开发过Android版本《泰康人寿移动端》。\n\n## 擅长语言\nObjective-C、Swift、JavaScript。\n\n\n[1]: https://itunes.apple.com/cn/app/yun-xiao-yuan-zai-xian-jiao/id962615292?l=en&mt=8\n[2]: https://itunes.apple.com/cn/app/questopia-trivia-game-about/id731738635?l=en&mt=8\n[3]: https://itunes.apple.com/cn/app/mo-ka-shi-guang-mian-fei-ban/id560481751?l=en&mt=8\n\n","updated":"2016-12-29T02:05:08.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj0brth3c0001givbg0ajxx51","content":"<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>姓名：<strong>EA.Huang</strong></li>\n<li>职业：iOS开发者，目前Html5也有所涉猎。</li>\n<li>Github：<a href=\"https://github.com/easence\">https://github.com/easence</a></li>\n<li>Email：yiyunhzy@163.com</li>\n<li>工龄：2011年 - 现在</li>\n<li>居住地：深圳</li>\n</ul>\n<h2 id=\"参与项目\"><a href=\"#参与项目\" class=\"headerlink\" title=\"参与项目\"></a>参与项目</h2><h3 id=\"云校园\"><a href=\"#云校园\" class=\"headerlink\" title=\"云校园\"></a>云校园</h3><p><img src=\"../images/cloud_campus.png\" alt=\"云校园\"></p>\n<p><a href=\"https://itunes.apple.com/cn/app/yun-xiao-yuan-zai-xian-jiao/id962615292?l=en&amp;mt=8\" target=\"_blank\" rel=\"external\">云校园</a>是一个中小学家校共育平台，搭建起老师与家长沟通的桥梁，让家校沟通更便捷，做老师的好助手；运用本地化家长社区推荐海量教育资讯，让家庭教育更信息化，做家长的好帮手。关爱孩子，从云校园开始。</p>\n<h4 id=\"主要功能：\"><a href=\"#主要功能：\" class=\"headerlink\" title=\"主要功能：\"></a>主要功能：</h4><p><strong>校务管理</strong>：高效实现家校互通，学校领导、老师轻松发布，家长、学生随时接收学校讯息。 </p>\n<p><strong>家校社区</strong>：资讯—为您提供成长教育内容，帮助孩子走更少的弯路；班级圈—校园互动空间，记录孩子成长精彩瞬间；有问必答—家庭教育难题，专家团队为您在线解答；活动墙—不定期更新评选活动，给孩子更多展现自我的机会！</p>\n<p><strong>学习中心</strong>：根据学生的不同学年、学习能力、兴趣，为学生定制化提供精品线上课程及优质教学资源，真正实现因材施教。</p>\n<h3 id=\"Questopia\"><a href=\"#Questopia\" class=\"headerlink\" title=\"Questopia\"></a>Questopia</h3><p><img src=\"../images/questopia.png\" alt=\"Questopia\"></p>\n<p><a href=\"https://itunes.apple.com/cn/app/questopia-trivia-game-about/id731738635?l=en&amp;mt=8\" target=\"_blank\" rel=\"external\">Questopia</a> is a top social quiz game which’ll help you find your best Facebook friend!<br>Test your Facebook friends’ knowledge about yourself and find the answer! </p>\n<p>How well do your Facebook friends know you and how much do you know about your friends?<br>Find out as you answer questions about yourself and guess your friends’ answers. </p>\n<p>Make Questopia a wonderful place! Earn gold bricks to build a thriving city. Surprise your friends by giving them decorations for their cities like trees, lights and trash cans. The more you know, the more your city will grow! </p>\n<p>How to Play </p>\n<ol>\n<li>Answer 4 questions about yourself </li>\n<li>Answer 4 questions about a friend </li>\n<li>Earn gold bricks to buy decorations for your city </li>\n<li>Unlock new areas to expand Questopia </li>\n</ol>\n<h3 id=\"摩卡时光\"><a href=\"#摩卡时光\" class=\"headerlink\" title=\"摩卡时光\"></a>摩卡时光</h3><p><img src=\"../images/moka.png\" alt=\"摩卡时光\"></p>\n<p><a href=\"https://itunes.apple.com/cn/app/mo-ka-shi-guang-mian-fei-ban/id560481751?l=en&amp;mt=8\" target=\"_blank\" rel=\"external\">摩卡时光</a>首创以时光轴管理手机图片，快速管理手机图片；三十多种摩卡特色滤镜，让图片更完美；强大的分享功能，一键分享到多平台，新推摩卡时光社区，摩卡生活不再孤单<br>摩卡一下，生活可以如此不同。 </p>\n<h4 id=\"特色功能\"><a href=\"#特色功能\" class=\"headerlink\" title=\"特色功能\"></a>特色功能</h4><ul>\n<li><strong>摩卡相机</strong>：所拍即所得，多种摩卡滤镜让你的图片更精彩； </li>\n<li><strong>时光相册</strong>：以时光轴管理方式管理图片，串联美好生活。 </li>\n<li><strong>时光广场</strong>：独乐乐，不如众乐乐，摩卡生活不再孤单。 </li>\n<li><strong>一键分享</strong>：强大的分享功能，支持各种社交平台一键分享。 </li>\n<li><strong>有声日记</strong>：用声音和图片写日记，体验不一样的生活 </li>\n<li><strong>摩卡眼缘</strong>：与爱有关，测试你和TA命中注定的缘分 </li>\n<li><strong>素材中心</strong>：多种滤镜，边框，潘多拉素材下载 </li>\n</ul>\n<p>摩卡时光收费版，更多滤镜效果：中国画、卡通画、铅笔淡彩、素描、粗布画。 </p>\n<h3 id=\"其他参与开发的产品\"><a href=\"#其他参与开发的产品\" class=\"headerlink\" title=\"其他参与开发的产品\"></a>其他参与开发的产品</h3><p>MTK版本《悠米音乐播放器》、《Task Labels》、《LoloFurs》、在校期间开发过Android版本《泰康人寿移动端》。</p>\n<h2 id=\"擅长语言\"><a href=\"#擅长语言\" class=\"headerlink\" title=\"擅长语言\"></a>擅长语言</h2><p>Objective-C、Swift、JavaScript。</p>\n","excerpt":"","more":"<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>姓名：<strong>EA.Huang</strong></li>\n<li>职业：iOS开发者，目前Html5也有所涉猎。</li>\n<li>Github：<a href=\"https://github.com/easence\">https://github.com/easence</a></li>\n<li>Email：yiyunhzy@163.com</li>\n<li>工龄：2011年 - 现在</li>\n<li>居住地：深圳</li>\n</ul>\n<h2 id=\"参与项目\"><a href=\"#参与项目\" class=\"headerlink\" title=\"参与项目\"></a>参与项目</h2><h3 id=\"云校园\"><a href=\"#云校园\" class=\"headerlink\" title=\"云校园\"></a>云校园</h3><p><img src=\"../images/cloud_campus.png\" alt=\"云校园\"></p>\n<p><a href=\"https://itunes.apple.com/cn/app/yun-xiao-yuan-zai-xian-jiao/id962615292?l=en&amp;mt=8\">云校园</a>是一个中小学家校共育平台，搭建起老师与家长沟通的桥梁，让家校沟通更便捷，做老师的好助手；运用本地化家长社区推荐海量教育资讯，让家庭教育更信息化，做家长的好帮手。关爱孩子，从云校园开始。</p>\n<h4 id=\"主要功能：\"><a href=\"#主要功能：\" class=\"headerlink\" title=\"主要功能：\"></a>主要功能：</h4><p><strong>校务管理</strong>：高效实现家校互通，学校领导、老师轻松发布，家长、学生随时接收学校讯息。 </p>\n<p><strong>家校社区</strong>：资讯—为您提供成长教育内容，帮助孩子走更少的弯路；班级圈—校园互动空间，记录孩子成长精彩瞬间；有问必答—家庭教育难题，专家团队为您在线解答；活动墙—不定期更新评选活动，给孩子更多展现自我的机会！</p>\n<p><strong>学习中心</strong>：根据学生的不同学年、学习能力、兴趣，为学生定制化提供精品线上课程及优质教学资源，真正实现因材施教。</p>\n<h3 id=\"Questopia\"><a href=\"#Questopia\" class=\"headerlink\" title=\"Questopia\"></a>Questopia</h3><p><img src=\"../images/questopia.png\" alt=\"Questopia\"></p>\n<p><a href=\"https://itunes.apple.com/cn/app/questopia-trivia-game-about/id731738635?l=en&amp;mt=8\">Questopia</a> is a top social quiz game which’ll help you find your best Facebook friend!<br>Test your Facebook friends’ knowledge about yourself and find the answer! </p>\n<p>How well do your Facebook friends know you and how much do you know about your friends?<br>Find out as you answer questions about yourself and guess your friends’ answers. </p>\n<p>Make Questopia a wonderful place! Earn gold bricks to build a thriving city. Surprise your friends by giving them decorations for their cities like trees, lights and trash cans. The more you know, the more your city will grow! </p>\n<p>How to Play </p>\n<ol>\n<li>Answer 4 questions about yourself </li>\n<li>Answer 4 questions about a friend </li>\n<li>Earn gold bricks to buy decorations for your city </li>\n<li>Unlock new areas to expand Questopia </li>\n</ol>\n<h3 id=\"摩卡时光\"><a href=\"#摩卡时光\" class=\"headerlink\" title=\"摩卡时光\"></a>摩卡时光</h3><p><img src=\"../images/moka.png\" alt=\"摩卡时光\"></p>\n<p><a href=\"https://itunes.apple.com/cn/app/mo-ka-shi-guang-mian-fei-ban/id560481751?l=en&amp;mt=8\">摩卡时光</a>首创以时光轴管理手机图片，快速管理手机图片；三十多种摩卡特色滤镜，让图片更完美；强大的分享功能，一键分享到多平台，新推摩卡时光社区，摩卡生活不再孤单<br>摩卡一下，生活可以如此不同。 </p>\n<h4 id=\"特色功能\"><a href=\"#特色功能\" class=\"headerlink\" title=\"特色功能\"></a>特色功能</h4><ul>\n<li><strong>摩卡相机</strong>：所拍即所得，多种摩卡滤镜让你的图片更精彩； </li>\n<li><strong>时光相册</strong>：以时光轴管理方式管理图片，串联美好生活。 </li>\n<li><strong>时光广场</strong>：独乐乐，不如众乐乐，摩卡生活不再孤单。 </li>\n<li><strong>一键分享</strong>：强大的分享功能，支持各种社交平台一键分享。 </li>\n<li><strong>有声日记</strong>：用声音和图片写日记，体验不一样的生活 </li>\n<li><strong>摩卡眼缘</strong>：与爱有关，测试你和TA命中注定的缘分 </li>\n<li><strong>素材中心</strong>：多种滤镜，边框，潘多拉素材下载 </li>\n</ul>\n<p>摩卡时光收费版，更多滤镜效果：中国画、卡通画、铅笔淡彩、素描、粗布画。 </p>\n<h3 id=\"其他参与开发的产品\"><a href=\"#其他参与开发的产品\" class=\"headerlink\" title=\"其他参与开发的产品\"></a>其他参与开发的产品</h3><p>MTK版本《悠米音乐播放器》、《Task Labels》、《LoloFurs》、在校期间开发过Android版本《泰康人寿移动端》。</p>\n<h2 id=\"擅长语言\"><a href=\"#擅长语言\" class=\"headerlink\" title=\"擅长语言\"></a>擅长语言</h2><p>Objective-C、Swift、JavaScript。</p>\n"},{"title":"categories","date":"2016-10-17T04:04:17.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-10-17 12:04:17\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-10-17T04:07:43.000Z","path":"categories/index.html","layout":"page","_id":"cj0brth3f0003givb1glpw4sx","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-10-17T04:04:24.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-10-17 12:04:24\ntype: \"tags\"\ncomments: false\n---\n","updated":"2016-10-17T04:07:32.000Z","path":"tags/index.html","layout":"page","_id":"cj0brth3i0007givb2l3g3g31","content":"","excerpt":"","more":""}],"Post":[{"title":"OpenGL概念篇","_content":"# 基础概念\n### 图元\n### 顶点\n### 片段\n### 管线\n### 着色器\n- 顶点（vertex）着色器\n- 片段（fragment）着色器\n- 几何着色器\n- GLSL语言\n- 属性\n- uniform\n- 纹理\n\n### 光栅化\n\n\n","source":"_drafts/OpenGL_Conception.md","raw":"---\ntitle: OpenGL概念篇\ncategories: \n- OpenGL\ntags: \n- OpenGL\n\n---\n# 基础概念\n### 图元\n### 顶点\n### 片段\n### 管线\n### 着色器\n- 顶点（vertex）着色器\n- 片段（fragment）着色器\n- 几何着色器\n- GLSL语言\n- 属性\n- uniform\n- 纹理\n\n### 光栅化\n\n\n","slug":"OpenGL_Conception","published":0,"date":"2016-11-08T01:52:23.000Z","updated":"2017-03-16T02:09:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth380000givbxfz1bo6z","content":"<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h3 id=\"图元\"><a href=\"#图元\" class=\"headerlink\" title=\"图元\"></a>图元</h3><h3 id=\"顶点\"><a href=\"#顶点\" class=\"headerlink\" title=\"顶点\"></a>顶点</h3><h3 id=\"片段\"><a href=\"#片段\" class=\"headerlink\" title=\"片段\"></a>片段</h3><h3 id=\"管线\"><a href=\"#管线\" class=\"headerlink\" title=\"管线\"></a>管线</h3><h3 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h3><ul>\n<li>顶点（vertex）着色器</li>\n<li>片段（fragment）着色器</li>\n<li>几何着色器</li>\n<li>GLSL语言</li>\n<li>属性</li>\n<li>uniform</li>\n<li>纹理</li>\n</ul>\n<h3 id=\"光栅化\"><a href=\"#光栅化\" class=\"headerlink\" title=\"光栅化\"></a>光栅化</h3>","excerpt":"","more":"<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h3 id=\"图元\"><a href=\"#图元\" class=\"headerlink\" title=\"图元\"></a>图元</h3><h3 id=\"顶点\"><a href=\"#顶点\" class=\"headerlink\" title=\"顶点\"></a>顶点</h3><h3 id=\"片段\"><a href=\"#片段\" class=\"headerlink\" title=\"片段\"></a>片段</h3><h3 id=\"管线\"><a href=\"#管线\" class=\"headerlink\" title=\"管线\"></a>管线</h3><h3 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h3><ul>\n<li>顶点（vertex）着色器</li>\n<li>片段（fragment）着色器</li>\n<li>几何着色器</li>\n<li>GLSL语言</li>\n<li>属性</li>\n<li>uniform</li>\n<li>纹理</li>\n</ul>\n<h3 id=\"光栅化\"><a href=\"#光栅化\" class=\"headerlink\" title=\"光栅化\"></a>光栅化</h3>"},{"title":"swift 100 tips笔记.md","_content":"## 笔记来源\n来自喵神的[《swifter》][1]的要点记录。\n\n## 要点\n1. 柯里化，即将接受**多个参数**的方法转换成接受**一个参数**的的方法。\n2. Struct `Mutating`关键字，由于Struct是immutable的数据结构，如果想**在方法体中修改局部变量的值**，则需要在func 前面加上`Mutating`关键字。\n3. Protocol方法的`Mutating`关键字，为了**能使Struct、enum能在方法中修改它们的局部变量的值**，多考虑在func 前面加上`Mutating`关键字。`Class`方法的前面不需要加`Mutating`关键字。\n4. 传入的闭包，为了避免引用循环，可以在参数列表前加上[weak self, weak obj]这样的标注。\n5. 当作为参数的闭包，在这个函数执行完之后，依然还会被其他地方使用，可以使用`@escaping`关键字修饰这个闭包参数。例如：在网络请求中，传输的结果处理闭包，往往是异步调用的，因此应当使用`@escaping`修饰传入的闭包。\n\n\n---\n[1]: https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&qid=1477880062&sr=8-1&keywords=swifter\n\n","source":"_drafts/swift_100_tips笔记.md","raw":"---\ntitle: swift 100 tips笔记.md\ncategories:\n- Apple Development\n- iOS开发笔记\ntags:\n- swift\n---\n## 笔记来源\n来自喵神的[《swifter》][1]的要点记录。\n\n## 要点\n1. 柯里化，即将接受**多个参数**的方法转换成接受**一个参数**的的方法。\n2. Struct `Mutating`关键字，由于Struct是immutable的数据结构，如果想**在方法体中修改局部变量的值**，则需要在func 前面加上`Mutating`关键字。\n3. Protocol方法的`Mutating`关键字，为了**能使Struct、enum能在方法中修改它们的局部变量的值**，多考虑在func 前面加上`Mutating`关键字。`Class`方法的前面不需要加`Mutating`关键字。\n4. 传入的闭包，为了避免引用循环，可以在参数列表前加上[weak self, weak obj]这样的标注。\n5. 当作为参数的闭包，在这个函数执行完之后，依然还会被其他地方使用，可以使用`@escaping`关键字修饰这个闭包参数。例如：在网络请求中，传输的结果处理闭包，往往是异步调用的，因此应当使用`@escaping`修饰传入的闭包。\n\n\n---\n[1]: https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&qid=1477880062&sr=8-1&keywords=swifter\n\n","slug":"swift_100_tips笔记","published":0,"date":"2017-02-16T02:58:30.000Z","updated":"2017-02-16T02:58:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3e0002givbpsvqatl1","content":"<h2 id=\"笔记来源\"><a href=\"#笔记来源\" class=\"headerlink\" title=\"笔记来源\"></a>笔记来源</h2><p>来自喵神的<a href=\"https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&amp;qid=1477880062&amp;sr=8-1&amp;keywords=swifter\" target=\"_blank\" rel=\"external\">《swifter》</a>的要点记录。</p>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li>柯里化，即将接受<strong>多个参数</strong>的方法转换成接受<strong>一个参数</strong>的的方法。</li>\n<li>Struct <code>Mutating</code>关键字，由于Struct是immutable的数据结构，如果想<strong>在方法体中修改局部变量的值</strong>，则需要在func 前面加上<code>Mutating</code>关键字。</li>\n<li>Protocol方法的<code>Mutating</code>关键字，为了<strong>能使Struct、enum能在方法中修改它们的局部变量的值</strong>，多考虑在func 前面加上<code>Mutating</code>关键字。<code>Class</code>方法的前面不需要加<code>Mutating</code>关键字。</li>\n<li>传入的闭包，为了避免引用循环，可以在参数列表前加上[weak self, weak obj]这样的标注。</li>\n<li>当作为参数的闭包，在这个函数执行完之后，依然还会被其他地方使用，可以使用<code>@escaping</code>关键字修饰这个闭包参数。例如：在网络请求中，传输的结果处理闭包，往往是异步调用的，因此应当使用<code>@escaping</code>修饰传入的闭包。</li>\n</ol>\n<hr>\n","excerpt":"","more":"<h2 id=\"笔记来源\"><a href=\"#笔记来源\" class=\"headerlink\" title=\"笔记来源\"></a>笔记来源</h2><p>来自喵神的<a href=\"https://www.amazon.cn/Swifter-100个Swift-2开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_1?ie=UTF8&amp;qid=1477880062&amp;sr=8-1&amp;keywords=swifter\">《swifter》</a>的要点记录。</p>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li>柯里化，即将接受<strong>多个参数</strong>的方法转换成接受<strong>一个参数</strong>的的方法。</li>\n<li>Struct <code>Mutating</code>关键字，由于Struct是immutable的数据结构，如果想<strong>在方法体中修改局部变量的值</strong>，则需要在func 前面加上<code>Mutating</code>关键字。</li>\n<li>Protocol方法的<code>Mutating</code>关键字，为了<strong>能使Struct、enum能在方法中修改它们的局部变量的值</strong>，多考虑在func 前面加上<code>Mutating</code>关键字。<code>Class</code>方法的前面不需要加<code>Mutating</code>关键字。</li>\n<li>传入的闭包，为了避免引用循环，可以在参数列表前加上[weak self, weak obj]这样的标注。</li>\n<li>当作为参数的闭包，在这个函数执行完之后，依然还会被其他地方使用，可以使用<code>@escaping</code>关键字修饰这个闭包参数。例如：在网络请求中，传输的结果处理闭包，往往是异步调用的，因此应当使用<code>@escaping</code>修饰传入的闭包。</li>\n</ol>\n<hr>\n"},{"title":"AsyncDisplayKit笔记","_content":"\n## 开始\n众所周知，`UIKit`它的基础UI单元是`UIView`，类似的`AsyncDisplayKit`的基础单元的是`ASDisplayNode`，`ASDisplayNode`是`UIView`的抽象，不同的是`ASDisplayNode `是线程安全的，可以在在主线程之外使用。\n\n要让app能流畅运行就需要保证app的渲染帧数在60f/s，这也是iOS开发的黄金法则。因此需要将图片解码、文字计算、渲染等耗时的任务从主线程中剥离出去。而`AsyncDisplayKit`做到了这一点。下面就介绍`ASDK`(`ASDK`是`AsyncDisplayKit`的缩写)中的具体模块。\n\n## Nodes\n`node`对应于`UIKit`中的`UIView`，可以说是对`UIView`的封装，`node`的大部分属性方法命名都跟`UIView`保持一致，如果需要访问`node`对应的`UIView`，或者`CALayer`，可以直接使用`node.view`或者`node.layer`，但是要注意在主线程使用它们。\n\n`ASDK`提供了不同类型的node，它们的层级如下图：\n\n![node-hierarchy](http://asyncdisplaykit.org/static/images/node-hierarchy.png)\n\n## Node Containers\n如果想在现有的工程中使用`ASDK`，不能直接将`node`加到现有的view层级中，这样会导致渲染后直接被刷新到屏幕中。\n\n而是，应该是将node加到的[`node Containers`](http://asyncdisplaykit.org/docs/containers-overview.html)中，这些Container就像是UIkit与ASDK之间的桥梁，它们负责管理它们的孩子node的状态，在适当的时机有效的更新孩子node的数据以及渲染UI。\n\n## Layout Engine\nASDK的布局引擎是基于`CSS FlexBox`模型构建的，每一个`node`都会有一个与之对应的`ASLayoutSpec`来管理它的布局。`CSS FlexBox`相关的学习资料可以在参考如下几个网站：\n\n- [ASStackLayout Game](http://nguyenhuy.github.io/froggy-asdk-layout/)\n- [Visual Guide to CSS3 Flexbox](https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/)\n- [FlexBox Patterns](http://www.flexboxpatterns.com/home)\n\n\n","source":"_drafts/AsyncDisplayKit笔记.md","raw":"---\ntitle: AsyncDisplayKit笔记\ncategories: \n- Apple Development\n- iOS开发笔记\ntags: UI优化\n---\n\n## 开始\n众所周知，`UIKit`它的基础UI单元是`UIView`，类似的`AsyncDisplayKit`的基础单元的是`ASDisplayNode`，`ASDisplayNode`是`UIView`的抽象，不同的是`ASDisplayNode `是线程安全的，可以在在主线程之外使用。\n\n要让app能流畅运行就需要保证app的渲染帧数在60f/s，这也是iOS开发的黄金法则。因此需要将图片解码、文字计算、渲染等耗时的任务从主线程中剥离出去。而`AsyncDisplayKit`做到了这一点。下面就介绍`ASDK`(`ASDK`是`AsyncDisplayKit`的缩写)中的具体模块。\n\n## Nodes\n`node`对应于`UIKit`中的`UIView`，可以说是对`UIView`的封装，`node`的大部分属性方法命名都跟`UIView`保持一致，如果需要访问`node`对应的`UIView`，或者`CALayer`，可以直接使用`node.view`或者`node.layer`，但是要注意在主线程使用它们。\n\n`ASDK`提供了不同类型的node，它们的层级如下图：\n\n![node-hierarchy](http://asyncdisplaykit.org/static/images/node-hierarchy.png)\n\n## Node Containers\n如果想在现有的工程中使用`ASDK`，不能直接将`node`加到现有的view层级中，这样会导致渲染后直接被刷新到屏幕中。\n\n而是，应该是将node加到的[`node Containers`](http://asyncdisplaykit.org/docs/containers-overview.html)中，这些Container就像是UIkit与ASDK之间的桥梁，它们负责管理它们的孩子node的状态，在适当的时机有效的更新孩子node的数据以及渲染UI。\n\n## Layout Engine\nASDK的布局引擎是基于`CSS FlexBox`模型构建的，每一个`node`都会有一个与之对应的`ASLayoutSpec`来管理它的布局。`CSS FlexBox`相关的学习资料可以在参考如下几个网站：\n\n- [ASStackLayout Game](http://nguyenhuy.github.io/froggy-asdk-layout/)\n- [Visual Guide to CSS3 Flexbox](https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/)\n- [FlexBox Patterns](http://www.flexboxpatterns.com/home)\n\n\n","slug":"AsyncDisplayKit笔记","published":0,"date":"2016-12-15T06:09:51.000Z","updated":"2016-12-15T06:09:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3h0006givbtk73eo29","content":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>众所周知，<code>UIKit</code>它的基础UI单元是<code>UIView</code>，类似的<code>AsyncDisplayKit</code>的基础单元的是<code>ASDisplayNode</code>，<code>ASDisplayNode</code>是<code>UIView</code>的抽象，不同的是<code>ASDisplayNode</code>是线程安全的，可以在在主线程之外使用。</p>\n<p>要让app能流畅运行就需要保证app的渲染帧数在60f/s，这也是iOS开发的黄金法则。因此需要将图片解码、文字计算、渲染等耗时的任务从主线程中剥离出去。而<code>AsyncDisplayKit</code>做到了这一点。下面就介绍<code>ASDK</code>(<code>ASDK</code>是<code>AsyncDisplayKit</code>的缩写)中的具体模块。</p>\n<h2 id=\"Nodes\"><a href=\"#Nodes\" class=\"headerlink\" title=\"Nodes\"></a>Nodes</h2><p><code>node</code>对应于<code>UIKit</code>中的<code>UIView</code>，可以说是对<code>UIView</code>的封装，<code>node</code>的大部分属性方法命名都跟<code>UIView</code>保持一致，如果需要访问<code>node</code>对应的<code>UIView</code>，或者<code>CALayer</code>，可以直接使用<code>node.view</code>或者<code>node.layer</code>，但是要注意在主线程使用它们。</p>\n<p><code>ASDK</code>提供了不同类型的node，它们的层级如下图：</p>\n<p><img src=\"http://asyncdisplaykit.org/static/images/node-hierarchy.png\" alt=\"node-hierarchy\"></p>\n<h2 id=\"Node-Containers\"><a href=\"#Node-Containers\" class=\"headerlink\" title=\"Node Containers\"></a>Node Containers</h2><p>如果想在现有的工程中使用<code>ASDK</code>，不能直接将<code>node</code>加到现有的view层级中，这样会导致渲染后直接被刷新到屏幕中。</p>\n<p>而是，应该是将node加到的<a href=\"http://asyncdisplaykit.org/docs/containers-overview.html\" target=\"_blank\" rel=\"external\"><code>node Containers</code></a>中，这些Container就像是UIkit与ASDK之间的桥梁，它们负责管理它们的孩子node的状态，在适当的时机有效的更新孩子node的数据以及渲染UI。</p>\n<h2 id=\"Layout-Engine\"><a href=\"#Layout-Engine\" class=\"headerlink\" title=\"Layout Engine\"></a>Layout Engine</h2><p>ASDK的布局引擎是基于<code>CSS FlexBox</code>模型构建的，每一个<code>node</code>都会有一个与之对应的<code>ASLayoutSpec</code>来管理它的布局。<code>CSS FlexBox</code>相关的学习资料可以在参考如下几个网站：</p>\n<ul>\n<li><a href=\"http://nguyenhuy.github.io/froggy-asdk-layout/\" target=\"_blank\" rel=\"external\">ASStackLayout Game</a></li>\n<li><a href=\"https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/\" target=\"_blank\" rel=\"external\">Visual Guide to CSS3 Flexbox</a></li>\n<li><a href=\"http://www.flexboxpatterns.com/home\" target=\"_blank\" rel=\"external\">FlexBox Patterns</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>众所周知，<code>UIKit</code>它的基础UI单元是<code>UIView</code>，类似的<code>AsyncDisplayKit</code>的基础单元的是<code>ASDisplayNode</code>，<code>ASDisplayNode</code>是<code>UIView</code>的抽象，不同的是<code>ASDisplayNode</code>是线程安全的，可以在在主线程之外使用。</p>\n<p>要让app能流畅运行就需要保证app的渲染帧数在60f/s，这也是iOS开发的黄金法则。因此需要将图片解码、文字计算、渲染等耗时的任务从主线程中剥离出去。而<code>AsyncDisplayKit</code>做到了这一点。下面就介绍<code>ASDK</code>(<code>ASDK</code>是<code>AsyncDisplayKit</code>的缩写)中的具体模块。</p>\n<h2 id=\"Nodes\"><a href=\"#Nodes\" class=\"headerlink\" title=\"Nodes\"></a>Nodes</h2><p><code>node</code>对应于<code>UIKit</code>中的<code>UIView</code>，可以说是对<code>UIView</code>的封装，<code>node</code>的大部分属性方法命名都跟<code>UIView</code>保持一致，如果需要访问<code>node</code>对应的<code>UIView</code>，或者<code>CALayer</code>，可以直接使用<code>node.view</code>或者<code>node.layer</code>，但是要注意在主线程使用它们。</p>\n<p><code>ASDK</code>提供了不同类型的node，它们的层级如下图：</p>\n<p><img src=\"http://asyncdisplaykit.org/static/images/node-hierarchy.png\" alt=\"node-hierarchy\"></p>\n<h2 id=\"Node-Containers\"><a href=\"#Node-Containers\" class=\"headerlink\" title=\"Node Containers\"></a>Node Containers</h2><p>如果想在现有的工程中使用<code>ASDK</code>，不能直接将<code>node</code>加到现有的view层级中，这样会导致渲染后直接被刷新到屏幕中。</p>\n<p>而是，应该是将node加到的<a href=\"http://asyncdisplaykit.org/docs/containers-overview.html\"><code>node Containers</code></a>中，这些Container就像是UIkit与ASDK之间的桥梁，它们负责管理它们的孩子node的状态，在适当的时机有效的更新孩子node的数据以及渲染UI。</p>\n<h2 id=\"Layout-Engine\"><a href=\"#Layout-Engine\" class=\"headerlink\" title=\"Layout Engine\"></a>Layout Engine</h2><p>ASDK的布局引擎是基于<code>CSS FlexBox</code>模型构建的，每一个<code>node</code>都会有一个与之对应的<code>ASLayoutSpec</code>来管理它的布局。<code>CSS FlexBox</code>相关的学习资料可以在参考如下几个网站：</p>\n<ul>\n<li><a href=\"http://nguyenhuy.github.io/froggy-asdk-layout/\">ASStackLayout Game</a></li>\n<li><a href=\"https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/\">Visual Guide to CSS3 Flexbox</a></li>\n<li><a href=\"http://www.flexboxpatterns.com/home\">FlexBox Patterns</a></li>\n</ul>\n"},{"title":"时间管理","_content":"\n习惯的三要素：暗示、惯例、奖励。","source":"_drafts/时间管理.md","raw":"---\ntitle: 时间管理\ncategories:\ntags: 方法论\n---\n\n习惯的三要素：暗示、惯例、奖励。","slug":"时间管理","published":0,"date":"2016-10-21T02:18:47.000Z","updated":"2016-10-21T02:18:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3k0008givbo2veo19k","content":"<p>习惯的三要素：暗示、惯例、奖励。</p>\n","excerpt":"","more":"<p>习惯的三要素：暗示、惯例、奖励。</p>\n"},{"title":"Mach调度","description":"抢占模式: 1. 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点: 2. 隐式抢占：调度器管理线程的执行。","_content":"\n## 线程\n线程是个结构体\n## 任务（task）\n线程的容器，是以线程为元素的数组\n## 优先级\n## 运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n## 续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n## 抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n## 异步软件陷阱（AST）\n\n## 定时器中断\n软件定时器：\n硬件定时器：\n## 异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","source":"_drafts/Mach调度.md","raw":"---\ntitle: Mach调度\ndescription: \"抢占模式: 1. 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n2. 隐式抢占：调度器管理线程的执行。\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - Mach\n---\n\n## 线程\n线程是个结构体\n## 任务（task）\n线程的容器，是以线程为元素的数组\n## 优先级\n## 运行队列\n将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组\n## 续体\n为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。\n## 抢占模式\n- 显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:\n- 隐式抢占：调度器管理线程的执行。\n## 异步软件陷阱（AST）\n\n## 定时器中断\n软件定时器：\n硬件定时器：\n## 异常\n- 每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。\n- 异常消息分发顺序：\n1、检查线程是否注册了异常处理端口，有则线程数理。完成。\n2、检查task时候注册异常处理端口，有则task处理。完成。\n3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。\n4、如果都没有注册异常处理端口，则crash。\n\n\n\n\n\n\n","slug":"Mach调度","published":0,"date":"2016-11-15T09:30:49.000Z","updated":"2016-11-15T09:30:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3l0009givbz4l5lszt","content":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是个结构体</p>\n<h2 id=\"任务（task）\"><a href=\"#任务（task）\" class=\"headerlink\" title=\"任务（task）\"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><h2 id=\"运行队列\"><a href=\"#运行队列\" class=\"headerlink\" title=\"运行队列\"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<h2 id=\"续体\"><a href=\"#续体\" class=\"headerlink\" title=\"续体\"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<h2 id=\"抢占模式\"><a href=\"#抢占模式\" class=\"headerlink\" title=\"抢占模式\"></a>抢占模式</h2><ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<h2 id=\"异步软件陷阱（AST）\"><a href=\"#异步软件陷阱（AST）\" class=\"headerlink\" title=\"异步软件陷阱（AST）\"></a>异步软件陷阱（AST）</h2></li>\n</ul>\n<h2 id=\"定时器中断\"><a href=\"#定时器中断\" class=\"headerlink\" title=\"定时器中断\"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>线程是个结构体</p>\n<h2 id=\"任务（task）\"><a href=\"#任务（task）\" class=\"headerlink\" title=\"任务（task）\"></a>任务（task）</h2><p>线程的容器，是以线程为元素的数组</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><h2 id=\"运行队列\"><a href=\"#运行队列\" class=\"headerlink\" title=\"运行队列\"></a>运行队列</h2><p>将同等优先级的线程放到同一个数组，而运行队列则是优先级数组的数组</p>\n<h2 id=\"续体\"><a href=\"#续体\" class=\"headerlink\" title=\"续体\"></a>续体</h2><p>为降低切换线程消耗资源而设计的数据结构，里面包含了线程的状态以及入口，当线程切换时候，调度器找到目标线程的续体，然后从续体恢复状态，进入线程。</p>\n<h2 id=\"抢占模式\"><a href=\"#抢占模式\" class=\"headerlink\" title=\"抢占模式\"></a>抢占模式</h2><ul>\n<li>显示抢占：线程自己管理自己对资源的占用，即，自己管理自己在什么让出CPU，或者什么时候占用CPU。缺点:</li>\n<li>隐式抢占：调度器管理线程的执行。<h2 id=\"异步软件陷阱（AST）\"><a href=\"#异步软件陷阱（AST）\" class=\"headerlink\" title=\"异步软件陷阱（AST）\"></a>异步软件陷阱（AST）</h2></li>\n</ul>\n<h2 id=\"定时器中断\"><a href=\"#定时器中断\" class=\"headerlink\" title=\"定时器中断\"></a>定时器中断</h2><p>软件定时器：<br>硬件定时器：</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>每个task可以注册一个异常处理端口A，如果它的子线程没有注册异常处理端口，那么它的所有线程的的异常都将抛到端口A。</li>\n<li>异常消息分发顺序：<br>1、检查线程是否注册了异常处理端口，有则线程数理。完成。<br>2、检查task时候注册异常处理端口，有则task处理。完成。<br>3、检查远端server时候有注册异常处理端口，有则远端server处理。完成。<br>4、如果都没有注册异常处理端口，则crash。</li>\n</ul>\n"},{"title":"编译过程预览","_content":"\n","source":"_drafts/编译过程预览.md","raw":"---\ntitle: 编译过程预览\ncategories: \n- 编译系统\ntags: \n- 编译 \n- 汇编\n---\n\n","slug":"编译过程预览","published":0,"date":"2016-11-08T01:52:23.000Z","updated":"2016-11-08T01:52:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3p000dgivbfu42y08q","content":"","excerpt":"","more":""},{"title":"Building xnu for OS X 10.11 El Capitan","description":"此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份...","_content":"\n\n*此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份。*\n\nThe OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: [here](https://opensource.apple.com/source/xnu/xnu-3247.1.106/)\n\nBuilding xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:\n\n1. Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with \"sudo xcodebuild -license\"\n2. Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself\n\n\t```\n    $ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz\n\t```\n    \n3. Build and install CTF tools from dtrace\n\n\t```\n    $ tar zxf dtrace-168.tar.gz\n    $ cd dtrace-168\n    $ mkdir -p obj sym dst\n    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=\"x86_64\" SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    ...\n    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain\n    Password:\n    $ cd ..\n\t```    \n\n4. Install AvailabilityVersions\n\n\t```\n    $ tar zxf AvailabilityVersions-20.tar.gz \n    $ cd AvailabilityVersions-20\n    $ mkdir -p dst\n    $ make install SRCROOT=$PWD DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst/usr/local `xcrun -sdk macosx -show-sdk-path`/usr/local\n    $ cd ..\n\t```\n\n5. Build xnu\n\n\t```\n    $ tar zxf xnu-3247.1.106.tar.gz\n    $ cd xnu-3247.1.106\n    $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\n\t```\n\n**See xnu's top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**\n\nUpdate: If you are attempting to add system calls, you may also need to build Libsyscall.\n\n1. Download the Libsystem source\n\n\t```\n\t$ curl -O https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\n\t```\n\n2. Install Libsystem headers\n\n\t```\n    $ tar zxf Libsystem-1225.1.1.tar.gz\n    $ cd Libsystem-1225.1.1\n    $ xcodebuild installhdrs -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst `xcrun -sdk macosx -show-sdk-path`\n    $ cd ..\n    ```\n3. Install xnu and Libsyscall headers\n\t\n\t```\n    $ cd xnu-3247.1.106\n    $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst\n    $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo ditto BUILD.hdrs/dst `xcrun -sdk macosx -show-sdk-path`\n    ```\n4. Build Libsyscall\n\n\t```\n    $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst\n    $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst\n    ```\n5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).\n\n6. To install the resulting new binaries, execute:\n  \t1. xnu: \n\t\n\t\t```\n\t    $ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n\t    $ sudo kextcache -invalidate /\n\t    / locked; waiting for lock.\n\t    Lock acquired; proceeding.\n\t    ...\n\t    $ sudo reboot\n   \t\t ```\n  \t2. Libsyscall: \n\t\t\n\t\t```\n        $ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n\t    $ sudo update_dyld_shared_cache\n\t    ...\n\t    $ sudo reboot\n    \t```\n\n---\n[1]: http://shantonu.blogspot.co.uk","source":"_posts/Building xnu for OS X 10.11 El Capitan.md","raw":"---\ntitle: Building xnu for OS X 10.11 El Capitan\ndescription: \"此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n - XNU\n---\n\n\n*此文只因为国内浏览[ssen's blog][1]需要翻墙，为了方便浏览从中拷贝了一份。*\n\nThe OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: [here](https://opensource.apple.com/source/xnu/xnu-3247.1.106/)\n\nBuilding xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:\n\n1. Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with \"sudo xcodebuild -license\"\n2. Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself\n\n\t```\n    $ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz\n    $ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz\n\t```\n    \n3. Build and install CTF tools from dtrace\n\n\t```\n    $ tar zxf dtrace-168.tar.gz\n    $ cd dtrace-168\n    $ mkdir -p obj sym dst\n    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=\"x86_64\" SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    ...\n    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain\n    Password:\n    $ cd ..\n\t```    \n\n4. Install AvailabilityVersions\n\n\t```\n    $ tar zxf AvailabilityVersions-20.tar.gz \n    $ cd AvailabilityVersions-20\n    $ mkdir -p dst\n    $ make install SRCROOT=$PWD DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst/usr/local `xcrun -sdk macosx -show-sdk-path`/usr/local\n    $ cd ..\n\t```\n\n5. Build xnu\n\n\t```\n    $ tar zxf xnu-3247.1.106.tar.gz\n    $ cd xnu-3247.1.106\n    $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE\n\t```\n\n**See xnu's top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**\n\nUpdate: If you are attempting to add system calls, you may also need to build Libsyscall.\n\n1. Download the Libsystem source\n\n\t```\n\t$ curl -O https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\n\t```\n\n2. Install Libsystem headers\n\n\t```\n    $ tar zxf Libsystem-1225.1.1.tar.gz\n    $ cd Libsystem-1225.1.1\n    $ xcodebuild installhdrs -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst\n    $ sudo ditto $PWD/dst `xcrun -sdk macosx -show-sdk-path`\n    $ cd ..\n    ```\n3. Install xnu and Libsyscall headers\n\t\n\t```\n    $ cd xnu-3247.1.106\n    $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst\n    $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst\n    $ sudo ditto BUILD.hdrs/dst `xcrun -sdk macosx -show-sdk-path`\n    ```\n4. Build Libsyscall\n\n\t```\n    $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst\n    $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS='x86_64 i386' SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst\n    ```\n5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).\n\n6. To install the resulting new binaries, execute:\n  \t1. xnu: \n\t\n\t\t```\n\t    $ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n\t    $ sudo kextcache -invalidate /\n\t    / locked; waiting for lock.\n\t    Lock acquired; proceeding.\n\t    ...\n\t    $ sudo reboot\n   \t\t ```\n  \t2. Libsyscall: \n\t\t\n\t\t```\n        $ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n\t    $ sudo update_dyld_shared_cache\n\t    ...\n\t    $ sudo reboot\n    \t```\n\n---\n[1]: http://shantonu.blogspot.co.uk","slug":"Building xnu for OS X 10.11 El Capitan","published":1,"date":"2016-11-15T09:29:47.000Z","updated":"2016-11-15T09:29:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3q000fgivbrhx01zbk","content":"<p><em>此文只因为国内浏览<a href=\"http://shantonu.blogspot.co.uk\" target=\"_blank\" rel=\"external\">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>\n<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href=\"https://opensource.apple.com/source/xnu/xnu-3247.1.106/\" target=\"_blank\" rel=\"external\">here</a></p>\n<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>\n<ol>\n<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>\n<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>Build and install CTF tools from dtrace</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    $ tar zxf dtrace-168.tar.gz</div><div class=\"line\">    $ cd dtrace-168</div><div class=\"line\">    $ mkdir -p obj sym dst</div><div class=\"line\">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class=\"line\">    ...</div><div class=\"line\">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class=\"line\">    Password:</div><div class=\"line\">    $ cd ..</div><div class=\"line\">\t```    </div><div class=\"line\"></div><div class=\"line\">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>\n<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. Build xnu</div></pre></td></tr></table></figure>\n<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**</div><div class=\"line\"></div><div class=\"line\">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class=\"line\"></div><div class=\"line\">1. Download the Libsystem source</div></pre></td></tr></table></figure>\n<p> $ curl -O <a href=\"https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\" target=\"_blank\" rel=\"external\">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">2. Install Libsystem headers</div></pre></td></tr></table></figure>\n<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>\n<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">4. Build Libsyscall</div></pre></td></tr></table></figure>\n<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class=\"line\"></div><div class=\"line\">6. To install the resulting new binaries, execute:</div><div class=\"line\">  \t1. xnu:</div></pre></td></tr></table></figure>\n<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n$ sudo kextcache -invalidate /\n/ locked; waiting for lock.\nLock acquired; proceeding.\n...\n$ sudo reboot\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2. Libsyscall:</div></pre></td></tr></table></figure>\n\n$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n$ sudo update_dyld_shared_cache\n...\n$ sudo reboot\n```\n</code></pre></li>\n</ol>\n<hr>\n","excerpt":"","more":"<p><em>此文只因为国内浏览<a href=\"http://shantonu.blogspot.co.uk\">ssen’s blog</a>需要翻墙，为了方便浏览从中拷贝了一份。</em></p>\n<p>The OS X kernel source (xnu) has been released for OS X 10.11 El Capitan: <a href=\"https://opensource.apple.com/source/xnu/xnu-3247.1.106/\">here</a></p>\n<p>Building xnu requires Xcode and some additional open-source (but not pre-installed) dependencies. You can build xnu manually by doing:</p>\n<ol>\n<li>Install OS X El Capitan and Xcode 7.0, 7.1, or 7.2 from the Mac App Store, make sure the Xcode license has been agreed-to with “sudo xcodebuild -license”</li>\n<li><p>Download the source for the dtrace and AvailabilityVersions projects, which are required dependencies, as well as xnu itself</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/dtrace/dtrace-168.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/AvailabilityVersions/AvailabilityVersions-20.tar.gz</div><div class=\"line\">$ curl -O https://opensource.apple.com/tarballs/xnu/xnu-3247.1.106.tar.gz</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>Build and install CTF tools from dtrace</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">    $ tar zxf dtrace-168.tar.gz</div><div class=\"line\">    $ cd dtrace-168</div><div class=\"line\">    $ mkdir -p obj sym dst</div><div class=\"line\">    $ xcodebuild install -target ctfconvert -target ctfdump -target ctfmerge ARCHS=&quot;x86_64&quot; SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst</div><div class=\"line\">    ...</div><div class=\"line\">    $ sudo ditto $PWD/dst/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain</div><div class=\"line\">    Password:</div><div class=\"line\">    $ cd ..</div><div class=\"line\">\t```    </div><div class=\"line\"></div><div class=\"line\">4. Install AvailabilityVersions</div></pre></td></tr></table></figure>\n<p> $ tar zxf AvailabilityVersions-20.tar.gz<br> $ cd AvailabilityVersions-20<br> $ mkdir -p dst<br> $ make install SRCROOT=$PWD DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst/usr/local <code>xcrun -sdk macosx -show-sdk-path</code>/usr/local<br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">5. Build xnu</div></pre></td></tr></table></figure>\n<p> $ tar zxf xnu-3247.1.106.tar.gz<br> $ cd xnu-3247.1.106<br> $ make SDKROOT=macosx ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=RELEASE</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**See xnu&apos;s top-level README for additional build variables that can be passed on the command-line, such as BUILD\\_LTO=0 or KERNEL\\_CONFIGS=DEVELOPMENT .**</div><div class=\"line\"></div><div class=\"line\">Update: If you are attempting to add system calls, you may also need to build Libsyscall.</div><div class=\"line\"></div><div class=\"line\">1. Download the Libsystem source</div></pre></td></tr></table></figure>\n<p> $ curl -O <a href=\"https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz\">https://opensource.apple.com/tarballs/Libsystem/Libsystem-1225.1.1.tar.gz</a></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">2. Install Libsystem headers</div></pre></td></tr></table></figure>\n<p> $ tar zxf Libsystem-1225.1.1.tar.gz<br> $ cd Libsystem-1225.1.1<br> $ xcodebuild installhdrs -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD OBJROOT=$PWD/obj SYMROOT=$PWD/sym DSTROOT=$PWD/dst<br> $ sudo ditto $PWD/dst <code>xcrun -sdk macosx -show-sdk-path</code><br> $ cd ..</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">3. Install xnu and Libsyscall headers</div></pre></td></tr></table></figure>\n<p> $ cd xnu-3247.1.106<br> $ mkdir -p BUILD.hdrs/obj BUILD.hdrs/sym BUILD.hdrs/dst<br> $ make installhdrs SDKROOT=macosx ARCH_CONFIGS=X86_64 SRCROOT=$PWD OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo xcodebuild installhdrs -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.hdrs/obj SYMROOT=$PWD/BUILD.hdrs/sym DSTROOT=$PWD/BUILD.hdrs/dst<br> $ sudo ditto BUILD.hdrs/dst <code>xcrun -sdk macosx -show-sdk-path</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">4. Build Libsyscall</div></pre></td></tr></table></figure>\n<p> $ mkdir -p BUILD.libsyscall/obj BUILD.libsyscall/sym BUILD.libsyscall/dst<br> $ sudo xcodebuild install -project libsyscall/Libsyscall.xcodeproj -sdk macosx ARCHS=’x86_64 i386’ SRCROOT=$PWD/libsyscall OBJROOT=$PWD/BUILD.libsyscall/obj SYMROOT=$PWD/BUILD.libsyscall/sym DSTROOT=$PWD/BUILD.libsyscall/dst</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">5. To install custom OS components, [System Integrity Protection must be disabled](https://developer.apple.com/library/mac/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html#//apple_ref/doc/uid/TP40016462-CH5-SW1).</div><div class=\"line\"></div><div class=\"line\">6. To install the resulting new binaries, execute:</div><div class=\"line\">  \t1. xnu:</div></pre></td></tr></table></figure>\n<pre><code>$ sudo cp BUILD/obj/RELEASE_X86_64/kernel /System/Library/Kernels/\n$ sudo kextcache -invalidate /\n/ locked; waiting for lock.\nLock acquired; proceeding.\n...\n$ sudo reboot\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">2. Libsyscall:</div></pre></td></tr></table></figure>\n\n$ sudo cp BUILD.libsyscall/dst/usr/lib/system/libsystem_kernel.dylib /usr/lib/system/\n$ sudo update_dyld_shared_cache\n...\n$ sudo reboot\n```\n</code></pre></li>\n</ol>\n<hr>\n"},{"title":"基于B树的HFS+文件系统","_content":"# B树基础\n## 定义\n网络上或者算法书上可以看到很多对B树的定义，比如这篇文章：[《B树》][1]。在理解这个定义的时候，我们需要理解这些概念：\n\n- key：树节点的键值（关键字），同一个节点的键值应该是顺序排列的。\n- 度：一个节点子树的数目。\n- 阶：所有节点的子树数目最大值。用m表示。\n\n然后再看定义：\n\n- 树中每个结点最多含有m个孩子（m>=2）；\n- 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；\n- 根结点至少有2个孩子（除非B树只包含一个结点：根结点）；\n- 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。\n- 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中： \n\t1. Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。 \n\t2. Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 \n\t3. 关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。\n\n## 插入\n\n- 如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；\n- 如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该 结点 进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。\n- 此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。\n\n> 具体实例见[《B树》][1]中的“插入”小节。\n\n## 删除\n删除操作相对于插入操作要考虑的情况多点。\n\n- 首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点\n\t1. 如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；\n\t2. 如果没有，直接删除后，移动之后的情况。\n- 删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于 ceil(m/2)-1 ，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）\n\t1. 如果丰满，则向父节点借一个元素来满足条件；\n\t2. 如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。\n\n> 具体实例见[《B树》][1]中的“删除”小节。\n\n## B树的优点\nB树是一棵多叉树，在查找数据的过程中最优的情况下时间复杂度是logm(n),最坏情况下是logm/2(n)，（m表示B数的阶），因此B树大部分情况下能提供指数时间的复杂度。对于文件系统的搜索、删除、插入、更新、随机访问都能提供较快，较稳定的时间复杂度。\n\n## B树与Hash的对比\n在做对比前，我们已经理解Hash以及B树的查找原理分别是怎样的。\n\n- Hash相当于把key通过hash函数计算，得到key的hash值,再用这个hash值做指针，查找hash表中是否存在key，如果存在就返回 key所对应的value，选定一个好的hash函数很重要，好的hash函数可以使计算出的hash值分布均匀，降低冲突，只有冲突减小了，才会降低 hash表的查找时间。\n- B-tree完全基于key的比较，和二叉树相同的道理，相当于建个排序后的数据集，使用二分法查找算法，实际上也非常快，而且受数据量增长影响非常小。\n\n为什么很多数据库或文件系统采用了B树做数据结构，而不采用hash？\n\n- Hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询。\n- Hash索引无法被用来进行数据的排序操作。\n- Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。\n\n# HFS+文件系统\nHFS+文件系统采用了6个特殊的文件来维护自己的数据，其中有四个是B树，分别是：\n\n- **编录B树**：包含文件系统的所有目录以及文件，也就是说用户对文件的所有操作都会影响到这个文件。\n- **属性B树**：用于支持文件扩展属性。\n- **extent溢出B树**：用于超过8个碎片（或extent，一个extent表示一组连续的分配块）的文件。\n- **热文件B树**：用户频繁访问的小文件。\n\n两个文件是：\n\n- **分配文件**：一个位图，包含文件系统中所有数据块的使用情况，其中每一位代表一个数据块的使用情况。\n- **启动文件**：一个可执行文件，用于引导操作系统。MacOS X已经弃用了，其他操作系统可以使用。\n\n如果HFS+挂载的时候启用了日志功能，那么还会启用一个日志文件。\n\n\n## 参考文献：\n1. [B树][1]\n\n[1]: http://taop.marchtea.com/03.02.html\n\n","source":"_posts/B-Tree_and_HFS+.md","raw":"---\ntitle: 基于B树的HFS+文件系统\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n- 文件系统\n---\n# B树基础\n## 定义\n网络上或者算法书上可以看到很多对B树的定义，比如这篇文章：[《B树》][1]。在理解这个定义的时候，我们需要理解这些概念：\n\n- key：树节点的键值（关键字），同一个节点的键值应该是顺序排列的。\n- 度：一个节点子树的数目。\n- 阶：所有节点的子树数目最大值。用m表示。\n\n然后再看定义：\n\n- 树中每个结点最多含有m个孩子（m>=2）；\n- 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；\n- 根结点至少有2个孩子（除非B树只包含一个结点：根结点）；\n- 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。\n- 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中： \n\t1. Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。 \n\t2. Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 \n\t3. 关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。\n\n## 插入\n\n- 如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；\n- 如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该 结点 进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。\n- 此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。\n\n> 具体实例见[《B树》][1]中的“插入”小节。\n\n## 删除\n删除操作相对于插入操作要考虑的情况多点。\n\n- 首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点\n\t1. 如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；\n\t2. 如果没有，直接删除后，移动之后的情况。\n- 删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于 ceil(m/2)-1 ，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）\n\t1. 如果丰满，则向父节点借一个元素来满足条件；\n\t2. 如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。\n\n> 具体实例见[《B树》][1]中的“删除”小节。\n\n## B树的优点\nB树是一棵多叉树，在查找数据的过程中最优的情况下时间复杂度是logm(n),最坏情况下是logm/2(n)，（m表示B数的阶），因此B树大部分情况下能提供指数时间的复杂度。对于文件系统的搜索、删除、插入、更新、随机访问都能提供较快，较稳定的时间复杂度。\n\n## B树与Hash的对比\n在做对比前，我们已经理解Hash以及B树的查找原理分别是怎样的。\n\n- Hash相当于把key通过hash函数计算，得到key的hash值,再用这个hash值做指针，查找hash表中是否存在key，如果存在就返回 key所对应的value，选定一个好的hash函数很重要，好的hash函数可以使计算出的hash值分布均匀，降低冲突，只有冲突减小了，才会降低 hash表的查找时间。\n- B-tree完全基于key的比较，和二叉树相同的道理，相当于建个排序后的数据集，使用二分法查找算法，实际上也非常快，而且受数据量增长影响非常小。\n\n为什么很多数据库或文件系统采用了B树做数据结构，而不采用hash？\n\n- Hash索引仅满足“=”、“IN”和“<=>”查询，不能使用范围查询。\n- Hash索引无法被用来进行数据的排序操作。\n- Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。\n\n# HFS+文件系统\nHFS+文件系统采用了6个特殊的文件来维护自己的数据，其中有四个是B树，分别是：\n\n- **编录B树**：包含文件系统的所有目录以及文件，也就是说用户对文件的所有操作都会影响到这个文件。\n- **属性B树**：用于支持文件扩展属性。\n- **extent溢出B树**：用于超过8个碎片（或extent，一个extent表示一组连续的分配块）的文件。\n- **热文件B树**：用户频繁访问的小文件。\n\n两个文件是：\n\n- **分配文件**：一个位图，包含文件系统中所有数据块的使用情况，其中每一位代表一个数据块的使用情况。\n- **启动文件**：一个可执行文件，用于引导操作系统。MacOS X已经弃用了，其他操作系统可以使用。\n\n如果HFS+挂载的时候启用了日志功能，那么还会启用一个日志文件。\n\n\n## 参考文献：\n1. [B树][1]\n\n[1]: http://taop.marchtea.com/03.02.html\n\n","slug":"B-Tree_and_HFS+","published":1,"date":"2016-12-21T08:09:38.000Z","updated":"2016-12-21T08:09:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3t000igivbsfdsq94q","content":"<h1 id=\"B树基础\"><a href=\"#B树基础\" class=\"headerlink\" title=\"B树基础\"></a>B树基础</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>网络上或者算法书上可以看到很多对B树的定义，比如这篇文章：<a href=\"http://taop.marchtea.com/03.02.html\" target=\"_blank\" rel=\"external\">《B树》</a>。在理解这个定义的时候，我们需要理解这些概念：</p>\n<ul>\n<li>key：树节点的键值（关键字），同一个节点的键值应该是顺序排列的。</li>\n<li>度：一个节点子树的数目。</li>\n<li>阶：所有节点的子树数目最大值。用m表示。</li>\n</ul>\n<p>然后再看定义：</p>\n<ul>\n<li>树中每个结点最多含有m个孩子（m&gt;=2）；</li>\n<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>\n<li>根结点至少有2个孩子（除非B树只包含一个结点：根结点）；</li>\n<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。</li>\n<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中： <ol>\n<li>Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 </li>\n<li>Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 </li>\n<li>关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><ul>\n<li>如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；</li>\n<li>如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该 结点 进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。</li>\n<li>此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</li>\n</ul>\n<blockquote>\n<p>具体实例见<a href=\"http://taop.marchtea.com/03.02.html\" target=\"_blank\" rel=\"external\">《B树》</a>中的“插入”小节。</p>\n</blockquote>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>删除操作相对于插入操作要考虑的情况多点。</p>\n<ul>\n<li>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点<ol>\n<li>如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；</li>\n<li>如果没有，直接删除后，移动之后的情况。</li>\n</ol>\n</li>\n<li>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于 ceil(m/2)-1 ，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）<ol>\n<li>如果丰满，则向父节点借一个元素来满足条件；</li>\n<li>如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>具体实例见<a href=\"http://taop.marchtea.com/03.02.html\" target=\"_blank\" rel=\"external\">《B树》</a>中的“删除”小节。</p>\n</blockquote>\n<h2 id=\"B树的优点\"><a href=\"#B树的优点\" class=\"headerlink\" title=\"B树的优点\"></a>B树的优点</h2><p>B树是一棵多叉树，在查找数据的过程中最优的情况下时间复杂度是logm(n),最坏情况下是logm/2(n)，（m表示B数的阶），因此B树大部分情况下能提供指数时间的复杂度。对于文件系统的搜索、删除、插入、更新、随机访问都能提供较快，较稳定的时间复杂度。</p>\n<h2 id=\"B树与Hash的对比\"><a href=\"#B树与Hash的对比\" class=\"headerlink\" title=\"B树与Hash的对比\"></a>B树与Hash的对比</h2><p>在做对比前，我们已经理解Hash以及B树的查找原理分别是怎样的。</p>\n<ul>\n<li>Hash相当于把key通过hash函数计算，得到key的hash值,再用这个hash值做指针，查找hash表中是否存在key，如果存在就返回 key所对应的value，选定一个好的hash函数很重要，好的hash函数可以使计算出的hash值分布均匀，降低冲突，只有冲突减小了，才会降低 hash表的查找时间。</li>\n<li>B-tree完全基于key的比较，和二叉树相同的道理，相当于建个排序后的数据集，使用二分法查找算法，实际上也非常快，而且受数据量增长影响非常小。</li>\n</ul>\n<p>为什么很多数据库或文件系统采用了B树做数据结构，而不采用hash？</p>\n<ul>\n<li>Hash索引仅满足“=”、“IN”和“&lt;=&gt;”查询，不能使用范围查询。</li>\n<li>Hash索引无法被用来进行数据的排序操作。</li>\n<li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li>\n</ul>\n<h1 id=\"HFS-文件系统\"><a href=\"#HFS-文件系统\" class=\"headerlink\" title=\"HFS+文件系统\"></a>HFS+文件系统</h1><p>HFS+文件系统采用了6个特殊的文件来维护自己的数据，其中有四个是B树，分别是：</p>\n<ul>\n<li><strong>编录B树</strong>：包含文件系统的所有目录以及文件，也就是说用户对文件的所有操作都会影响到这个文件。</li>\n<li><strong>属性B树</strong>：用于支持文件扩展属性。</li>\n<li><strong>extent溢出B树</strong>：用于超过8个碎片（或extent，一个extent表示一组连续的分配块）的文件。</li>\n<li><strong>热文件B树</strong>：用户频繁访问的小文件。</li>\n</ul>\n<p>两个文件是：</p>\n<ul>\n<li><strong>分配文件</strong>：一个位图，包含文件系统中所有数据块的使用情况，其中每一位代表一个数据块的使用情况。</li>\n<li><strong>启动文件</strong>：一个可执行文件，用于引导操作系统。MacOS X已经弃用了，其他操作系统可以使用。</li>\n</ul>\n<p>如果HFS+挂载的时候启用了日志功能，那么还会启用一个日志文件。</p>\n<h2 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h2><ol>\n<li><a href=\"http://taop.marchtea.com/03.02.html\" target=\"_blank\" rel=\"external\">B树</a></li>\n</ol>\n","excerpt":"","more":"<h1 id=\"B树基础\"><a href=\"#B树基础\" class=\"headerlink\" title=\"B树基础\"></a>B树基础</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>网络上或者算法书上可以看到很多对B树的定义，比如这篇文章：<a href=\"http://taop.marchtea.com/03.02.html\">《B树》</a>。在理解这个定义的时候，我们需要理解这些概念：</p>\n<ul>\n<li>key：树节点的键值（关键字），同一个节点的键值应该是顺序排列的。</li>\n<li>度：一个节点子树的数目。</li>\n<li>阶：所有节点的子树数目最大值。用m表示。</li>\n</ul>\n<p>然后再看定义：</p>\n<ul>\n<li>树中每个结点最多含有m个孩子（m&gt;=2）；</li>\n<li>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；</li>\n<li>根结点至少有2个孩子（除非B树只包含一个结点：根结点）；</li>\n<li>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。</li>\n<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中： <ol>\n<li>Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 </li>\n<li>Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 </li>\n<li>关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><ul>\n<li>如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；</li>\n<li>如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该 结点 进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。</li>\n<li>此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</li>\n</ul>\n<blockquote>\n<p>具体实例见<a href=\"http://taop.marchtea.com/03.02.html\">《B树》</a>中的“插入”小节。</p>\n</blockquote>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>删除操作相对于插入操作要考虑的情况多点。</p>\n<ul>\n<li>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点<ol>\n<li>如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；</li>\n<li>如果没有，直接删除后，移动之后的情况。</li>\n</ol>\n</li>\n<li>删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于 ceil(m/2)-1 ，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）<ol>\n<li>如果丰满，则向父节点借一个元素来满足条件；</li>\n<li>如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>具体实例见<a href=\"http://taop.marchtea.com/03.02.html\">《B树》</a>中的“删除”小节。</p>\n</blockquote>\n<h2 id=\"B树的优点\"><a href=\"#B树的优点\" class=\"headerlink\" title=\"B树的优点\"></a>B树的优点</h2><p>B树是一棵多叉树，在查找数据的过程中最优的情况下时间复杂度是logm(n),最坏情况下是logm/2(n)，（m表示B数的阶），因此B树大部分情况下能提供指数时间的复杂度。对于文件系统的搜索、删除、插入、更新、随机访问都能提供较快，较稳定的时间复杂度。</p>\n<h2 id=\"B树与Hash的对比\"><a href=\"#B树与Hash的对比\" class=\"headerlink\" title=\"B树与Hash的对比\"></a>B树与Hash的对比</h2><p>在做对比前，我们已经理解Hash以及B树的查找原理分别是怎样的。</p>\n<ul>\n<li>Hash相当于把key通过hash函数计算，得到key的hash值,再用这个hash值做指针，查找hash表中是否存在key，如果存在就返回 key所对应的value，选定一个好的hash函数很重要，好的hash函数可以使计算出的hash值分布均匀，降低冲突，只有冲突减小了，才会降低 hash表的查找时间。</li>\n<li>B-tree完全基于key的比较，和二叉树相同的道理，相当于建个排序后的数据集，使用二分法查找算法，实际上也非常快，而且受数据量增长影响非常小。</li>\n</ul>\n<p>为什么很多数据库或文件系统采用了B树做数据结构，而不采用hash？</p>\n<ul>\n<li>Hash索引仅满足“=”、“IN”和“&lt;=&gt;”查询，不能使用范围查询。</li>\n<li>Hash索引无法被用来进行数据的排序操作。</li>\n<li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li>\n</ul>\n<h1 id=\"HFS-文件系统\"><a href=\"#HFS-文件系统\" class=\"headerlink\" title=\"HFS+文件系统\"></a>HFS+文件系统</h1><p>HFS+文件系统采用了6个特殊的文件来维护自己的数据，其中有四个是B树，分别是：</p>\n<ul>\n<li><strong>编录B树</strong>：包含文件系统的所有目录以及文件，也就是说用户对文件的所有操作都会影响到这个文件。</li>\n<li><strong>属性B树</strong>：用于支持文件扩展属性。</li>\n<li><strong>extent溢出B树</strong>：用于超过8个碎片（或extent，一个extent表示一组连续的分配块）的文件。</li>\n<li><strong>热文件B树</strong>：用户频繁访问的小文件。</li>\n</ul>\n<p>两个文件是：</p>\n<ul>\n<li><strong>分配文件</strong>：一个位图，包含文件系统中所有数据块的使用情况，其中每一位代表一个数据块的使用情况。</li>\n<li><strong>启动文件</strong>：一个可执行文件，用于引导操作系统。MacOS X已经弃用了，其他操作系统可以使用。</li>\n</ul>\n<p>如果HFS+挂载的时候启用了日志功能，那么还会启用一个日志文件。</p>\n<h2 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h2><ol>\n<li><a href=\"http://taop.marchtea.com/03.02.html\">B树</a></li>\n</ol>\n"},{"title":"H5的体验优化","description":"H5跟Native的性能对比 : 1. native可以做缓存，第二次访问可以实现秒开。 2. 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。 3.webView的加载需要耗时，网络建立连接也需要时间...","_content":"\n## H5跟Native的性能对比\n- native可以做缓存，第二次访问可以实现秒开。\n- 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。\n- webView的加载需要耗时，网络建立连接也需要时间。\n\n## 未采用的优化H5的方案\n- 离线包+预加载。\n缺点：\n1. 主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。\n2. 离线包发布效率低下。\n3. 由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。\n\n## 比较好的优化方案\n1. 由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。\n2. 将HTTP改成了Socket。\n3. 通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。\n\n## 进一步优化\n1. H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。\n2. 模板也需要制定一套更新的机制。\n\n## React Native\n- 针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。\n\n要点提炼自：[QQ空间面向移动时代Hybrid架构设计][1]\n[1]: http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650993637&idx=1&sn=8a2673272575abbef4b0f6dbc25e0186&scene=0#wechat_redirect\n","source":"_posts/H5的体验优化.md","raw":"---\ntitle: H5的体验优化\ndescription: \"H5跟Native的性能对比 : 1. native可以做缓存，第二次访问可以实现秒开。 2. 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。 3.webView的加载需要耗时，网络建立连接也需要时间...\"\ncategories: \n - Web \ntags:\n - H5\n - JS\n---\n\n## H5跟Native的性能对比\n- native可以做缓存，第二次访问可以实现秒开。\n- 对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。\n- webView的加载需要耗时，网络建立连接也需要时间。\n\n## 未采用的优化H5的方案\n- 离线包+预加载。\n缺点：\n1. 主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。\n2. 离线包发布效率低下。\n3. 由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。\n\n## 比较好的优化方案\n1. 由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。\n2. 将HTTP改成了Socket。\n3. 通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。\n\n## 进一步优化\n1. H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。\n2. 模板也需要制定一套更新的机制。\n\n## React Native\n- 针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。\n\n要点提炼自：[QQ空间面向移动时代Hybrid架构设计][1]\n[1]: http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650993637&idx=1&sn=8a2673272575abbef4b0f6dbc25e0186&scene=0#wechat_redirect\n","slug":"H5的体验优化","published":1,"date":"2016-11-15T09:29:56.000Z","updated":"2016-11-15T09:29:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3t000kgivb5209n7fd","content":"<h2 id=\"H5跟Native的性能对比\"><a href=\"#H5跟Native的性能对比\" class=\"headerlink\" title=\"H5跟Native的性能对比\"></a>H5跟Native的性能对比</h2><ul>\n<li>native可以做缓存，第二次访问可以实现秒开。</li>\n<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>\n<li>webView的加载需要耗时，网络建立连接也需要时间。</li>\n</ul>\n<h2 id=\"未采用的优化H5的方案\"><a href=\"#未采用的优化H5的方案\" class=\"headerlink\" title=\"未采用的优化H5的方案\"></a>未采用的优化H5的方案</h2><ul>\n<li>离线包+预加载。<br>缺点：</li>\n</ul>\n<ol>\n<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>\n<li>离线包发布效率低下。</li>\n<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>\n</ol>\n<h2 id=\"比较好的优化方案\"><a href=\"#比较好的优化方案\" class=\"headerlink\" title=\"比较好的优化方案\"></a>比较好的优化方案</h2><ol>\n<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>\n<li>将HTTP改成了Socket。</li>\n<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>\n</ol>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><ol>\n<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>\n<li>模板也需要制定一套更新的机制。</li>\n</ol>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>\n</ul>\n<p>要点提炼自：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect\" target=\"_blank\" rel=\"external\">QQ空间面向移动时代Hybrid架构设计</a></p>\n","excerpt":"","more":"<h2 id=\"H5跟Native的性能对比\"><a href=\"#H5跟Native的性能对比\" class=\"headerlink\" title=\"H5跟Native的性能对比\"></a>H5跟Native的性能对比</h2><ul>\n<li>native可以做缓存，第二次访问可以实现秒开。</li>\n<li>对于H5，由于HTTP的不稳定，将会导致H5的第二次访问并不一定会比第一次快。</li>\n<li>webView的加载需要耗时，网络建立连接也需要时间。</li>\n</ul>\n<h2 id=\"未采用的优化H5的方案\"><a href=\"#未采用的优化H5的方案\" class=\"headerlink\" title=\"未采用的优化H5的方案\"></a>未采用的优化H5的方案</h2><ul>\n<li>离线包+预加载。<br>缺点：</li>\n</ul>\n<ol>\n<li>主要解决静态资源的缓存（如静态HTML、静态CSS、静态JS），面对针对个人用户信息做运营时，作用不大。</li>\n<li>离线包发布效率低下。</li>\n<li>由于更新一般都是异步进行的，很多时候没发保证进入某个页面，离线包已经加载完毕了。</li>\n</ol>\n<h2 id=\"比较好的优化方案\"><a href=\"#比较好的优化方案\" class=\"headerlink\" title=\"比较好的优化方案\"></a>比较好的优化方案</h2><ol>\n<li>由于启动webView有时间消耗，因此将启动webView与发起网络请求同步进行。</li>\n<li>将HTTP改成了Socket。</li>\n<li>通过304服务，以及ETag方案，客户端做一些缓存方案，同时服务端需要做版本验证。这样可以减少数据的传输，同时提升用户体验。</li>\n</ol>\n<h2 id=\"进一步优化\"><a href=\"#进一步优化\" class=\"headerlink\" title=\"进一步优化\"></a>进一步优化</h2><ol>\n<li>H5采用增量更新的方案-动静分离，即将UI架构挖出来以及一些静态不变的元素，作为一个模板。本地将这个模板缓存起来，大部分时候客户端与服务端只交换动态变化的数据，然后客户端本地将静态模板以及动态数据做一次合并，生成一个HTML展示给用户。</li>\n<li>模板也需要制定一套更新的机制。</li>\n</ol>\n<h2 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h2><ul>\n<li>针对RN的ListView内存占用很大的问题，介绍了一种处理方案，不完美，但是却能介绍内存占用：把屏幕外的节点用一个宽度为1的空View作为一个占位，这样其实就可以达到内存稍微增长没有这么厉害而不至于达到无限制的增长。</li>\n</ul>\n<p>要点提炼自：<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993637&amp;idx=1&amp;sn=8a2673272575abbef4b0f6dbc25e0186&amp;scene=0#wechat_redirect\">QQ空间面向移动时代Hybrid架构设计</a></p>\n"},{"title":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","date":"2016-07-09T06:22:30.000Z","description":"在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？","_content":"\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n## KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","source":"_posts/KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？.md","raw":"---\ntitle: KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？\ndate: 2016-07-09 14:22:30\ndescription: \"在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？\"\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 遇到的问题\n在做iOS项目过程中，一次偶然的机会发现`object_getClass(id obj)`返回的结果是`NSKVONotifing_ObjectClass`,`[obj class]`返回的结果却是`ObjectClass`,它们的结果竟会不一致？      \n这不科学啊。因为实例的`class方法`，底层实际上就是调用runtime的`object_getClass(id obj)`方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？\n\n## KVO是元凶\n-  从`object_getClass(id obj)`返回的结果`NSKVONotifing_ObjectClass`我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。\n-  KVO的原理\n> 其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：\n1. 比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过`[obj addObserver:self forKeyPath:@“propertyA” options:context:]`方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。\n2. 在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：`setProperA`，并在它里面调用 `- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context`方法。这样当改变属性propertyA的值时，外面就会得到通知。\n3. 在NSKVONotifing_ObjectClass中重写`- (Class) class`方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么`[obj class]`与`object_getClass(id obj)`返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：\n```\n- (void)printMethodList\n{\n    Class cls =  object_getClass(self);\n    unsigned int outCount;\n    Method* methods = class_copyMethodList(cls,&outCount);\n    \n    for (int i = 0; i < outCount ; i++)\n    {\n        SEL name = method_getName(methods[i]);\n        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];\n        NSLog(@\"selName : %@\",strName);\n    }\n\n}\n```\n## 总结\n经过研究这个问题，可以得到以下几个要点：\n1. 查看OC Runtime可以知道，`[obj class]`的底层实现实际是： \n```\n- (Class) class {\n    return object_getClass(self);\n}\n```\n,因此正常情况下`[obj class]`与`object_getClass(obj)`返回的结果应该是一致的。\n2. 当使用KVO时，OC Runtime会改变isa，并重写了class方法。\n3. 当发现`[obj class]`，`object_getClass(obj)`,两者结果不一致的时候，就要想到是不是有地方更改了`- (Class) class`的实现。\n\n\n\n\n\n\n\n\n\n","slug":"KVO后[obj class]与object_getClass(id obj)的结果竟会不一致？","published":1,"updated":"2016-11-15T09:30:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3v000ngivbzj77b4vz","content":"<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<h2 id=\"KVO是元凶\"><a href=\"#KVO是元凶\" class=\"headerlink\" title=\"KVO是元凶\"></a>KVO是元凶</h2><ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>在做iOS项目过程中，一次偶然的机会发现<code>object_getClass(id obj)</code>返回的结果是<code>NSKVONotifing_ObjectClass</code>,<code>[obj class]</code>返回的结果却是<code>ObjectClass</code>,它们的结果竟会不一致？<br>这不科学啊。因为实例的<code>class方法</code>，底层实际上就是调用runtime的<code>object_getClass(id obj)</code>方法实现的，所以正常的情况下这两个方法返回的结果应该是一致的。那是什么原因导致的呢？</p>\n<h2 id=\"KVO是元凶\"><a href=\"#KVO是元凶\" class=\"headerlink\" title=\"KVO是元凶\"></a>KVO是元凶</h2><ul>\n<li>从<code>object_getClass(id obj)</code>返回的结果<code>NSKVONotifing_ObjectClass</code>我们可以猜测，obj可能使用了KVO。那么我们要知道问题出在什么地方，就可以从KVO的实现原理入手。</li>\n<li>KVO的原理<blockquote>\n<p>其实也简单，就是利用OC的runtime特性，更改了isa只能只指向类，以下三步是必不可少的：</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li>比如原先实例obj的isa指针指向的是ObjectClass，那么当你在第一次调用过<code>[obj addObserver:self forKeyPath:@“propertyA” options:context:]</code>方法后，runtime会创建一个新的类，类名以NSKVONotifing开头叫NSKVONotifing_ObjectClass，同时更改实例obj的isa的指针，将其指向NSKVONotifing_ObjectClass。</li>\n<li>在NSKVONotifing_ObjectClass中重写观察的属性propertyA的setter：<code>setProperA</code>，并在它里面调用 <code>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context</code>方法。这样当改变属性propertyA的值时，外面就会得到通知。</li>\n<li>在NSKVONotifing_ObjectClass中重写<code>- (Class) class</code>方法，返回原先的isa指向的类（在这个例子中就是ObjectClass）。这就是为什么<code>[obj class]</code>与<code>object_getClass(id obj)</code>返回的结果不一致的原因。可以通过下面的的方法打印出NSKVONotifing_ObjectClass的方法列表加以证明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)printMethodList</div><div class=\"line\">&#123;</div><div class=\"line\">    Class cls =  object_getClass(self);</div><div class=\"line\">    unsigned int outCount;</div><div class=\"line\">    Method* methods = class_copyMethodList(cls,&amp;outCount);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; outCount ; i++)</div><div class=\"line\">    &#123;</div><div class=\"line\">        SEL name = method_getName(methods[i]);</div><div class=\"line\">        NSString *strName = [NSString  stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</div><div class=\"line\">        NSLog(@&quot;selName : %@&quot;,strName);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过研究这个问题，可以得到以下几个要点：</p>\n<ol>\n<li>查看OC Runtime可以知道，<code>[obj class]</code>的底层实现实际是： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (Class) class &#123;</div><div class=\"line\">    return object_getClass(self);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>,因此正常情况下<code>[obj class]</code>与<code>object_getClass(obj)</code>返回的结果应该是一致的。</p>\n<ol>\n<li>当使用KVO时，OC Runtime会改变isa，并重写了class方法。</li>\n<li>当发现<code>[obj class]</code>，<code>object_getClass(obj)</code>,两者结果不一致的时候，就要想到是不是有地方更改了<code>- (Class) class</code>的实现。</li>\n</ol>\n"},{"title":"Mach原语：一切以消息为媒介","description":"在Mach中所有东西（Task、线程、虚拟内存等））都是对象。对象与对象之间通信**只能**通过端口收发消息...","_content":"\n## 1. Mach概述\n### 1.1 Mach设计原则\n- 在Mach中所有东西（Task、线程、虚拟内存等））都是对象。\n- 对象与对象之间通信**只能**通过端口收发消息。\n\n### 1.2 Mach设计目标\n内核为了保持极简，只做如下的事情：\n\n- “控制点”或执行单元的管理。\n- 线程或线程组（Task）的资源分配。\n- 虚拟内存的分配和管理。\n- 底层物理资源--即CPU、内存和任何物理设备的分配。\n\n## 2. Mach消息\n### 2.1 简单消息\n最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：\n\n```\ntypedef\tstruct \n{\n  mach_msg_bits_t\tmsgh_bits;//标志位\n  mach_msg_size_t\tmsgh_size;//大小\n  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）\n  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）\n  mach_port_name_t\tmsgh_voucher_port;\n  mach_msg_id_t\t\tmsgh_id;\n} mach_msg_header_t; //消息头\n\ntypedef struct\n{\n        mach_msg_size_t msgh_descriptor_count;\n} mach_msg_body_t;//消息体\n\ntypedef struct\n{\n        mach_msg_header_t       header;\n        mach_msg_body_t         body;\n} mach_msg_base_t; //基本消息\n\ntypedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型\n\ntypedef struct \n{\n  mach_msg_trailer_type_t\tmsgh_trailer_type;\n  mach_msg_trailer_size_t\tmsgh_trailer_size;\n} mach_msg_trailer_t; //消息尾\n\n```\n\n### 2.2 复杂消息\n将消息头的标志位`mach_msg_bits_t`设置为`MACH_MSGH_BITS_COMPLEX`，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：\n\n```\ntypedef struct\n{\n  uint64_t\t\t\taddress;//数据的大小\n  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配\n  mach_msg_copy_options_t       copy: 8;//复制指令\n  unsigned int     \t\tpad1: 8;\n  mach_msg_descriptor_type_t    type: 8;\n  mach_msg_size_t       \tsize;//数据的大小\n} mach_msg_ool_descriptor64_t;\n\n```\n\n### 2.3 消息收发\n消息的收发在用户态都是通过如下方法进行的：\n\n```\nextern mach_msg_return_t\tmach_msg(\n\t\t\t\t\tmach_msg_header_t *msg,\n\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型\n\t\t\t\t\tmach_msg_size_t send_size,\n\t\t\t\t\tmach_msg_size_t rcv_size,\n\t\t\t\t\tmach_port_name_t rcv_name,\n\t\t\t\t\tmach_msg_timeout_t timeout,\n\t\t\t\t\tmach_port_name_t notify);\t\t\t\t\t\n```\n\n### 2.4 端口\n端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：\n\n```\nstruct ipc_port {\n\n\t/*\n\t * Initial sub-structure in common with ipc_pset\n\t * First element is an ipc_object second is a\n\t * message queue\n\t */\n\tstruct ipc_object ip_object;\n\tstruct ipc_mqueue ip_messages;\n\n\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */\n\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */\n\t\t  ip_impdonation:1,\t/* port supports importance donation */\n\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */\n\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */\n\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */\n\t\t  ip_reserved:2,\n\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */\n\n\tunion {\n\t\tstruct ipc_space *receiver;\n\t\tstruct ipc_port *destination;\n\t\tipc_port_timestamp_t timestamp;\n\t} data;\n\n\tunion {\n\t\tipc_kobject_t kobject;\n\t\tipc_importance_task_t imp_task;\n\t\tuintptr_t alias;\n\t} kdata;\n\t\t\n\tstruct ipc_port *ip_nsrequest;\n\tstruct ipc_port *ip_pdrequest;\n\tstruct ipc_port_request *ip_requests;\n\tstruct ipc_kmsg *ip_premsg;\n\n\tmach_vm_address_t ip_context;\n\n\tmach_port_mscount_t ip_mscount;\n\tmach_port_rights_t ip_srights;\n\tmach_port_rights_t ip_sorights;\n\n#if\tMACH_ASSERT\n#define\tIP_NSPARES\t\t4\n#define\tIP_CALLSTACK_MAX\t16\n/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */\n\tthread_t\tip_thread;\t/* who made me?  thread context */\n\tunsigned long\tip_timetrack;\t/* give an idea of \"when\" created */\n\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */\n\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */\n#endif\t/* MACH_ASSERT */\n} __attribute__((__packed__));\n\n```\n\n### 2.5 Mach接口生成器（MIG）\nMach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些`.defs`文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：\n![IG_opt.png][1]\n\n## 3. 深入IPC\n- Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。\n- 在用户态下，消息传递都是通过`mach_msg()`函数实现的，这个函数会触发一个mach陷阱`mach_msg_trap()`，接下来`mach_msg_trap()`又会调用`mach_msg_overwrite_trap()`，它会通过`MACH_SEND_MSG`和`MACH_RCV_MSG`来判断是发送操作，还是接收操作。\n- 期中内核态中还可以通过`mach_msg_receive()`和`mach_msg_send()`来收发数据。\n\n## 4. 同步原语\n### 4.1 锁的实现方式\n- **阻塞**：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。**当锁可用的时候**，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。\n- **忙等**：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。\n- **阻塞与忙等的对比**：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。\n\n### 4.2 互斥体(lck_mtx_t)（阻塞）\n- 互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。\n- 原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。\n\n### 4.3 信号量(semaphore_t)（阻塞）\n信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。\n\n### 4.4 自旋锁(hw_lock_t)（忙等）\n一种采用忙等形式的锁。\n### 4.5 读写锁(hw_lock_t)（阻塞）\n当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。\n\n### 4.6 锁集(lock_set_t)\n锁集就是锁的一个数组。\n\n## 5. 机器原语\n### 5.1 主机对象（Host）\n主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：\n\n```\nstruct\thost {\n\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */\n\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];\n\tstruct exception_action exc_actions[EXC_TYPES_COUNT];\n};\n```\n\n### 5.2 时钟对象（Clock）\nMach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是`clock_deadline_for_periodic_event（）`，调度器通过它设置了一个重复发生的通知--从而保证了多任务引擎的运转。\n\n### 5.3 处理器对象（Processer）\n在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给**处理器集**，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：\n\n```\nstruct processor {\n\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,\n\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */\n\tint\t\t\t\t\tstate;\t\t\t/* See below */\n\tboolean_t\t\tis_SMT;\n\tboolean_t\t\tis_recommended;\n\tstruct thread\n\t\t\t\t\t\t*active_thread,\t/* thread running on processor */\n\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */\n\t\t\t\t\t\t*idle_thread;\t/* this processor's idle thread. */\n\n\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */\n\n\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */\n\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */\n\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */\n\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */\n\n\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */\n\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */\n\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */\n\n\tuint64_t\t\t\tdeadline;\t\t/* current deadline */\n\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\trunq;\t\t\t/* runq for this processor */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */\n#endif\n#if defined(CONFIG_SCHED_GRRR)\n\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */\n#endif\n\n\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for\n\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer\n\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */\n\tprocessor_t\t\tprocessor_secondary;\n\tstruct ipc_port *\tprocessor_self;\t/* port for operations */\n\n\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */\n\tprocessor_data_t\tprocessor_data;\t/* per-processor data */\n};\n```\n其中最重要的是runq，这是分发到这个处理器的线程队列。\n\n### 5.3 处理器集\n处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：\n\n- `active_queue`：用于保存当前正在执行线程的CPU。\n- `idle_queue`：用于保存当前空闲的CPU（例如：正在执行`idle_thread`）。\n- `pset_runq`：保存了在这个集合中的所有CPU上执行的线程。\n\n`processor_set`的定义如下：\n\n```\nstruct processor_set {\n\tqueue_head_t\t\tactive_queue;\t/* active processors */\n\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */\n\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */\n\n\tint\t\t\t\t\tonline_processor_count;\n\n\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;\n\tint\t\t\t\t\tcpu_set_count;\n\n#if __SMP__\n\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\tpset_runq;      /* runq for this processor set */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\tpset_runq_bound_count;\n\t\t/* # of threads in runq bound to any processor in pset */\n#endif\n\n\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */\n\tuint64_t\t\t\tpending_AST_cpu_mask;\n#if defined(CONFIG_SCHED_DEFERRED_AST)\n\t/*\n\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on\n\t * some level of support for requesting an AST on a processor, and then quashing\n\t * that request later.\n\t *\n\t * The purpose of this field (and the associated codepaths) is to infer when we\n\t * no longer need a processor that is DISPATCHING to come up, and to prevent it\n\t * from coming out of IDLE if possible.  This should serve to decrease the number\n\t * of spurious ASTs in the system, and let processors spend longer periods in\n\t * IDLE.\n\t */\n\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;\n#endif\n\n\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */\n\tstruct ipc_port *\tpset_name_self;\t/* port for information */\n\n\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */\n\tpset_node_t\t\t\tnode;\n};\n```\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\n","source":"_posts/Mach原语：一起以消息为媒介.md","raw":"---\ntitle: Mach原语：一切以消息为媒介\ndescription: \"在Mach中所有东西（Task、线程、虚拟内存等））都是对象。对象与对象之间通信**只能**通过端口收发消息...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n - Mach\n---\n\n## 1. Mach概述\n### 1.1 Mach设计原则\n- 在Mach中所有东西（Task、线程、虚拟内存等））都是对象。\n- 对象与对象之间通信**只能**通过端口收发消息。\n\n### 1.2 Mach设计目标\n内核为了保持极简，只做如下的事情：\n\n- “控制点”或执行单元的管理。\n- 线程或线程组（Task）的资源分配。\n- 虚拟内存的分配和管理。\n- 底层物理资源--即CPU、内存和任何物理设备的分配。\n\n## 2. Mach消息\n### 2.1 简单消息\n最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：\n\n```\ntypedef\tstruct \n{\n  mach_msg_bits_t\tmsgh_bits;//标志位\n  mach_msg_size_t\tmsgh_size;//大小\n  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）\n  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）\n  mach_port_name_t\tmsgh_voucher_port;\n  mach_msg_id_t\t\tmsgh_id;\n} mach_msg_header_t; //消息头\n\ntypedef struct\n{\n        mach_msg_size_t msgh_descriptor_count;\n} mach_msg_body_t;//消息体\n\ntypedef struct\n{\n        mach_msg_header_t       header;\n        mach_msg_body_t         body;\n} mach_msg_base_t; //基本消息\n\ntypedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型\n\ntypedef struct \n{\n  mach_msg_trailer_type_t\tmsgh_trailer_type;\n  mach_msg_trailer_size_t\tmsgh_trailer_size;\n} mach_msg_trailer_t; //消息尾\n\n```\n\n### 2.2 复杂消息\n将消息头的标志位`mach_msg_bits_t`设置为`MACH_MSGH_BITS_COMPLEX`，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：\n\n```\ntypedef struct\n{\n  uint64_t\t\t\taddress;//数据的大小\n  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配\n  mach_msg_copy_options_t       copy: 8;//复制指令\n  unsigned int     \t\tpad1: 8;\n  mach_msg_descriptor_type_t    type: 8;\n  mach_msg_size_t       \tsize;//数据的大小\n} mach_msg_ool_descriptor64_t;\n\n```\n\n### 2.3 消息收发\n消息的收发在用户态都是通过如下方法进行的：\n\n```\nextern mach_msg_return_t\tmach_msg(\n\t\t\t\t\tmach_msg_header_t *msg,\n\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型\n\t\t\t\t\tmach_msg_size_t send_size,\n\t\t\t\t\tmach_msg_size_t rcv_size,\n\t\t\t\t\tmach_port_name_t rcv_name,\n\t\t\t\t\tmach_msg_timeout_t timeout,\n\t\t\t\t\tmach_port_name_t notify);\t\t\t\t\t\n```\n\n### 2.4 端口\n端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：\n\n```\nstruct ipc_port {\n\n\t/*\n\t * Initial sub-structure in common with ipc_pset\n\t * First element is an ipc_object second is a\n\t * message queue\n\t */\n\tstruct ipc_object ip_object;\n\tstruct ipc_mqueue ip_messages;\n\n\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */\n\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */\n\t\t  ip_impdonation:1,\t/* port supports importance donation */\n\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */\n\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */\n\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */\n\t\t  ip_reserved:2,\n\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */\n\n\tunion {\n\t\tstruct ipc_space *receiver;\n\t\tstruct ipc_port *destination;\n\t\tipc_port_timestamp_t timestamp;\n\t} data;\n\n\tunion {\n\t\tipc_kobject_t kobject;\n\t\tipc_importance_task_t imp_task;\n\t\tuintptr_t alias;\n\t} kdata;\n\t\t\n\tstruct ipc_port *ip_nsrequest;\n\tstruct ipc_port *ip_pdrequest;\n\tstruct ipc_port_request *ip_requests;\n\tstruct ipc_kmsg *ip_premsg;\n\n\tmach_vm_address_t ip_context;\n\n\tmach_port_mscount_t ip_mscount;\n\tmach_port_rights_t ip_srights;\n\tmach_port_rights_t ip_sorights;\n\n#if\tMACH_ASSERT\n#define\tIP_NSPARES\t\t4\n#define\tIP_CALLSTACK_MAX\t16\n/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */\n\tthread_t\tip_thread;\t/* who made me?  thread context */\n\tunsigned long\tip_timetrack;\t/* give an idea of \"when\" created */\n\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */\n\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */\n#endif\t/* MACH_ASSERT */\n} __attribute__((__packed__));\n\n```\n\n### 2.5 Mach接口生成器（MIG）\nMach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些`.defs`文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：\n![IG_opt.png][1]\n\n## 3. 深入IPC\n- Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。\n- 在用户态下，消息传递都是通过`mach_msg()`函数实现的，这个函数会触发一个mach陷阱`mach_msg_trap()`，接下来`mach_msg_trap()`又会调用`mach_msg_overwrite_trap()`，它会通过`MACH_SEND_MSG`和`MACH_RCV_MSG`来判断是发送操作，还是接收操作。\n- 期中内核态中还可以通过`mach_msg_receive()`和`mach_msg_send()`来收发数据。\n\n## 4. 同步原语\n### 4.1 锁的实现方式\n- **阻塞**：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。**当锁可用的时候**，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。\n- **忙等**：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。\n- **阻塞与忙等的对比**：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。\n\n### 4.2 互斥体(lck_mtx_t)（阻塞）\n- 互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。\n- 原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。\n\n### 4.3 信号量(semaphore_t)（阻塞）\n信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。\n\n### 4.4 自旋锁(hw_lock_t)（忙等）\n一种采用忙等形式的锁。\n### 4.5 读写锁(hw_lock_t)（阻塞）\n当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。\n\n### 4.6 锁集(lock_set_t)\n锁集就是锁的一个数组。\n\n## 5. 机器原语\n### 5.1 主机对象（Host）\n主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：\n\n```\nstruct\thost {\n\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */\n\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];\n\tstruct exception_action exc_actions[EXC_TYPES_COUNT];\n};\n```\n\n### 5.2 时钟对象（Clock）\nMach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是`clock_deadline_for_periodic_event（）`，调度器通过它设置了一个重复发生的通知--从而保证了多任务引擎的运转。\n\n### 5.3 处理器对象（Processer）\n在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给**处理器集**，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：\n\n```\nstruct processor {\n\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,\n\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */\n\tint\t\t\t\t\tstate;\t\t\t/* See below */\n\tboolean_t\t\tis_SMT;\n\tboolean_t\t\tis_recommended;\n\tstruct thread\n\t\t\t\t\t\t*active_thread,\t/* thread running on processor */\n\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */\n\t\t\t\t\t\t*idle_thread;\t/* this processor's idle thread. */\n\n\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */\n\n\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */\n\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */\n\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */\n\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */\n\n\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */\n\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */\n\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */\n\n\tuint64_t\t\t\tdeadline;\t\t/* current deadline */\n\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\trunq;\t\t\t/* runq for this processor */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */\n#endif\n#if defined(CONFIG_SCHED_GRRR)\n\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */\n#endif\n\n\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for\n\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer\n\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */\n\tprocessor_t\t\tprocessor_secondary;\n\tstruct ipc_port *\tprocessor_self;\t/* port for operations */\n\n\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */\n\tprocessor_data_t\tprocessor_data;\t/* per-processor data */\n};\n```\n其中最重要的是runq，这是分发到这个处理器的线程队列。\n\n### 5.3 处理器集\n处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：\n\n- `active_queue`：用于保存当前正在执行线程的CPU。\n- `idle_queue`：用于保存当前空闲的CPU（例如：正在执行`idle_thread`）。\n- `pset_runq`：保存了在这个集合中的所有CPU上执行的线程。\n\n`processor_set`的定义如下：\n\n```\nstruct processor_set {\n\tqueue_head_t\t\tactive_queue;\t/* active processors */\n\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */\n\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */\n\n\tint\t\t\t\t\tonline_processor_count;\n\n\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;\n\tint\t\t\t\t\tcpu_set_count;\n\n#if __SMP__\n\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)\n\tstruct run_queue\tpset_runq;      /* runq for this processor set */\n#endif\n\n#if defined(CONFIG_SCHED_TRADITIONAL)\n\tint\t\t\t\t\tpset_runq_bound_count;\n\t\t/* # of threads in runq bound to any processor in pset */\n#endif\n\n\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */\n\tuint64_t\t\t\tpending_AST_cpu_mask;\n#if defined(CONFIG_SCHED_DEFERRED_AST)\n\t/*\n\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on\n\t * some level of support for requesting an AST on a processor, and then quashing\n\t * that request later.\n\t *\n\t * The purpose of this field (and the associated codepaths) is to infer when we\n\t * no longer need a processor that is DISPATCHING to come up, and to prevent it\n\t * from coming out of IDLE if possible.  This should serve to decrease the number\n\t * of spurious ASTs in the system, and let processors spend longer periods in\n\t * IDLE.\n\t */\n\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;\n#endif\n\n\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */\n\tstruct ipc_port *\tpset_name_self;\t/* port for information */\n\n\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */\n\tpset_node_t\t\t\tnode;\n};\n```\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\n","slug":"Mach原语：一起以消息为媒介","published":1,"date":"2016-11-15T09:30:40.000Z","updated":"2016-11-15T09:30:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3w000pgivbw8zziifx","content":"<h2 id=\"1-Mach概述\"><a href=\"#1-Mach概述\" class=\"headerlink\" title=\"1. Mach概述\"></a>1. Mach概述</h2><h3 id=\"1-1-Mach设计原则\"><a href=\"#1-1-Mach设计原则\" class=\"headerlink\" title=\"1.1 Mach设计原则\"></a>1.1 Mach设计原则</h3><ul>\n<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>\n<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>\n</ul>\n<h3 id=\"1-2-Mach设计目标\"><a href=\"#1-2-Mach设计目标\" class=\"headerlink\" title=\"1.2 Mach设计目标\"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>\n<ul>\n<li>“控制点”或执行单元的管理。</li>\n<li>线程或线程组（Task）的资源分配。</li>\n<li>虚拟内存的分配和管理。</li>\n<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>\n</ul>\n<h2 id=\"2-Mach消息\"><a href=\"#2-Mach消息\" class=\"headerlink\" title=\"2. Mach消息\"></a>2. Mach消息</h2><h3 id=\"2-1-简单消息\"><a href=\"#2-1-简单消息\" class=\"headerlink\" title=\"2.1 简单消息\"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef\tstruct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_bits_t\tmsgh_bits;//标志位</div><div class=\"line\">  mach_msg_size_t\tmsgh_size;//大小</div><div class=\"line\">  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class=\"line\">  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class=\"line\">  mach_port_name_t\tmsgh_voucher_port;</div><div class=\"line\">  mach_msg_id_t\t\tmsgh_id;</div><div class=\"line\">&#125; mach_msg_header_t; //消息头</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_size_t msgh_descriptor_count;</div><div class=\"line\">&#125; mach_msg_body_t;//消息体</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_header_t       header;</div><div class=\"line\">        mach_msg_body_t         body;</div><div class=\"line\">&#125; mach_msg_base_t; //基本消息</div><div class=\"line\"></div><div class=\"line\">typedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class=\"line\"></div><div class=\"line\">typedef struct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_trailer_type_t\tmsgh_trailer_type;</div><div class=\"line\">  mach_msg_trailer_size_t\tmsgh_trailer_size;</div><div class=\"line\">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-复杂消息\"><a href=\"#2-2-复杂消息\" class=\"headerlink\" title=\"2.2 复杂消息\"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">  uint64_t\t\t\taddress;//数据的大小</div><div class=\"line\">  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配</div><div class=\"line\">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class=\"line\">  unsigned int     \t\tpad1: 8;</div><div class=\"line\">  mach_msg_descriptor_type_t    type: 8;</div><div class=\"line\">  mach_msg_size_t       \tsize;//数据的大小</div><div class=\"line\">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>\n<h3 id=\"2-3-消息收发\"><a href=\"#2-3-消息收发\" class=\"headerlink\" title=\"2.3 消息收发\"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern mach_msg_return_t\tmach_msg(</div><div class=\"line\">\t\t\t\t\tmach_msg_header_t *msg,</div><div class=\"line\">\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t send_size,</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t rcv_size,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t rcv_name,</div><div class=\"line\">\t\t\t\t\tmach_msg_timeout_t timeout,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t notify);</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-端口\"><a href=\"#2-4-端口\" class=\"headerlink\" title=\"2.4 端口\"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ipc_port &#123;</div><div class=\"line\"></div><div class=\"line\">\t/*</div><div class=\"line\">\t * Initial sub-structure in common with ipc_pset</div><div class=\"line\">\t * First element is an ipc_object second is a</div><div class=\"line\">\t * message queue</div><div class=\"line\">\t */</div><div class=\"line\">\tstruct ipc_object ip_object;</div><div class=\"line\">\tstruct ipc_mqueue ip_messages;</div><div class=\"line\"></div><div class=\"line\">\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */</div><div class=\"line\">\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */</div><div class=\"line\">\t\t  ip_impdonation:1,\t/* port supports importance donation */</div><div class=\"line\">\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */</div><div class=\"line\">\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class=\"line\">\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */</div><div class=\"line\">\t\t  ip_reserved:2,</div><div class=\"line\">\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tstruct ipc_space *receiver;</div><div class=\"line\">\t\tstruct ipc_port *destination;</div><div class=\"line\">\t\tipc_port_timestamp_t timestamp;</div><div class=\"line\">\t&#125; data;</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tipc_kobject_t kobject;</div><div class=\"line\">\t\tipc_importance_task_t imp_task;</div><div class=\"line\">\t\tuintptr_t alias;</div><div class=\"line\">\t&#125; kdata;</div><div class=\"line\">\t\t</div><div class=\"line\">\tstruct ipc_port *ip_nsrequest;</div><div class=\"line\">\tstruct ipc_port *ip_pdrequest;</div><div class=\"line\">\tstruct ipc_port_request *ip_requests;</div><div class=\"line\">\tstruct ipc_kmsg *ip_premsg;</div><div class=\"line\"></div><div class=\"line\">\tmach_vm_address_t ip_context;</div><div class=\"line\"></div><div class=\"line\">\tmach_port_mscount_t ip_mscount;</div><div class=\"line\">\tmach_port_rights_t ip_srights;</div><div class=\"line\">\tmach_port_rights_t ip_sorights;</div><div class=\"line\"></div><div class=\"line\">#if\tMACH_ASSERT</div><div class=\"line\">#define\tIP_NSPARES\t\t4</div><div class=\"line\">#define\tIP_CALLSTACK_MAX\t16</div><div class=\"line\">/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */</div><div class=\"line\">\tthread_t\tip_thread;\t/* who made me?  thread context */</div><div class=\"line\">\tunsigned long\tip_timetrack;\t/* give an idea of &quot;when&quot; created */</div><div class=\"line\">\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class=\"line\">\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */</div><div class=\"line\">#endif\t/* MACH_ASSERT */</div><div class=\"line\">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>\n<h3 id=\"2-5-Mach接口生成器（MIG）\"><a href=\"#2-5-Mach接口生成器（MIG）\" class=\"headerlink\" title=\"2.5 Mach接口生成器（MIG）\"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\" alt=\"IG_opt.png\"></p>\n<h2 id=\"3-深入IPC\"><a href=\"#3-深入IPC\" class=\"headerlink\" title=\"3. 深入IPC\"></a>3. 深入IPC</h2><ul>\n<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>\n<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>\n<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>\n</ul>\n<h2 id=\"4-同步原语\"><a href=\"#4-同步原语\" class=\"headerlink\" title=\"4. 同步原语\"></a>4. 同步原语</h2><h3 id=\"4-1-锁的实现方式\"><a href=\"#4-1-锁的实现方式\" class=\"headerlink\" title=\"4.1 锁的实现方式\"></a>4.1 锁的实现方式</h3><ul>\n<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>\n<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>\n<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>\n</ul>\n<h3 id=\"4-2-互斥体-lck-mtx-t-（阻塞）\"><a href=\"#4-2-互斥体-lck-mtx-t-（阻塞）\" class=\"headerlink\" title=\"4.2 互斥体(lck_mtx_t)（阻塞）\"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>\n<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>\n<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>\n</ul>\n<h3 id=\"4-3-信号量-semaphore-t-（阻塞）\"><a href=\"#4-3-信号量-semaphore-t-（阻塞）\" class=\"headerlink\" title=\"4.3 信号量(semaphore_t)（阻塞）\"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>\n<h3 id=\"4-4-自旋锁-hw-lock-t-（忙等）\"><a href=\"#4-4-自旋锁-hw-lock-t-（忙等）\" class=\"headerlink\" title=\"4.4 自旋锁(hw_lock_t)（忙等）\"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>\n<h3 id=\"4-5-读写锁-hw-lock-t-（阻塞）\"><a href=\"#4-5-读写锁-hw-lock-t-（阻塞）\" class=\"headerlink\" title=\"4.5 读写锁(hw_lock_t)（阻塞）\"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>\n<h3 id=\"4-6-锁集-lock-set-t\"><a href=\"#4-6-锁集-lock-set-t\" class=\"headerlink\" title=\"4.6 锁集(lock_set_t)\"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>\n<h2 id=\"5-机器原语\"><a href=\"#5-机器原语\" class=\"headerlink\" title=\"5. 机器原语\"></a>5. 机器原语</h2><h3 id=\"5-1-主机对象（Host）\"><a href=\"#5-1-主机对象（Host）\" class=\"headerlink\" title=\"5.1 主机对象（Host）\"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct\thost &#123;</div><div class=\"line\">\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */</div><div class=\"line\">\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class=\"line\">\tstruct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"5-2-时钟对象（Clock）\"><a href=\"#5-2-时钟对象（Clock）\" class=\"headerlink\" title=\"5.2 时钟对象（Clock）\"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>\n<h3 id=\"5-3-处理器对象（Processer）\"><a href=\"#5-3-处理器对象（Processer）\" class=\"headerlink\" title=\"5.3 处理器对象（Processer）\"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor &#123;</div><div class=\"line\">\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */</div><div class=\"line\">\tint\t\t\t\t\tstate;\t\t\t/* See below */</div><div class=\"line\">\tboolean_t\t\tis_SMT;</div><div class=\"line\">\tboolean_t\t\tis_recommended;</div><div class=\"line\">\tstruct thread</div><div class=\"line\">\t\t\t\t\t\t*active_thread,\t/* thread running on processor */</div><div class=\"line\">\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */</div><div class=\"line\">\t\t\t\t\t\t*idle_thread;\t/* this processor&apos;s idle thread. */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */</div><div class=\"line\">\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */</div><div class=\"line\">\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */</div><div class=\"line\">\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */</div><div class=\"line\"></div><div class=\"line\">\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */</div><div class=\"line\">\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */</div><div class=\"line\">\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */</div><div class=\"line\"></div><div class=\"line\">\tuint64_t\t\t\tdeadline;\t\t/* current deadline */</div><div class=\"line\">\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\trunq;\t\t\t/* runq for this processor */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */</div><div class=\"line\">#endif</div><div class=\"line\">#if defined(CONFIG_SCHED_GRRR)</div><div class=\"line\">\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */</div><div class=\"line\">\tprocessor_t\t\tprocessor_secondary;</div><div class=\"line\">\tstruct ipc_port *\tprocessor_self;\t/* port for operations */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */</div><div class=\"line\">\tprocessor_data_t\tprocessor_data;\t/* per-processor data */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>\n<h3 id=\"5-3-处理器集\"><a href=\"#5-3-处理器集\" class=\"headerlink\" title=\"5.3 处理器集\"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>\n<ul>\n<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>\n<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>\n<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>\n</ul>\n<p><code>processor_set</code>的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor_set &#123;</div><div class=\"line\">\tqueue_head_t\t\tactive_queue;\t/* active processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tonline_processor_count;</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;</div><div class=\"line\">\tint\t\t\t\t\tcpu_set_count;</div><div class=\"line\"></div><div class=\"line\">#if __SMP__</div><div class=\"line\">\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\tpset_runq;      /* runq for this processor set */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\tpset_runq_bound_count;</div><div class=\"line\">\t\t/* # of threads in runq bound to any processor in pset */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class=\"line\">\tuint64_t\t\t\tpending_AST_cpu_mask;</div><div class=\"line\">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class=\"line\">\t/*</div><div class=\"line\">\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class=\"line\">\t * some level of support for requesting an AST on a processor, and then quashing</div><div class=\"line\">\t * that request later.</div><div class=\"line\">\t *</div><div class=\"line\">\t * The purpose of this field (and the associated codepaths) is to infer when we</div><div class=\"line\">\t * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class=\"line\">\t * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class=\"line\">\t * of spurious ASTs in the system, and let processors spend longer periods in</div><div class=\"line\">\t * IDLE.</div><div class=\"line\">\t */</div><div class=\"line\">\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */</div><div class=\"line\">\tstruct ipc_port *\tpset_name_self;\t/* port for information */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */</div><div class=\"line\">\tpset_node_t\t\t\tnode;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<hr>\n","excerpt":"","more":"<h2 id=\"1-Mach概述\"><a href=\"#1-Mach概述\" class=\"headerlink\" title=\"1. Mach概述\"></a>1. Mach概述</h2><h3 id=\"1-1-Mach设计原则\"><a href=\"#1-1-Mach设计原则\" class=\"headerlink\" title=\"1.1 Mach设计原则\"></a>1.1 Mach设计原则</h3><ul>\n<li>在Mach中所有东西（Task、线程、虚拟内存等））都是对象。</li>\n<li>对象与对象之间通信<strong>只能</strong>通过端口收发消息。</li>\n</ul>\n<h3 id=\"1-2-Mach设计目标\"><a href=\"#1-2-Mach设计目标\" class=\"headerlink\" title=\"1.2 Mach设计目标\"></a>1.2 Mach设计目标</h3><p>内核为了保持极简，只做如下的事情：</p>\n<ul>\n<li>“控制点”或执行单元的管理。</li>\n<li>线程或线程组（Task）的资源分配。</li>\n<li>虚拟内存的分配和管理。</li>\n<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>\n</ul>\n<h2 id=\"2-Mach消息\"><a href=\"#2-Mach消息\" class=\"headerlink\" title=\"2. Mach消息\"></a>2. Mach消息</h2><h3 id=\"2-1-简单消息\"><a href=\"#2-1-简单消息\" class=\"headerlink\" title=\"2.1 简单消息\"></a>2.1 简单消息</h3><p>最基本的包含两部分：消息头、消息体。可以选择性的添加消息尾。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef\tstruct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_bits_t\tmsgh_bits;//标志位</div><div class=\"line\">  mach_msg_size_t\tmsgh_size;//大小</div><div class=\"line\">  mach_port_t\t\tmsgh_remote_port;//目标端口（发送：接受方，接收：发送方）</div><div class=\"line\">  mach_port_t\t\tmsgh_local_port; //源端口（发送：发送方，接收：接收方）</div><div class=\"line\">  mach_port_name_t\tmsgh_voucher_port;</div><div class=\"line\">  mach_msg_id_t\t\tmsgh_id;</div><div class=\"line\">&#125; mach_msg_header_t; //消息头</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_size_t msgh_descriptor_count;</div><div class=\"line\">&#125; mach_msg_body_t;//消息体</div><div class=\"line\"></div><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">        mach_msg_header_t       header;</div><div class=\"line\">        mach_msg_body_t         body;</div><div class=\"line\">&#125; mach_msg_base_t; //基本消息</div><div class=\"line\"></div><div class=\"line\">typedef\tunsigned int mach_msg_trailer_type_t;//消息尾的类型</div><div class=\"line\"></div><div class=\"line\">typedef struct </div><div class=\"line\">&#123;</div><div class=\"line\">  mach_msg_trailer_type_t\tmsgh_trailer_type;</div><div class=\"line\">  mach_msg_trailer_size_t\tmsgh_trailer_size;</div><div class=\"line\">&#125; mach_msg_trailer_t; //消息尾</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-复杂消息\"><a href=\"#2-2-复杂消息\" class=\"headerlink\" title=\"2.2 复杂消息\"></a>2.2 复杂消息</h3><p>将消息头的标志位<code>mach_msg_bits_t</code>设置为<code>MACH_MSGH_BITS_COMPLEX</code>，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct</div><div class=\"line\">&#123;</div><div class=\"line\">  uint64_t\t\t\taddress;//数据的大小</div><div class=\"line\">  boolean_t     \t\tdeallocate: 8;//发送之后是否接触分配</div><div class=\"line\">  mach_msg_copy_options_t       copy: 8;//复制指令</div><div class=\"line\">  unsigned int     \t\tpad1: 8;</div><div class=\"line\">  mach_msg_descriptor_type_t    type: 8;</div><div class=\"line\">  mach_msg_size_t       \tsize;//数据的大小</div><div class=\"line\">&#125; mach_msg_ool_descriptor64_t;</div></pre></td></tr></table></figure>\n<h3 id=\"2-3-消息收发\"><a href=\"#2-3-消息收发\" class=\"headerlink\" title=\"2.3 消息收发\"></a>2.3 消息收发</h3><p>消息的收发在用户态都是通过如下方法进行的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">extern mach_msg_return_t\tmach_msg(</div><div class=\"line\">\t\t\t\t\tmach_msg_header_t *msg,</div><div class=\"line\">\t\t\t\t\tmach_msg_option_t option,//可以设置为收消息还是发消息等类型</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t send_size,</div><div class=\"line\">\t\t\t\t\tmach_msg_size_t rcv_size,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t rcv_name,</div><div class=\"line\">\t\t\t\t\tmach_msg_timeout_t timeout,</div><div class=\"line\">\t\t\t\t\tmach_port_name_t notify);</div></pre></td></tr></table></figure>\n<h3 id=\"2-4-端口\"><a href=\"#2-4-端口\" class=\"headerlink\" title=\"2.4 端口\"></a>2.4 端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct ipc_port &#123;</div><div class=\"line\"></div><div class=\"line\">\t/*</div><div class=\"line\">\t * Initial sub-structure in common with ipc_pset</div><div class=\"line\">\t * First element is an ipc_object second is a</div><div class=\"line\">\t * message queue</div><div class=\"line\">\t */</div><div class=\"line\">\tstruct ipc_object ip_object;</div><div class=\"line\">\tstruct ipc_mqueue ip_messages;</div><div class=\"line\"></div><div class=\"line\">\tnatural_t ip_sprequests:1,\t/* send-possible requests outstanding */</div><div class=\"line\">\t\t  ip_spimportant:1,\t/* ... at least one is importance donating */</div><div class=\"line\">\t\t  ip_impdonation:1,\t/* port supports importance donation */</div><div class=\"line\">\t\t  ip_tempowner:1,\t/* dont give donations to current receiver */</div><div class=\"line\">\t\t  ip_guarded:1,         /* port guarded (use context value as guard) */</div><div class=\"line\">\t\t  ip_strict_guard:1,\t/* Strict guarding; Prevents user manipulation of context values directly */</div><div class=\"line\">\t\t  ip_reserved:2,</div><div class=\"line\">\t\t  ip_impcount:24;\t/* number of importance donations in nested queue */</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tstruct ipc_space *receiver;</div><div class=\"line\">\t\tstruct ipc_port *destination;</div><div class=\"line\">\t\tipc_port_timestamp_t timestamp;</div><div class=\"line\">\t&#125; data;</div><div class=\"line\"></div><div class=\"line\">\tunion &#123;</div><div class=\"line\">\t\tipc_kobject_t kobject;</div><div class=\"line\">\t\tipc_importance_task_t imp_task;</div><div class=\"line\">\t\tuintptr_t alias;</div><div class=\"line\">\t&#125; kdata;</div><div class=\"line\">\t\t</div><div class=\"line\">\tstruct ipc_port *ip_nsrequest;</div><div class=\"line\">\tstruct ipc_port *ip_pdrequest;</div><div class=\"line\">\tstruct ipc_port_request *ip_requests;</div><div class=\"line\">\tstruct ipc_kmsg *ip_premsg;</div><div class=\"line\"></div><div class=\"line\">\tmach_vm_address_t ip_context;</div><div class=\"line\"></div><div class=\"line\">\tmach_port_mscount_t ip_mscount;</div><div class=\"line\">\tmach_port_rights_t ip_srights;</div><div class=\"line\">\tmach_port_rights_t ip_sorights;</div><div class=\"line\"></div><div class=\"line\">#if\tMACH_ASSERT</div><div class=\"line\">#define\tIP_NSPARES\t\t4</div><div class=\"line\">#define\tIP_CALLSTACK_MAX\t16</div><div class=\"line\">/*\tqueue_chain_t\tip_port_links;*//* all allocated ports */</div><div class=\"line\">\tthread_t\tip_thread;\t/* who made me?  thread context */</div><div class=\"line\">\tunsigned long\tip_timetrack;\t/* give an idea of &quot;when&quot; created */</div><div class=\"line\">\tuintptr_t\tip_callstack[IP_CALLSTACK_MAX]; /* stack trace */</div><div class=\"line\">\tunsigned long\tip_spares[IP_NSPARES]; /* for debugging */</div><div class=\"line\">#endif\t/* MACH_ASSERT */</div><div class=\"line\">&#125; __attribute__((__packed__));</div></pre></td></tr></table></figure>\n<h3 id=\"2-5-Mach接口生成器（MIG）\"><a href=\"#2-5-Mach接口生成器（MIG）\" class=\"headerlink\" title=\"2.5 Mach接口生成器（MIG）\"></a>2.5 Mach接口生成器（MIG）</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些<code>.defs</code>文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/MIG_opt.png?raw=true\" alt=\"IG_opt.png\"></p>\n<h2 id=\"3-深入IPC\"><a href=\"#3-深入IPC\" class=\"headerlink\" title=\"3. 深入IPC\"></a>3. 深入IPC</h2><ul>\n<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>\n<li>在用户态下，消息传递都是通过<code>mach_msg()</code>函数实现的，这个函数会触发一个mach陷阱<code>mach_msg_trap()</code>，接下来<code>mach_msg_trap()</code>又会调用<code>mach_msg_overwrite_trap()</code>，它会通过<code>MACH_SEND_MSG</code>和<code>MACH_RCV_MSG</code>来判断是发送操作，还是接收操作。</li>\n<li>期中内核态中还可以通过<code>mach_msg_receive()</code>和<code>mach_msg_send()</code>来收发数据。</li>\n</ul>\n<h2 id=\"4-同步原语\"><a href=\"#4-同步原语\" class=\"headerlink\" title=\"4. 同步原语\"></a>4. 同步原语</h2><h3 id=\"4-1-锁的实现方式\"><a href=\"#4-1-锁的实现方式\" class=\"headerlink\" title=\"4.1 锁的实现方式\"></a>4.1 锁的实现方式</h3><ul>\n<li><strong>阻塞</strong>：如果锁对象被其他线程所持有，那么请求访问的线程就会被加入到等待队列中，因而被阻塞。这就意味着被阻塞的线程放弃了时间片，调度器会将CPU让给下一个执行的的线程。<strong>当锁可用的时候</strong>，调度器会得到通知，然后根据情况将线程从等待队列取出来，并重新调度。</li>\n<li><strong>忙等</strong>：线程不放弃CPU时间片，而是继续重复的尝试访问所对，直到锁可用。</li>\n<li><strong>阻塞与忙等的对比</strong>：当锁只持续短短几个周期的时候，阻塞会带来性能问题，因为至少会消耗两次上下文切换的时间。因此如果锁的持续时间短，应该采用忙等形式的锁对象，反之就采用阻塞形式的锁对象。</li>\n</ul>\n<h3 id=\"4-2-互斥体-lck-mtx-t-（阻塞）\"><a href=\"#4-2-互斥体-lck-mtx-t-（阻塞）\" class=\"headerlink\" title=\"4.2 互斥体(lck_mtx_t)（阻塞）\"></a>4.2 互斥体(lck_mtx_t)（阻塞）</h3><ul>\n<li>互斥体其实就是一个内核中的一个不同的变量，通常是机器字节大小的整数，但是必须要求硬件能对这些变量进行原子操作。</li>\n<li>原子的意思就是：对互斥体的操作不能打断，即使是硬件中断也不能打断。</li>\n</ul>\n<h3 id=\"4-3-信号量-semaphore-t-（阻塞）\"><a href=\"#4-3-信号量-semaphore-t-（阻塞）\" class=\"headerlink\" title=\"4.3 信号量(semaphore_t)（阻塞）\"></a>4.3 信号量(semaphore_t)（阻塞）</h3><p>信号量在初始化的时候可以设置一个大于零的初始值。信号量包含两个操作：一个是+1操作，一个是-1操作，当值大于0表示锁可用，当值小于等于0的时候表示锁不可用。互斥体可以看做是初始值为1的信号量。</p>\n<h3 id=\"4-4-自旋锁-hw-lock-t-（忙等）\"><a href=\"#4-4-自旋锁-hw-lock-t-（忙等）\" class=\"headerlink\" title=\"4.4 自旋锁(hw_lock_t)（忙等）\"></a>4.4 自旋锁(hw_lock_t)（忙等）</h3><p>一种采用忙等形式的锁。</p>\n<h3 id=\"4-5-读写锁-hw-lock-t-（阻塞）\"><a href=\"#4-5-读写锁-hw-lock-t-（阻塞）\" class=\"headerlink\" title=\"4.5 读写锁(hw_lock_t)（阻塞）\"></a>4.5 读写锁(hw_lock_t)（阻塞）</h3><p>当多个线程对资源只做只读的操作，这种情况下这些线程并不会相互影响。为了提高效率，读写锁就应运而生了。读写锁能够区分是读访问还是写访问，对个读者可以同时持有锁，但一次只能一个写者持有锁。</p>\n<h3 id=\"4-6-锁集-lock-set-t\"><a href=\"#4-6-锁集-lock-set-t\" class=\"headerlink\" title=\"4.6 锁集(lock_set_t)\"></a>4.6 锁集(lock_set_t)</h3><p>锁集就是锁的一个数组。</p>\n<h2 id=\"5-机器原语\"><a href=\"#5-机器原语\" class=\"headerlink\" title=\"5. 机器原语\"></a>5. 机器原语</h2><h3 id=\"5-1-主机对象（Host）\"><a href=\"#5-1-主机对象（Host）\" class=\"headerlink\" title=\"5.1 主机对象（Host）\"></a>5.1 主机对象（Host）</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct\thost &#123;</div><div class=\"line\">\tdecl_lck_mtx_data(,lock)\t\t/* lock to protect exceptions */</div><div class=\"line\">\tipc_port_t special[HOST_MAX_SPECIAL_PORT + 1];</div><div class=\"line\">\tstruct exception_action exc_actions[EXC_TYPES_COUNT];</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"5-2-时钟对象（Clock）\"><a href=\"#5-2-时钟对象（Clock）\" class=\"headerlink\" title=\"5.2 时钟对象（Clock）\"></a>5.2 时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是<code>clock_deadline_for_periodic_event（）</code>，调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>\n<h3 id=\"5-3-处理器对象（Processer）\"><a href=\"#5-3-处理器对象（Processer）\" class=\"headerlink\" title=\"5.3 处理器对象（Processer）\"></a>5.3 处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给<strong>处理器集</strong>，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor &#123;</div><div class=\"line\">\tqueue_chain_t\t\tprocessor_queue;/* idle/active queue link,</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t * MUST remain the first element */</div><div class=\"line\">\tint\t\t\t\t\tstate;\t\t\t/* See below */</div><div class=\"line\">\tboolean_t\t\tis_SMT;</div><div class=\"line\">\tboolean_t\t\tis_recommended;</div><div class=\"line\">\tstruct thread</div><div class=\"line\">\t\t\t\t\t\t*active_thread,\t/* thread running on processor */</div><div class=\"line\">\t\t\t\t\t\t*next_thread,\t/* next thread when dispatched */</div><div class=\"line\">\t\t\t\t\t\t*idle_thread;\t/* this processor&apos;s idle thread. */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tprocessor_set;\t/* assigned set */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcurrent_pri;\t/* priority of current thread */</div><div class=\"line\">\tsched_mode_t\t\tcurrent_thmode;\t/* sched mode of current thread */</div><div class=\"line\">\tsfi_class_id_t\t\tcurrent_sfi_class;\t/* SFI class of current thread */</div><div class=\"line\">\tint\t\t\t\t\tcpu_id;\t\t\t/* platform numeric id */</div><div class=\"line\"></div><div class=\"line\">\ttimer_call_data_t\tquantum_timer;\t/* timer for quantum expiration */</div><div class=\"line\">\tuint64_t\t\t\tquantum_end;\t/* time when current quantum ends */</div><div class=\"line\">\tuint64_t\t\t\tlast_dispatch;\t/* time of last dispatch */</div><div class=\"line\"></div><div class=\"line\">\tuint64_t\t\t\tdeadline;\t\t/* current deadline */</div><div class=\"line\">\tboolean_t               first_timeslice;                /* has the quantum expired since context switch */</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\trunq;\t\t\t/* runq for this processor */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\trunq_bound_count; /* # of threads bound to this processor */</div><div class=\"line\">#endif</div><div class=\"line\">#if defined(CONFIG_SCHED_GRRR)</div><div class=\"line\">\tstruct grrr_run_queue\tgrrr_runq;      /* Group Ratio Round-Robin runq */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_primary;\t/* pointer to primary processor for</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * secondary SMT processors, or a pointer</div><div class=\"line\">\t\t\t\t\t\t\t\t\t\t\t * to ourselves for primaries or non-SMT */</div><div class=\"line\">\tprocessor_t\t\tprocessor_secondary;</div><div class=\"line\">\tstruct ipc_port *\tprocessor_self;\t/* port for operations */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_t\t\t\tprocessor_list;\t/* all existing processors */</div><div class=\"line\">\tprocessor_data_t\tprocessor_data;\t/* per-processor data */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>\n<h3 id=\"5-3-处理器集\"><a href=\"#5-3-处理器集\" class=\"headerlink\" title=\"5.3 处理器集\"></a>5.3 处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>\n<ul>\n<li><code>active_queue</code>：用于保存当前正在执行线程的CPU。</li>\n<li><code>idle_queue</code>：用于保存当前空闲的CPU（例如：正在执行<code>idle_thread</code>）。</li>\n<li><code>pset_runq</code>：保存了在这个集合中的所有CPU上执行的线程。</li>\n</ul>\n<p><code>processor_set</code>的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct processor_set &#123;</div><div class=\"line\">\tqueue_head_t\t\tactive_queue;\t/* active processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_queue;\t\t/* idle processors */</div><div class=\"line\">\tqueue_head_t\t\tidle_secondary_queue;\t\t/* idle secondary processors */</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tonline_processor_count;</div><div class=\"line\"></div><div class=\"line\">\tint\t\t\t\t\tcpu_set_low, cpu_set_hi;</div><div class=\"line\">\tint\t\t\t\t\tcpu_set_count;</div><div class=\"line\"></div><div class=\"line\">#if __SMP__</div><div class=\"line\">\tdecl_simple_lock_data(,sched_lock)\t/* lock for above */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</div><div class=\"line\">\tstruct run_queue\tpset_runq;      /* runq for this processor set */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">#if defined(CONFIG_SCHED_TRADITIONAL)</div><div class=\"line\">\tint\t\t\t\t\tpset_runq_bound_count;</div><div class=\"line\">\t\t/* # of threads in runq bound to any processor in pset */</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\t/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</div><div class=\"line\">\tuint64_t\t\t\tpending_AST_cpu_mask;</div><div class=\"line\">#if defined(CONFIG_SCHED_DEFERRED_AST)</div><div class=\"line\">\t/*</div><div class=\"line\">\t * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</div><div class=\"line\">\t * some level of support for requesting an AST on a processor, and then quashing</div><div class=\"line\">\t * that request later.</div><div class=\"line\">\t *</div><div class=\"line\">\t * The purpose of this field (and the associated codepaths) is to infer when we</div><div class=\"line\">\t * no longer need a processor that is DISPATCHING to come up, and to prevent it</div><div class=\"line\">\t * from coming out of IDLE if possible.  This should serve to decrease the number</div><div class=\"line\">\t * of spurious ASTs in the system, and let processors spend longer periods in</div><div class=\"line\">\t * IDLE.</div><div class=\"line\">\t */</div><div class=\"line\">\tuint64_t\t\t\tpending_deferred_AST_cpu_mask;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">\tstruct ipc_port\t*\tpset_self;\t\t/* port for operations */</div><div class=\"line\">\tstruct ipc_port *\tpset_name_self;\t/* port for information */</div><div class=\"line\"></div><div class=\"line\">\tprocessor_set_t\t\tpset_list;\t\t/* chain of associated psets */</div><div class=\"line\">\tpset_node_t\t\t\tnode;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<hr>\n"},{"title":"Mach-O格式文件(用户态下的进程加载)","description":"内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有...","_content":"\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Mach-O格式文件(用户态下的进程加载).md","raw":"---\ntitle: Mach-O格式文件(用户态下的进程加载)\ndescription: \"内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - Mach\n---\n\n## Mach-O二进制文件\nMach-O的文件头包含的内容:\n\n- 魔数\n- CPU类型及其子类型\n- 文件类型\n- 用于加载器的“加载命令”的条数和大小\n- 动态链接器的标志\n\n> 使用`otool -h /bin/ls`来查看Mach-O的文件头。\n\n## Mach-O的加载命令\n内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：\n\n- LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）\n - 代码段（__TEXT）、数据段(__DATA)、用户动态链接的桩(__stubs、__stub_helper)、主程序代码(__text)\n- LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)\n- LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)\n- LC_CODE_SIGNATURE(代码签名)\n\n> `otool`可以用来可以用来分析加载命令和代码段，如：`otool -l /bin/ls`\n\n## 动态库\n### 动态链接\n少量的进程只需要`内核加载器`就能完成加载，OSX中几乎所有的程序都是动态链接的--即填补对外部库和符号的引用。这个工作是由`动态链接器`来完成。该过程也被称为`符号绑定`。这个过程大概是这样的：\n> \n如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用--即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。\n\n链接一般都是递归的，因为库也有可能引用其他的库。\n\n### 共享库缓存（shared library cache）\n共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。\n> \n在OS X中dyld共享缓存保存在`/private/var/db/dyld`目录下。在iOS中则保存在`/System/Library/Caches/com.apple.dyld`.\n\n### 运行时加载\n一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过`<dlfcn.h>`头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：\n\n- dlopen(const char *path)\n- dlopen_preflight(const char *path)\n- dlsym(void *handle ,char *sym)\n- dladdr(char *addr , DL_Info *info)\n- dlerror()\n\nCocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。\n\n### 弱定义的符号\n- 通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。\n- 可以使用`__attribute__(weak_import)`将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。\n\n> 使用`nm -m xxx.dylib`可以显示弱符号。\n\n## dyld的特性\n### 两级命名空间\n- 通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。\n- 可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。\n\n### 函数拦截\n- DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：\n```\nDYLD_INTERPOSE(my_open ,open)\n```\n- dyld的函数拦截功能提供一个新的__DATA区，名为__interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：\n```\nstatic const interpose_t interposing_functions[] \\\n    __attribute__(section(\"__DATA,__interpose\")) = {\n        {(void *)my_free , (void *)free },\n        {(void *)my_malloc , (void *) malloc },\n    };\n```\n完整代码：\n```\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <malloc/malloc.h> // for malloc_printf()\n\n// Note: Compile with GCC, not cc (important)\n//\n//\n// This is the expected interpose structure\n typedef struct interpose_s { void *new_func;\n\t\t\t       void *orig_func; } interpose_t;\n// Our prototypes - requires since we are putting them in \n//  the interposing_functions, below\n\nvoid *my_malloc(int size); // matches real malloc()\nvoid my_free (void *); // matches real free()\n\n// For clang, add attribute(used)\nstatic const interpose_t interposing_functions[] \\ \n    __attribute__ ((used, section(\"__DATA, __interpose\"))) = {\n\n { (void *)my_free, (void *)free },\n { (void *)my_malloc, (void *)malloc } \n\n};\n\nvoid *\nmy_malloc (int size) {\n // In our function we have access to the real malloc() -\n // and since we don’t want to mess with the heap ourselves,\n // just call it\n //\nvoid *returned = malloc(size);\n// call malloc_printf() because the real printf() calls malloc()\n// // internally - and would end up calling us, recursing ad infinitum\n\n  malloc_printf ( \"+ %p %d\\n\", returned, size); return (returned);\n}\nvoid\nmy_free (void *freed) {\n// Free - just print the address, then call the real free()\n\n\n  malloc_printf ( \"- %p\\n\", freed); free(freed);\n}\n\n\n\n#if 0\n  From output 4-11:\n\n morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib\n morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls\n ls(24346) malloc: + 0x100100020 88\n ls(24346) malloc: + 0x100800000 4096\n ls(24346) malloc: + 0x100801000 2160 \n ls(24346) malloc: - 0x100800000 \n ls(24346) malloc: + 0x100801a00 3312 ... // etc.\n\n#endif\n```\n> 使用`pagestuff`命令可以显示文件逻辑页中的符号。如：`pagestuff /usr/lib/libgmalloc.dylib 6`,\n\n## 进程的地址空间\n- 每一个进程都有自己私有的虚拟地址空间。\n- 32位地址空间，用户态可访问整个4G的内存空间。\n- 64位的地址允许高达16EB（16GGB）\n- 现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。\n> 使用`vmmap`命令来查看内存的空间布局，可以加上参数`-interleaved`以清晰的方式导出地址空间。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Mach-O格式文件(用户态下的进程加载)","published":1,"date":"2016-11-15T09:31:01.000Z","updated":"2016-11-15T09:31:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3x000sgivbg9v91mgn","content":"<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Mach-O二进制文件\"><a href=\"#Mach-O二进制文件\" class=\"headerlink\" title=\"Mach-O二进制文件\"></a>Mach-O二进制文件</h2><p>Mach-O的文件头包含的内容:</p>\n<ul>\n<li>魔数</li>\n<li>CPU类型及其子类型</li>\n<li>文件类型</li>\n<li>用于加载器的“加载命令”的条数和大小</li>\n<li>动态链接器的标志</li>\n</ul>\n<blockquote>\n<p>使用<code>otool -h /bin/ls</code>来查看Mach-O的文件头。</p>\n</blockquote>\n<h2 id=\"Mach-O的加载命令\"><a href=\"#Mach-O的加载命令\" class=\"headerlink\" title=\"Mach-O的加载命令\"></a>Mach-O的加载命令</h2><p>内核加载器会在加载的过程中使用这些命令来对进程进行一些设置：包括分配虚拟内存、创建主线程、启动动态链接器以及处理代码签名等工作。重要的命令有：</p>\n<ul>\n<li>LC_SEGMENT或者LC_SEGMENT_64（设置进程的内存空间）<ul>\n<li>代码段（<strong>TEXT）、数据段(</strong>DATA)、用户动态链接的桩(<strong>stubs、</strong>stub_helper)、主程序代码(__text)</li>\n</ul>\n</li>\n<li>LC_LOAD_DYLINKER(内核加载器在执行该命令时启动动态链接器)</li>\n<li>LC_MAIN(设置进程的入口地址和栈大小，以及出程序计数器外的寄存器清零)</li>\n<li>LC_CODE_SIGNATURE(代码签名)</li>\n</ul>\n<blockquote>\n<p><code>otool</code>可以用来可以用来分析加载命令和代码段，如：<code>otool -l /bin/ls</code></p>\n</blockquote>\n<h2 id=\"动态库\"><a href=\"#动态库\" class=\"headerlink\" title=\"动态库\"></a>动态库</h2><h3 id=\"动态链接\"><a href=\"#动态链接\" class=\"headerlink\" title=\"动态链接\"></a>动态链接</h3><p>少量的进程只需要<code>内核加载器</code>就能完成加载，OSX中几乎所有的程序都是动态链接的–即填补对外部库和符号的引用。这个工作是由<code>动态链接器</code>来完成。该过程也被称为<code>符号绑定</code>。这个过程大概是这样的：</p>\n<blockquote>\n<p>如果二进制文件使用了外部定义的函数或符号，那么在他们的文本段中就会有一个名为__stubs的区，在这个区中存放的是本地未定义符号的占位符。编译器生成代码时会创建对符号桩的调用，链接器在运行的时候会解决对桩的这些调用–即在被调用的地址处放置一条JMP指令，并将控制权交给真实的函数体。但不会修改栈。因此真实的函数可以正常返回，就像直接调用函数一样。</p>\n</blockquote>\n<p>链接一般都是递归的，因为库也有可能引用其他的库。</p>\n<h3 id=\"共享库缓存（shared-library-cache）\"><a href=\"#共享库缓存（shared-library-cache）\" class=\"headerlink\" title=\"共享库缓存（shared library cache）\"></a>共享库缓存（shared library cache）</h3><p>共享库缓存是dyld支持的的另一种机制。是指：一些库经过预先链接，然后保存在磁盘的一个文件中。</p>\n<blockquote>\n<p>在OS X中dyld共享缓存保存在<code>/private/var/db/dyld</code>目录下。在iOS中则保存在<code>/System/Library/Caches/com.apple.dyld</code>.</p>\n</blockquote>\n<h3 id=\"运行时加载\"><a href=\"#运行时加载\" class=\"headerlink\" title=\"运行时加载\"></a>运行时加载</h3><p>一般通过#include包含一些头文件，这种方式构建的可执行文件只有在解决了所有依赖条件之后才能加载执行。但是通过<code>&lt;dlfcn.h&gt;</code>头文件提供的函数就可以在运行时（runtime）加载库。这样函数有：</p>\n<ul>\n<li>dlopen(const char *path)</li>\n<li>dlopen_preflight(const char *path)</li>\n<li>dlsym(void <em>handle ,char </em>sym)</li>\n<li>dladdr(char <em>addr , DL_Info </em>info)</li>\n<li>dlerror()</li>\n</ul>\n<p>Cocoa和Carbon为dl*系列提供了高层的封装，以及CFBundle和NSBundle对象，用于加载Mach-O bundle文件。</p>\n<h3 id=\"弱定义的符号\"><a href=\"#弱定义的符号\" class=\"headerlink\" title=\"弱定义的符号\"></a>弱定义的符号</h3><ul>\n<li>通常情况下符号都是被声明为强定义的，即文件在执行之前必须先解析这些符号，若发生解析失败，则程序运行失败，通常也会触发调试器陷阱。</li>\n<li>可以使用<code>__attribute__(weak_import)</code>将符号声明为弱符号。这样则在解析符号错误的时候，不会触发链接错误，动态链接器会将这个符号设置为NULL，效果跟运行时加载动态库类似（如dlopen）。</li>\n</ul>\n<blockquote>\n<p>使用<code>nm -m xxx.dylib</code>可以显示弱符号。</p>\n</blockquote>\n<h2 id=\"dyld的特性\"><a href=\"#dyld的特性\" class=\"headerlink\" title=\"dyld的特性\"></a>dyld的特性</h2><h3 id=\"两级命名空间\"><a href=\"#两级命名空间\" class=\"headerlink\" title=\"两级命名空间\"></a>两级命名空间</h3><ul>\n<li>通过将DYLD_FORCE_FLAT_NAMESPACE环境变量设置为非零即可禁用。</li>\n<li>可执行文件也可以在文件头中设置MH_FORCE_FLAT标志，强制对其加载的所有库使用平坦命名空间。</li>\n</ul>\n<h3 id=\"函数拦截\"><a href=\"#函数拦截\" class=\"headerlink\" title=\"函数拦截\"></a>函数拦截</h3><ul>\n<li><p>DYLD_INTERPOSE宏允许一个库将其函数替换为另一个函数。（跟iOS的swizzle类似）,例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DYLD_INTERPOSE(my_open ,open)</div></pre></td></tr></table></figure>\n</li>\n<li><p>dyld的函数拦截功能提供一个新的<strong>DATA区，名为</strong>interpose,在这个区中依次列出了替换的函数和被替换的函数，其他事情则交给dyld处理。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static const interpose_t interposing_functions[] \\</div><div class=\"line\">    __attribute__(section(&quot;__DATA,__interpose&quot;)) = &#123;</div><div class=\"line\">        &#123;(void *)my_free , (void *)free &#125;,</div><div class=\"line\">        &#123;(void *)my_malloc , (void *) malloc &#125;,</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>完整代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">#include &lt;unistd.h&gt;</div><div class=\"line\">#include &lt;fcntl.h&gt;</div><div class=\"line\">#include &lt;stdlib.h&gt;</div><div class=\"line\">#include &lt;malloc/malloc.h&gt; // for malloc_printf()</div><div class=\"line\"></div><div class=\"line\">// Note: Compile with GCC, not cc (important)</div><div class=\"line\">//</div><div class=\"line\">//</div><div class=\"line\">// This is the expected interpose structure</div><div class=\"line\"> typedef struct interpose_s &#123; void *new_func;</div><div class=\"line\">\t\t\t       void *orig_func; &#125; interpose_t;</div><div class=\"line\">// Our prototypes - requires since we are putting them in </div><div class=\"line\">//  the interposing_functions, below</div><div class=\"line\"></div><div class=\"line\">void *my_malloc(int size); // matches real malloc()</div><div class=\"line\">void my_free (void *); // matches real free()</div><div class=\"line\"></div><div class=\"line\">// For clang, add attribute(used)</div><div class=\"line\">static const interpose_t interposing_functions[] \\ </div><div class=\"line\">    __attribute__ ((used, section(&quot;__DATA, __interpose&quot;))) = &#123;</div><div class=\"line\"></div><div class=\"line\"> &#123; (void *)my_free, (void *)free &#125;,</div><div class=\"line\"> &#123; (void *)my_malloc, (void *)malloc &#125; </div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">void *</div><div class=\"line\">my_malloc (int size) &#123;</div><div class=\"line\"> // In our function we have access to the real malloc() -</div><div class=\"line\"> // and since we don’t want to mess with the heap ourselves,</div><div class=\"line\"> // just call it</div><div class=\"line\"> //</div><div class=\"line\">void *returned = malloc(size);</div><div class=\"line\">// call malloc_printf() because the real printf() calls malloc()</div><div class=\"line\">// // internally - and would end up calling us, recursing ad infinitum</div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;+ %p %d\\n&quot;, returned, size); return (returned);</div><div class=\"line\">&#125;</div><div class=\"line\">void</div><div class=\"line\">my_free (void *freed) &#123;</div><div class=\"line\">// Free - just print the address, then call the real free()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  malloc_printf ( &quot;- %p\\n&quot;, freed); free(freed);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#if 0</div><div class=\"line\">  From output 4-11:</div><div class=\"line\"></div><div class=\"line\"> morpheus@Ergo(~)$ gcc -dynamiclib l.c -o libMTrace.dylib -Wall  // compile to dylib</div><div class=\"line\"> morpheus@Ergo(~)$ DYLD_INSERT_LIBRARIES=libMTrace.dylib ls     // force insert into ls</div><div class=\"line\"> ls(24346) malloc: + 0x100100020 88</div><div class=\"line\"> ls(24346) malloc: + 0x100800000 4096</div><div class=\"line\"> ls(24346) malloc: + 0x100801000 2160 </div><div class=\"line\"> ls(24346) malloc: - 0x100800000 </div><div class=\"line\"> ls(24346) malloc: + 0x100801a00 3312 ... // etc.</div><div class=\"line\"></div><div class=\"line\">#endif</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用<code>pagestuff</code>命令可以显示文件逻辑页中的符号。如：<code>pagestuff /usr/lib/libgmalloc.dylib 6</code>,</p>\n</blockquote>\n<h2 id=\"进程的地址空间\"><a href=\"#进程的地址空间\" class=\"headerlink\" title=\"进程的地址空间\"></a>进程的地址空间</h2><ul>\n<li>每一个进程都有自己私有的虚拟地址空间。</li>\n<li>32位地址空间，用户态可访问整个4G的内存空间。</li>\n<li>64位的地址允许高达16EB（16GGB）</li>\n<li>现代系统一般都会在每次启动进程的时候，将其地址空间随机化（随机的给每个段加上地址偏移）。<blockquote>\n<p>使用<code>vmmap</code>命令来查看内存的空间布局，可以加上参数<code>-interleaved</code>以清晰的方式导出地址空间。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"React Native笔记","_content":"\n## 要点记录\n### 本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // Call long-running code on background thread\n    ...\n    // You can invoke callback from any thread/queue\n    callback(@[...]);\n  });\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@\"name\"];\n  [self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n  'EventReminder',\n  (reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n## 本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\n  RCTMap *map = [RCTMap new];\n  map.delegate = self;\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\n  render() {\n    return <RCTMap {...this.props} />;\n  }\n}\n\nMapView.propTypes = {\n  /**\n   * When this property is set to `true` and a valid camera is associated\n   * with the map, the camera’s pitch angle is used to tilt the plane\n   * of the map. When this property is set to `false`, the camera’s pitch\n   * angle is ignored and the map is always displayed as if the user\n   * is looking straight down onto it.\n   */\n  pitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n## FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 网友眼中的MVC\n![网友眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n## ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n## 遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","source":"_posts/React Native笔记.md","raw":"---\ntitle: React Native笔记\ncategories: \n - JS\n - React Native\ntags:\n - React\n - JS\n---\n\n## 要点记录\n### 本地模块（[Native Modules][1]）\n- **导出方法、导出静态变量、导出枚举**。\n- **本地模块改变运行线程的方法**。\n全局方法：重写属性methodQueue，如：\n``` objectivec\n- (dispatch_queue_t)methodQueue\n{\n  return dispatch_queue_create(\"com.facebook.React.AsyncLocalStorageQueue\", DISPATCH_QUEUE_SERIAL);\n}\n```\n个别方法：就是在调用回调的时候在外面包一层GCD，如：\n``` objectivec\nRCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{ \ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // Call long-running code on background thread\n    ...\n    // You can invoke callback from any thread/queue\n    callback(@[...]);\n  });\n}\n```\n- **发送事件给JavaScript**\nNative代码通过RCTBridge的eventDispatcher发送事件：\n``` objectivec\n#import \"RCTBridge.h\"\n#import \"RCTEventDispatcher.h\"\n@(开发笔记)implementation CalendarManager\n\n@synthesize bridge = _bridge;\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@\"name\"];\n  [self.bridge.eventDispatcher sendAppEventWithName:@\"EventReminder\" body:@{@\"name\": eventName}];\n}\n@end\n```\nJavaScript订阅事件：\n``` javascript\nimport { NativeAppEventEmitter } from 'react-native';\nvar subscription = NativeAppEventEmitter.addListener(\n  'EventReminder',\n  (reminder) => console.log(reminder.name)\n);\n...\n// Don't forget to unsubscribe, typically in componentWillUnmount\nsubscription.remove();\n```\n## 本地UI组件（[Native UI Components][2])\n- **本地的View都是通过`RCTViewManager`的子类来管理的，比如：`UIScrollView`会对应有一个`RCTScrollViewManager`，但这些`RCTViewManager`本质上是个单列，因为他们只会被bridge创建一次。`UIView`、`RCTViewManager`、`RCTUIManager`之间的关系如下图(不一定正确，需要研读代码做修正)**：\n``` seq\nUIView->RCTViewManager: UIView注册到RCTViewManager\nRCTViewManager->RCTUIManager:提供UIView给\nRCTUIManager-->RCTViewManager: 在更新UIView的属性时候通知它\nRCTViewManager-->UIView: 更新或设置UIView的属性\n```\n- 当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承`RCTViewManager`创建一个`RCTCustomViewManager`，然后重写`- (UIView *)view`方法，同可以用宏`RCT_EXPORT_VIEW_PROPERTY`导出属性或者使用`RCT_CUSTOM_VIEW_PROPERTY`自定义属性，例如：\n``` objectivec\n@implementation RCTMapManager\n\nRCT_EXPORT_MODULE()\n\n- (UIView *)view\n{\n  RCTMap *map = [RCTMap new];\n  map.delegate = self;\n  return map;\n}\n\nRCT_EXPORT_VIEW_PROPERTY(showsUserLocation, BOOL)\nRCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, RCTMap)\n{\n  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];\n}\n\n...\n@end\n```\n然后在JavaScript中就可以这一样使用了：\n``` javascript\n// MapView.js\nimport { requireNativeComponent } from 'react-native';\n//requireNativeComponent automatically resolves this to \"RCTMapManager\"\n<RCTMap showsUserLocation={false} />\nmodule.exports = requireNativeComponent('RCTMap', null);\n```\n然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：\n\n``` javascript\n// MapView.js\nimport React, { requireNativeComponent } from 'react-native';\n\nclass MapView extends React.Component {\n  render() {\n    return <RCTMap {...this.props} />;\n  }\n}\n\nMapView.propTypes = {\n  /**\n   * When this property is set to `true` and a valid camera is associated\n   * with the map, the camera’s pitch angle is used to tilt the plane\n   * of the map. When this property is set to `false`, the camera’s pitch\n   * angle is ignored and the map is always displayed as if the user\n   * is looking straight down onto it.\n   */\n  pitchEnabled: React.PropTypes.bool,\n};\n\nvar RCTMap = requireNativeComponent('RCTMap', MapView);\n\nmodule.exports = MapView;\n```\n## FLUX\n**MVC模式**：\n- Facebok 眼中的MVC\n![Facebok 眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 网友眼中的MVC\n![网友眼中的MVC](http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**FLUX**数据模型：（https://github.com/facebook/flux/）\n![FLUX](http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Action:\n- Dispatcher:\n- Store:\n- View:\n\nAll data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.\n\n**FLUX与MVC的区别**\n- FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。\n\n## ES6语法相关\n- [**module**][3]\n1. **实质：**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n2. 循环加载问题，commonJS跟ES6的区别。\n- [异步操作和Async函数](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数)\n1. [Promise](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise)\n2. [Generator](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数)\n使用`yield`作为关键字,每当程序运行到`yield`做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个`yield`。\n3. [Thunk](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数)\n简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用`Thunkify`模块。安装方式为：`$ npm install thunkify`。\n4. 编写自动执行器\n当`Generator`和`Thunk`结合起来，即`Generator`函数调用多个`Thunk`函数，通过编写自动执行代码，可以实现一个自动执行器。[co模块](https://github.com/tj/co)就是一个自动执行器。实现自动执行器代码的过程一般是这样的：\n>(1) 将要异步的函数转换成`Thunk`函数，如：读取文件`readFile`函数。\n>(2) 使用关键字`yield`编写`Generator`函数。\n>(3) 编写递归调用执行函数。\n5. [ES7的`async`和`wait`关键字](https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法)\n`async`和`wait`关键字结合起来就实现了一个自动执行器。\n\n\n## 遇到的问题\n1. 同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.\n2. Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。\n3. ReactNative增量升级方案 http://react-china.org/t/reactnative/3932\n\n[1]: http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\n[2]: http://facebook.github.io/react-native/docs/native-components-ios.html#content\n[3]: https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\n","slug":"React Native笔记","published":1,"date":"2016-10-17T07:24:26.000Z","updated":"2016-10-17T07:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth3z000ugivbdtbp01es","content":"<h2 id=\"要点记录\"><a href=\"#要点记录\" class=\"headerlink\" title=\"要点记录\"></a>要点记录</h2><h3 id=\"本地模块（Native-Modules）\"><a href=\"#本地模块（Native-Modules）\" class=\"headerlink\" title=\"本地模块（Native Modules）\"></a>本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\" target=\"_blank\" rel=\"external\">Native Modules</a>）</h3><ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">    callback(@[...]);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">  [<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\">  <span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">  (reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地UI组件（Native-UI-Components\"><a href=\"#本地UI组件（Native-UI-Components\" class=\"headerlink\" title=\"本地UI组件（Native UI Components)\"></a>本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\" target=\"_blank\" rel=\"external\">Native UI Components</a>)</h2><ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">  RCTMap *map = [RCTMap new];</div><div class=\"line\">  map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">  [view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">  /**</div><div class=\"line\">   * When this property is set to `true` and a valid camera is associated</div><div class=\"line\">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">   * angle is ignored and the map is always displayed as if the user</div><div class=\"line\">   * is looking straight down onto it.</div><div class=\"line\">   */</div><div class=\"line\">  pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<h2 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<h2 id=\"ES6语法相关\"><a href=\"#ES6语法相关\" class=\"headerlink\" title=\"ES6语法相关\"></a>ES6语法相关</h2><ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\" target=\"_blank\" rel=\"external\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n","excerpt":"","more":"<h2 id=\"要点记录\"><a href=\"#要点记录\" class=\"headerlink\" title=\"要点记录\"></a>要点记录</h2><h3 id=\"本地模块（Native-Modules）\"><a href=\"#本地模块（Native-Modules）\" class=\"headerlink\" title=\"本地模块（Native Modules）\"></a>本地模块（<a href=\"http://facebook.github.io/react-native/docs/native-modules-ios.html#native-modules\">Native Modules</a>）</h3><ul>\n<li><strong>导出方法、导出静态变量、导出枚举</strong>。</li>\n<li><strong>本地模块改变运行线程的方法</strong>。<br>全局方法：重写属性methodQueue，如：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"built_in\">dispatch_queue_t</span>)methodQueue</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> dispatch_queue_create(<span class=\"string\">\"com.facebook.React.AsyncLocalStorageQueue\"</span>, DISPATCH_QUEUE_SERIAL);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>个别方法：就是在调用回调的时候在外面包一层GCD，如：<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">RCT_EXPORT_METHOD(doSomethingExpensive:(<span class=\"built_in\">NSString</span> *)param callback:(RCTResponseSenderBlock)callback)</div><div class=\"line\">&#123; </div><div class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</div><div class=\"line\">    <span class=\"comment\">// Call long-running code on background thread</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"comment\">// You can invoke callback from any thread/queue</span></div><div class=\"line\">    callback(@[...]);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>发送事件给JavaScript</strong><br>Native代码通过RCTBridge的eventDispatcher发送事件：<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTBridge.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"RCTEventDispatcher.h\"</span></span></div><div class=\"line\">@(开发笔记)implementation CalendarManager</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">@synthesize</span> bridge = _bridge;</div><div class=\"line\">- (<span class=\"keyword\">void</span>)calendarEventReminderReceived:(<span class=\"built_in\">NSNotification</span> *)notification</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">NSString</span> *eventName = notification.userInfo[<span class=\"string\">@\"name\"</span>];</div><div class=\"line\">  [<span class=\"keyword\">self</span>.bridge.eventDispatcher sendAppEventWithName:<span class=\"string\">@\"EventReminder\"</span> body:@&#123;<span class=\"string\">@\"name\"</span>: eventName&#125;];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JavaScript订阅事件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; NativeAppEventEmitter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> subscription = NativeAppEventEmitter.addListener(</div><div class=\"line\">  <span class=\"string\">'EventReminder'</span>,</div><div class=\"line\">  (reminder) =&gt; <span class=\"built_in\">console</span>.log(reminder.name)</div><div class=\"line\">);</div><div class=\"line\">...</div><div class=\"line\"><span class=\"comment\">// Don't forget to unsubscribe, typically in componentWillUnmount</span></div><div class=\"line\">subscription.remove();</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地UI组件（Native-UI-Components\"><a href=\"#本地UI组件（Native-UI-Components\" class=\"headerlink\" title=\"本地UI组件（Native UI Components)\"></a>本地UI组件（<a href=\"http://facebook.github.io/react-native/docs/native-components-ios.html#content\">Native UI Components</a>)</h2><ul>\n<li><p><strong>本地的View都是通过<code>RCTViewManager</code>的子类来管理的，比如：<code>UIScrollView</code>会对应有一个<code>RCTScrollViewManager</code>，但这些<code>RCTViewManager</code>本质上是个单列，因为他们只会被bridge创建一次。<code>UIView</code>、<code>RCTViewManager</code>、<code>RCTUIManager</code>之间的关系如下图(不一定正确，需要研读代码做修正)</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView-&gt;RCTViewManager: UIView注册到RCTViewManager</div><div class=\"line\">RCTViewManager-&gt;RCTUIManager:提供UIView给</div><div class=\"line\">RCTUIManager--&gt;RCTViewManager: 在更新UIView的属性时候通知它</div><div class=\"line\">RCTViewManager--&gt;UIView: 更新或设置UIView的属性</div></pre></td></tr></table></figure>\n</li>\n<li><p>当你想提供一个CustomView给JavaScript使用的时候要做的事情就是继承<code>RCTViewManager</code>创建一个<code>RCTCustomViewManager</code>，然后重写<code>- (UIView *)view</code>方法，同可以用宏<code>RCT_EXPORT_VIEW_PROPERTY</code>导出属性或者使用<code>RCT_CUSTOM_VIEW_PROPERTY</code>自定义属性，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">RCTMapManager</span></span></div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_MODULE()</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"built_in\">UIView</span> *)view</div><div class=\"line\">&#123;</div><div class=\"line\">  RCTMap *map = [RCTMap new];</div><div class=\"line\">  map.delegate = <span class=\"keyword\">self</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> map;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">RCT_EXPORT_VIEW_PROPERTY(showsUserLocation, <span class=\"built_in\">BOOL</span>)</div><div class=\"line\">RCT_CUSTOM_VIEW_PROPERTY(region, <span class=\"built_in\">MKCoordinateRegion</span>, RCTMap)</div><div class=\"line\">&#123;</div><div class=\"line\">  [view setRegion:json ? [RCTConvert <span class=\"built_in\">MKCoordinateRegion</span>:json] : defaultView.region animated:<span class=\"literal\">YES</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后在JavaScript中就可以这一样使用了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"><span class=\"comment\">//requireNativeComponent automatically resolves this to \"RCTMapManager\"</span></div><div class=\"line\">&lt;RCTMap showsUserLocation=&#123;<span class=\"literal\">false</span>&#125; /&gt;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = requireNativeComponent(<span class=\"string\">'RCTMap'</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure></p>\n<p>然而这并不是最好的方式，由于在Js中并不是很清楚的能看出来属性有什么，是什么类型，所以最好是将RCTMap再包一层，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MapView.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> React, &#123; requireNativeComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-native'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapView</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;RCTMap &#123;...this.props&#125; /&gt;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MapView.propTypes = &#123;</div><div class=\"line\">  /**</div><div class=\"line\">   * When this property is set to `true` and a valid camera is associated</div><div class=\"line\">   * with the map, the camera’s pitch angle is used to tilt the plane</div><div class=\"line\">   * of the map. When this property is set to `false`, the camera’s pitch</div><div class=\"line\">   * angle is ignored and the map is always displayed as if the user</div><div class=\"line\">   * is looking straight down onto it.</div><div class=\"line\">   */</div><div class=\"line\">  pitchEnabled: React.PropTypes.bool,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var RCTMap = requireNativeComponent('RCTMap', MapView);</div><div class=\"line\"></div><div class=\"line\">module.exports = MapView;</div></pre></td></tr></table></figure>\n<h2 id=\"FLUX\"><a href=\"#FLUX\" class=\"headerlink\" title=\"FLUX\"></a>FLUX</h2><p><strong>MVC模式</strong>：</p>\n<ul>\n<li>Facebok 眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-736b93462451f44e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Facebok 眼中的MVC\"></li>\n<li>网友眼中的MVC<br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-da96d932bead788d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网友眼中的MVC\"></li>\n</ul>\n<p><strong>FLUX</strong>数据模型：（<a href=\"https://github.com/facebook/flux/）\">https://github.com/facebook/flux/）</a><br><img src=\"http://upload-images.jianshu.io/upload_images/1801567-79c9daf37d2c9e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"FLUX\"></p>\n<ul>\n<li>Action:</li>\n<li>Dispatcher:</li>\n<li>Store:</li>\n<li>View:</li>\n</ul>\n<p>All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own setState() method, causing a re-rendering of themselves and all of their descendants in the component tree.</p>\n<p><strong>FLUX与MVC的区别</strong></p>\n<ul>\n<li>FLUX的Dispatcher与MVC的Controller的区别：Controller包含业务逻辑，而Dispatcher不包含业务逻辑，它可以在其他地方复用，主要职责是将事件分发给订阅者（Store）。</li>\n</ul>\n<h2 id=\"ES6语法相关\"><a href=\"#ES6语法相关\" class=\"headerlink\" title=\"ES6语法相关\"></a>ES6语法相关</h2><ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/8ad3c20f5f477a091282c764c15032732d386c48/docs/module.md\"><strong>module</strong></a></li>\n</ul>\n<ol>\n<li><strong>实质：</strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>循环加载问题，commonJS跟ES6的区别。</li>\n</ol>\n<ul>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#异步操作和async函数\">异步操作和Async函数</a></li>\n</ul>\n<ol>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#promise\">Promise</a></li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#generator函数\">Generator</a><br>使用<code>yield</code>作为关键字,每当程序运行到<code>yield</code>做修饰的代码，函数会暂停，并交出控制权给其他的协程，直到其协程返回控制权。调用next()方法执行下一个<code>yield</code>。</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#thunk函数\">Thunk</a><br>简单而言，就是将多参数的函数通过包装成高阶函数，将为只包含一个参数的函数。可使用<code>Thunkify</code>模块。安装方式为：<code>$ npm install thunkify</code>。</li>\n<li>编写自动执行器<br>当<code>Generator</code>和<code>Thunk</code>结合起来，即<code>Generator</code>函数调用多个<code>Thunk</code>函数，通过编写自动执行代码，可以实现一个自动执行器。<a href=\"https://github.com/tj/co\">co模块</a>就是一个自动执行器。实现自动执行器代码的过程一般是这样的：<blockquote>\n<p>(1) 将要异步的函数转换成<code>Thunk</code>函数，如：读取文件<code>readFile</code>函数。<br>(2) 使用关键字<code>yield</code>编写<code>Generator</code>函数。<br>(3) 编写递归调用执行函数。</p>\n</blockquote>\n</li>\n<li><a href=\"https://github.com/ruanyf/es6tutorial/blob/202f04bc43e0a9a74113338f0518847797071ae4/docs/async.md#async-函数的用法\">ES7的<code>async</code>和<code>wait</code>关键字</a><br><code>async</code>和<code>wait</code>关键字结合起来就实现了一个自动执行器。</li>\n</ol>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><ol>\n<li>同时只能启动一个server。否则会报错：[error][tid:com.facebook.React.JavaScript] Application AwesomeProject has not been registered. This is either due to a require() error during initialization or failure to call AppRegistry.registerComponent.</li>\n<li>Xcode 的 run script的运行路径是工程文件.xcodeproj所在目录。</li>\n<li>ReactNative增量升级方案 <a href=\"http://react-china.org/t/reactnative/3932\">http://react-china.org/t/reactnative/3932</a></li>\n</ol>\n"},{"title":"TCP/IP协议的理解与调优","_content":"\n*本文大部分内容摘自《Web性能权威指南》，然后经过本人的整理修饰，产生了本文，仅供学习所用。*\n\n## 开始\n我们做为一名互联网时代的开发，由于各种信息、知识的开源与共享，想要开发出一款可用网络应用已经相当容易了，但是想要开发出一款“快速”访问网络的应用，却并不是那么简单，需要经过无数的优化，踩过无数的坑才能更“快”。然而，如果对网络背后的原理都半点不知，又从何谈起优化，更不用说动手去优化。说到网络协议，我们自然而然会想到TCP/IP协议，因为它已经成了我们日常的一部分，只是因为它对绝大部分人来说都是透明的，看不见它。可是想要提高我们的网络应用的访问速度，却不得不揭开它的面纱，一窥其芳容。想要全面的了解它并不是一早一夕的事，我们只能先从出它的一些共性入手，下面便让我们一起看看到底TCP/IP是何物，又该如何让TCP更快一些。\n\n## 什么是TCP、IP\n- **IP**，即 Internet Protocol(因特网协议)，位于网络层，负责联网主机之间的路由选择和寻址;\n- **TCP**，即 Transmission Control Protocol(传输控制协议)，位于传输层，负责在不可靠的传输信道之上提供可靠的抽象层。\n\n\t> TCP 负责在不可靠的传输信道之上提供可靠的抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整，等等。 采用TCP数据流可以确保发送的所有字节能够完整地被接收到，而且到达客户端的顺序也一样。也就是说，TCP 专门为精确传送做了优化，但并未过多顾及时间。\n\n## 是什么给TCP带来了网络延迟\n众所周知，在现代的网络应用中我们几乎离不开TCP，从浏览器到微信，无一例外。但，我们在享受TCP给我们带来的便利的同时，却又对其所带来的网络延迟感到煎熬，总是尝试去改善它，那么究竟是什么给TCP带来了不小的网络延迟呢？下面便列举几种常见的因素。\n\n### TCP的3次握手\n所有TCP连接一开始都要经过3次握手，如下图。\n![3次握手](../images/shake_hand.png)\n3次握手的过程如下：\n\n- SYN\r客户端选择一个随机序列号x，并发送一个SYN分组，其中可能还包括其他TCP标志和选项。\r- SYN ACK\r服务器给x加1，并选择自己的一个随机序列号y，追加自己的标志和选项，然后返回响应。\r- ACK\r客户端给x和y加1并发送握手期间的最后一个ACK分组。\n\n经过上面的3次握手之后，客户端与服务端就可以通信了。**客户端在发送完ACK分组数据之后，可以马上发送数据，而服务端必须等接收到了ACK分组数据才能发送数据**。可见，3次握手带来的延迟使得每创建一个新TCP连接都要付出很大代价。而这也决定了提高TCP应用性能的关键，在于想办法**重用连接**。\n\n### TCP的流量控制\n流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP连接的每一方都要通告接收方自己的**接收窗口(rwnd)**，其中包含能够保存数据的**缓冲区空间大小信息**。\n\n如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。 假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。**这个过程贯穿于每个TCP连接的整个生命周期:如上图，每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力**。\n\n### TCP的慢启动\n发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件 而动态改变速度。\n\n比如：在家中开始以宽带全速8M/s的速度观看在线视频，中途有人更新软件，此时视频的下载速度根本达不到8M/s，如果依然以原来的速度传输，那么数据很快就会在某个中间的网关越积越多，最终会导致分组被删除，从而降低网络传输效率。\n\n慢启动就是用来应对这种问题的方案。首先通信的发送端会初始化一个叫做**拥塞窗口(cwnd)**的变量，其值就是在收到对方ACK之前可以发送数据大小，并且是一个保守的值。发送端最大可以传输(未经ACK确认的)数据量取`rwnd`和`cwnd`变量中的最小值。在接下来得发送过程中，每收到一个ACK（未收到则等待），发送数据量就以指数增长的方式往上增加，直到超过接收端的流量控制窗口`rwnd`，即系统配置的拥塞阈值(ssthresh)窗口，或者有分组丢失为止，此时拥塞预防算法介入。**由此可见在TCP三次握手到达最大传输速度之间会有一段慢启动导致的耗时**。减少慢启动导致的耗时的方案有：\n\n- **减少通信双方的往返时间**。（比如选择就近的服务器向客户端发送数据）\n- **加大初始拥塞窗口(cwnd)的值**。（一般这个值是伴随着系统版本而更新的）\n\n### TCP的拥塞预防\n拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了， 以至于必须采取删包措施。因此，必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。\n\r重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个时刻，可能又会有包丢失，于是这个过程再从头开始。如果你看到过TCP连接的吞吐量跟踪曲线，发现该曲线呈锯齿状，那现在就该明白为什么了。这是拥塞控制和预防算法在调整拥塞窗口，进而消除网络中的丢包问题。\n\n### 队首阻塞\nTCP在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发，以及保证网络最高效率的流量控制、拥塞控制和预防机制，让TCP成为大多数网络应用中最常见的传输协议。\n\n每个TCP分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端(如下图)。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的TCP缓冲区，等待丢失的分组重发并到达接收端。这一切都发生在TCP层，应用程序对TCP重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到延迟交付。这种效应称为TCP的**队首(HOL，Head of Line)阻塞**。\n\n![3次握手](../images/TCP_HOL.png)\n\n## 怎么让TCP网络延迟小一些\nTCP是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此，优化TCP的**最佳途径就是调整它感知当前网络状况的方式**，根据它之上或之下的抽象层的类型和需求来改变它的行为。无线网络可能需要不同的拥塞算法，**而某些应用程序可能需要自定义服务品质(QoS，Quality of Service)的含义**，从而 交付最佳的体验。\n\n上面只蜻蜓点水般地介绍了影响TCP性能的几个典型因素，而没有探讨的选择性应答(SACK)、延迟应答、快速转发等，随 便一个都能让你领略到 TCP 的复杂性(或者乐趣)，感受到理解、分析和调优之难。\n\r尽管如此，而且每个算法和反馈机制的具体细节可能会继续发展，但核心原理以及它们的影响是不变的:\n\r- TCP三次握手增加了整整一次往返时间。\r- TCP慢启动将被应用到每个新连接。\r- TCP流量及拥塞控制会影响所有连接的吞吐量。\r- TCP的吞吐量由当前拥塞窗口大小控制。\n\n### 服务器配置调优\n\n- **增大TCP的初始拥塞窗口。**\n- **在连接空闲时禁用慢启动可以改善瞬时发送数据的长TCP连接的性能。**\n- **启用窗口缩放可以增大最大接收窗口大小，可以让高延迟的连接达到更好吞吐量。**\n- **TCP快速打开。**\n\n### 应用程序行为调优\n\n- **消除不必要的数据传输本身就是很大的优化。**比如，减少下载不必要的资源， 或者通过压缩算法把要发送的比特数降到最低。\r- **通过在不同的地区部署服务器(比如，使用 CDN)，把数据放到接近客户端的地方，可以减少网络往返的延迟，从而显著提升TCP性能**。\r- **重用TCP连接**，把慢启动和其他拥塞控制机制的影响降到最低。。\n\n\n## 最后\n\n通过上面的介绍，我可以知道影响TCP性能的因素很多，有TCP的3次握手、流量控制、慢启动、拥塞预防等，这些因素既是TCP的特性也是导致TCP延迟的原因，让人又爱又恨。然而，为了让我们的应用快起来，我们又不得不尝试去优化TCP的速度，可悲的是过程很艰难，可喜的是并不是无计可施，针对TCP不同阶段的不同因素我们可以采取相应的措施，对其加以优化，便可以减少TCP特性所带来的网络延迟。\n","source":"_posts/TCP-IP-detail.md","raw":"---\ntitle: TCP/IP协议的理解与调优\ncategories: \n- Web性能调优\ntags:\n - 网络\n---\n\n*本文大部分内容摘自《Web性能权威指南》，然后经过本人的整理修饰，产生了本文，仅供学习所用。*\n\n## 开始\n我们做为一名互联网时代的开发，由于各种信息、知识的开源与共享，想要开发出一款可用网络应用已经相当容易了，但是想要开发出一款“快速”访问网络的应用，却并不是那么简单，需要经过无数的优化，踩过无数的坑才能更“快”。然而，如果对网络背后的原理都半点不知，又从何谈起优化，更不用说动手去优化。说到网络协议，我们自然而然会想到TCP/IP协议，因为它已经成了我们日常的一部分，只是因为它对绝大部分人来说都是透明的，看不见它。可是想要提高我们的网络应用的访问速度，却不得不揭开它的面纱，一窥其芳容。想要全面的了解它并不是一早一夕的事，我们只能先从出它的一些共性入手，下面便让我们一起看看到底TCP/IP是何物，又该如何让TCP更快一些。\n\n## 什么是TCP、IP\n- **IP**，即 Internet Protocol(因特网协议)，位于网络层，负责联网主机之间的路由选择和寻址;\n- **TCP**，即 Transmission Control Protocol(传输控制协议)，位于传输层，负责在不可靠的传输信道之上提供可靠的抽象层。\n\n\t> TCP 负责在不可靠的传输信道之上提供可靠的抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整，等等。 采用TCP数据流可以确保发送的所有字节能够完整地被接收到，而且到达客户端的顺序也一样。也就是说，TCP 专门为精确传送做了优化，但并未过多顾及时间。\n\n## 是什么给TCP带来了网络延迟\n众所周知，在现代的网络应用中我们几乎离不开TCP，从浏览器到微信，无一例外。但，我们在享受TCP给我们带来的便利的同时，却又对其所带来的网络延迟感到煎熬，总是尝试去改善它，那么究竟是什么给TCP带来了不小的网络延迟呢？下面便列举几种常见的因素。\n\n### TCP的3次握手\n所有TCP连接一开始都要经过3次握手，如下图。\n![3次握手](../images/shake_hand.png)\n3次握手的过程如下：\n\n- SYN\r客户端选择一个随机序列号x，并发送一个SYN分组，其中可能还包括其他TCP标志和选项。\r- SYN ACK\r服务器给x加1，并选择自己的一个随机序列号y，追加自己的标志和选项，然后返回响应。\r- ACK\r客户端给x和y加1并发送握手期间的最后一个ACK分组。\n\n经过上面的3次握手之后，客户端与服务端就可以通信了。**客户端在发送完ACK分组数据之后，可以马上发送数据，而服务端必须等接收到了ACK分组数据才能发送数据**。可见，3次握手带来的延迟使得每创建一个新TCP连接都要付出很大代价。而这也决定了提高TCP应用性能的关键，在于想办法**重用连接**。\n\n### TCP的流量控制\n流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP连接的每一方都要通告接收方自己的**接收窗口(rwnd)**，其中包含能够保存数据的**缓冲区空间大小信息**。\n\n如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。 假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。**这个过程贯穿于每个TCP连接的整个生命周期:如上图，每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力**。\n\n### TCP的慢启动\n发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件 而动态改变速度。\n\n比如：在家中开始以宽带全速8M/s的速度观看在线视频，中途有人更新软件，此时视频的下载速度根本达不到8M/s，如果依然以原来的速度传输，那么数据很快就会在某个中间的网关越积越多，最终会导致分组被删除，从而降低网络传输效率。\n\n慢启动就是用来应对这种问题的方案。首先通信的发送端会初始化一个叫做**拥塞窗口(cwnd)**的变量，其值就是在收到对方ACK之前可以发送数据大小，并且是一个保守的值。发送端最大可以传输(未经ACK确认的)数据量取`rwnd`和`cwnd`变量中的最小值。在接下来得发送过程中，每收到一个ACK（未收到则等待），发送数据量就以指数增长的方式往上增加，直到超过接收端的流量控制窗口`rwnd`，即系统配置的拥塞阈值(ssthresh)窗口，或者有分组丢失为止，此时拥塞预防算法介入。**由此可见在TCP三次握手到达最大传输速度之间会有一段慢启动导致的耗时**。减少慢启动导致的耗时的方案有：\n\n- **减少通信双方的往返时间**。（比如选择就近的服务器向客户端发送数据）\n- **加大初始拥塞窗口(cwnd)的值**。（一般这个值是伴随着系统版本而更新的）\n\n### TCP的拥塞预防\n拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了， 以至于必须采取删包措施。因此，必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。\n\r重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个时刻，可能又会有包丢失，于是这个过程再从头开始。如果你看到过TCP连接的吞吐量跟踪曲线，发现该曲线呈锯齿状，那现在就该明白为什么了。这是拥塞控制和预防算法在调整拥塞窗口，进而消除网络中的丢包问题。\n\n### 队首阻塞\nTCP在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发，以及保证网络最高效率的流量控制、拥塞控制和预防机制，让TCP成为大多数网络应用中最常见的传输协议。\n\n每个TCP分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端(如下图)。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的TCP缓冲区，等待丢失的分组重发并到达接收端。这一切都发生在TCP层，应用程序对TCP重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到延迟交付。这种效应称为TCP的**队首(HOL，Head of Line)阻塞**。\n\n![3次握手](../images/TCP_HOL.png)\n\n## 怎么让TCP网络延迟小一些\nTCP是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此，优化TCP的**最佳途径就是调整它感知当前网络状况的方式**，根据它之上或之下的抽象层的类型和需求来改变它的行为。无线网络可能需要不同的拥塞算法，**而某些应用程序可能需要自定义服务品质(QoS，Quality of Service)的含义**，从而 交付最佳的体验。\n\n上面只蜻蜓点水般地介绍了影响TCP性能的几个典型因素，而没有探讨的选择性应答(SACK)、延迟应答、快速转发等，随 便一个都能让你领略到 TCP 的复杂性(或者乐趣)，感受到理解、分析和调优之难。\n\r尽管如此，而且每个算法和反馈机制的具体细节可能会继续发展，但核心原理以及它们的影响是不变的:\n\r- TCP三次握手增加了整整一次往返时间。\r- TCP慢启动将被应用到每个新连接。\r- TCP流量及拥塞控制会影响所有连接的吞吐量。\r- TCP的吞吐量由当前拥塞窗口大小控制。\n\n### 服务器配置调优\n\n- **增大TCP的初始拥塞窗口。**\n- **在连接空闲时禁用慢启动可以改善瞬时发送数据的长TCP连接的性能。**\n- **启用窗口缩放可以增大最大接收窗口大小，可以让高延迟的连接达到更好吞吐量。**\n- **TCP快速打开。**\n\n### 应用程序行为调优\n\n- **消除不必要的数据传输本身就是很大的优化。**比如，减少下载不必要的资源， 或者通过压缩算法把要发送的比特数降到最低。\r- **通过在不同的地区部署服务器(比如，使用 CDN)，把数据放到接近客户端的地方，可以减少网络往返的延迟，从而显著提升TCP性能**。\r- **重用TCP连接**，把慢启动和其他拥塞控制机制的影响降到最低。。\n\n\n## 最后\n\n通过上面的介绍，我可以知道影响TCP性能的因素很多，有TCP的3次握手、流量控制、慢启动、拥塞预防等，这些因素既是TCP的特性也是导致TCP延迟的原因，让人又爱又恨。然而，为了让我们的应用快起来，我们又不得不尝试去优化TCP的速度，可悲的是过程很艰难，可喜的是并不是无计可施，针对TCP不同阶段的不同因素我们可以采取相应的措施，对其加以优化，便可以减少TCP特性所带来的网络延迟。\n","slug":"TCP-IP-detail","published":1,"date":"2016-12-22T01:46:58.000Z","updated":"2016-12-22T01:46:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth42000wgivb0gu4kg6y","content":"<p><em>本文大部分内容摘自《Web性能权威指南》，然后经过本人的整理修饰，产生了本文，仅供学习所用。</em></p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>我们做为一名互联网时代的开发，由于各种信息、知识的开源与共享，想要开发出一款可用网络应用已经相当容易了，但是想要开发出一款“快速”访问网络的应用，却并不是那么简单，需要经过无数的优化，踩过无数的坑才能更“快”。然而，如果对网络背后的原理都半点不知，又从何谈起优化，更不用说动手去优化。说到网络协议，我们自然而然会想到TCP/IP协议，因为它已经成了我们日常的一部分，只是因为它对绝大部分人来说都是透明的，看不见它。可是想要提高我们的网络应用的访问速度，却不得不揭开它的面纱，一窥其芳容。想要全面的了解它并不是一早一夕的事，我们只能先从出它的一些共性入手，下面便让我们一起看看到底TCP/IP是何物，又该如何让TCP更快一些。</p>\n<h2 id=\"什么是TCP、IP\"><a href=\"#什么是TCP、IP\" class=\"headerlink\" title=\"什么是TCP、IP\"></a>什么是TCP、IP</h2><ul>\n<li><strong>IP</strong>，即 Internet Protocol(因特网协议)，位于网络层，负责联网主机之间的路由选择和寻址;</li>\n<li><p><strong>TCP</strong>，即 Transmission Control Protocol(传输控制协议)，位于传输层，负责在不可靠的传输信道之上提供可靠的抽象层。</p>\n<blockquote>\n<p>TCP 负责在不可靠的传输信道之上提供可靠的抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整，等等。 采用TCP数据流可以确保发送的所有字节能够完整地被接收到，而且到达客户端的顺序也一样。也就是说，TCP 专门为精确传送做了优化，但并未过多顾及时间。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"是什么给TCP带来了网络延迟\"><a href=\"#是什么给TCP带来了网络延迟\" class=\"headerlink\" title=\"是什么给TCP带来了网络延迟\"></a>是什么给TCP带来了网络延迟</h2><p>众所周知，在现代的网络应用中我们几乎离不开TCP，从浏览器到微信，无一例外。但，我们在享受TCP给我们带来的便利的同时，却又对其所带来的网络延迟感到煎熬，总是尝试去改善它，那么究竟是什么给TCP带来了不小的网络延迟呢？下面便列举几种常见的因素。</p>\n<h3 id=\"TCP的3次握手\"><a href=\"#TCP的3次握手\" class=\"headerlink\" title=\"TCP的3次握手\"></a>TCP的3次握手</h3><p>所有TCP连接一开始都要经过3次握手，如下图。<br><img src=\"../images/shake_hand.png\" alt=\"3次握手\"><br>3次握手的过程如下：</p>\n<ul>\n<li>SYN<br>客户端选择一个随机序列号x，并发送一个SYN分组，其中可能还包括其他TCP标志和选项。</li>\n<li>SYN ACK<br>服务器给x加1，并选择自己的一个随机序列号y，追加自己的标志和选项，然后返回响应。</li>\n<li>ACK<br>客户端给x和y加1并发送握手期间的最后一个ACK分组。</li>\n</ul>\n<p>经过上面的3次握手之后，客户端与服务端就可以通信了。<strong>客户端在发送完ACK分组数据之后，可以马上发送数据，而服务端必须等接收到了ACK分组数据才能发送数据</strong>。可见，3次握手带来的延迟使得每创建一个新TCP连接都要付出很大代价。而这也决定了提高TCP应用性能的关键，在于想办法<strong>重用连接</strong>。</p>\n<h3 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h3><p>流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP连接的每一方都要通告接收方自己的<strong>接收窗口(rwnd)</strong>，其中包含能够保存数据的<strong>缓冲区空间大小信息</strong>。</p>\n<p>如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。 假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。<strong>这个过程贯穿于每个TCP连接的整个生命周期:如上图，每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力</strong>。</p>\n<h3 id=\"TCP的慢启动\"><a href=\"#TCP的慢启动\" class=\"headerlink\" title=\"TCP的慢启动\"></a>TCP的慢启动</h3><p>发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件 而动态改变速度。</p>\n<p>比如：在家中开始以宽带全速8M/s的速度观看在线视频，中途有人更新软件，此时视频的下载速度根本达不到8M/s，如果依然以原来的速度传输，那么数据很快就会在某个中间的网关越积越多，最终会导致分组被删除，从而降低网络传输效率。</p>\n<p>慢启动就是用来应对这种问题的方案。首先通信的发送端会初始化一个叫做<strong>拥塞窗口(cwnd)</strong>的变量，其值就是在收到对方ACK之前可以发送数据大小，并且是一个保守的值。发送端最大可以传输(未经ACK确认的)数据量取<code>rwnd</code>和<code>cwnd</code>变量中的最小值。在接下来得发送过程中，每收到一个ACK（未收到则等待），发送数据量就以指数增长的方式往上增加，直到超过接收端的流量控制窗口<code>rwnd</code>，即系统配置的拥塞阈值(ssthresh)窗口，或者有分组丢失为止，此时拥塞预防算法介入。<strong>由此可见在TCP三次握手到达最大传输速度之间会有一段慢启动导致的耗时</strong>。减少慢启动导致的耗时的方案有：</p>\n<ul>\n<li><strong>减少通信双方的往返时间</strong>。（比如选择就近的服务器向客户端发送数据）</li>\n<li><strong>加大初始拥塞窗口(cwnd)的值</strong>。（一般这个值是伴随着系统版本而更新的）</li>\n</ul>\n<h3 id=\"TCP的拥塞预防\"><a href=\"#TCP的拥塞预防\" class=\"headerlink\" title=\"TCP的拥塞预防\"></a>TCP的拥塞预防</h3><p>拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了， 以至于必须采取删包措施。因此，必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。</p>\n<p>重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个时刻，可能又会有包丢失，于是这个过程再从头开始。如果你看到过TCP连接的吞吐量跟踪曲线，发现该曲线呈锯齿状，那现在就该明白为什么了。这是拥塞控制和预防算法在调整拥塞窗口，进而消除网络中的丢包问题。</p>\n<h3 id=\"队首阻塞\"><a href=\"#队首阻塞\" class=\"headerlink\" title=\"队首阻塞\"></a>队首阻塞</h3><p>TCP在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发，以及保证网络最高效率的流量控制、拥塞控制和预防机制，让TCP成为大多数网络应用中最常见的传输协议。</p>\n<p>每个TCP分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端(如下图)。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的TCP缓冲区，等待丢失的分组重发并到达接收端。这一切都发生在TCP层，应用程序对TCP重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到延迟交付。这种效应称为TCP的<strong>队首(HOL，Head of Line)阻塞</strong>。</p>\n<p><img src=\"../images/TCP_HOL.png\" alt=\"3次握手\"></p>\n<h2 id=\"怎么让TCP网络延迟小一些\"><a href=\"#怎么让TCP网络延迟小一些\" class=\"headerlink\" title=\"怎么让TCP网络延迟小一些\"></a>怎么让TCP网络延迟小一些</h2><p>TCP是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此，优化TCP的<strong>最佳途径就是调整它感知当前网络状况的方式</strong>，根据它之上或之下的抽象层的类型和需求来改变它的行为。无线网络可能需要不同的拥塞算法，<strong>而某些应用程序可能需要自定义服务品质(QoS，Quality of Service)的含义</strong>，从而 交付最佳的体验。</p>\n<p>上面只蜻蜓点水般地介绍了影响TCP性能的几个典型因素，而没有探讨的选择性应答(SACK)、延迟应答、快速转发等，随 便一个都能让你领略到 TCP 的复杂性(或者乐趣)，感受到理解、分析和调优之难。</p>\n<p>尽管如此，而且每个算法和反馈机制的具体细节可能会继续发展，但核心原理以及它们的影响是不变的:</p>\n<ul>\n<li>TCP三次握手增加了整整一次往返时间。</li>\n<li>TCP慢启动将被应用到每个新连接。</li>\n<li>TCP流量及拥塞控制会影响所有连接的吞吐量。</li>\n<li>TCP的吞吐量由当前拥塞窗口大小控制。</li>\n</ul>\n<h3 id=\"服务器配置调优\"><a href=\"#服务器配置调优\" class=\"headerlink\" title=\"服务器配置调优\"></a>服务器配置调优</h3><ul>\n<li><strong>增大TCP的初始拥塞窗口。</strong></li>\n<li><strong>在连接空闲时禁用慢启动可以改善瞬时发送数据的长TCP连接的性能。</strong></li>\n<li><strong>启用窗口缩放可以增大最大接收窗口大小，可以让高延迟的连接达到更好吞吐量。</strong></li>\n<li><strong>TCP快速打开。</strong></li>\n</ul>\n<h3 id=\"应用程序行为调优\"><a href=\"#应用程序行为调优\" class=\"headerlink\" title=\"应用程序行为调优\"></a>应用程序行为调优</h3><ul>\n<li><strong>消除不必要的数据传输本身就是很大的优化。</strong>比如，减少下载不必要的资源， 或者通过压缩算法把要发送的比特数降到最低。</li>\n<li><strong>通过在不同的地区部署服务器(比如，使用 CDN)，把数据放到接近客户端的地方，可以减少网络往返的延迟，从而显著提升TCP性能</strong>。</li>\n<li><strong>重用TCP连接</strong>，把慢启动和其他拥塞控制机制的影响降到最低。。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>通过上面的介绍，我可以知道影响TCP性能的因素很多，有TCP的3次握手、流量控制、慢启动、拥塞预防等，这些因素既是TCP的特性也是导致TCP延迟的原因，让人又爱又恨。然而，为了让我们的应用快起来，我们又不得不尝试去优化TCP的速度，可悲的是过程很艰难，可喜的是并不是无计可施，针对TCP不同阶段的不同因素我们可以采取相应的措施，对其加以优化，便可以减少TCP特性所带来的网络延迟。</p>\n","excerpt":"","more":"<p><em>本文大部分内容摘自《Web性能权威指南》，然后经过本人的整理修饰，产生了本文，仅供学习所用。</em></p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>我们做为一名互联网时代的开发，由于各种信息、知识的开源与共享，想要开发出一款可用网络应用已经相当容易了，但是想要开发出一款“快速”访问网络的应用，却并不是那么简单，需要经过无数的优化，踩过无数的坑才能更“快”。然而，如果对网络背后的原理都半点不知，又从何谈起优化，更不用说动手去优化。说到网络协议，我们自然而然会想到TCP/IP协议，因为它已经成了我们日常的一部分，只是因为它对绝大部分人来说都是透明的，看不见它。可是想要提高我们的网络应用的访问速度，却不得不揭开它的面纱，一窥其芳容。想要全面的了解它并不是一早一夕的事，我们只能先从出它的一些共性入手，下面便让我们一起看看到底TCP/IP是何物，又该如何让TCP更快一些。</p>\n<h2 id=\"什么是TCP、IP\"><a href=\"#什么是TCP、IP\" class=\"headerlink\" title=\"什么是TCP、IP\"></a>什么是TCP、IP</h2><ul>\n<li><strong>IP</strong>，即 Internet Protocol(因特网协议)，位于网络层，负责联网主机之间的路由选择和寻址;</li>\n<li><p><strong>TCP</strong>，即 Transmission Control Protocol(传输控制协议)，位于传输层，负责在不可靠的传输信道之上提供可靠的抽象层。</p>\n<blockquote>\n<p>TCP 负责在不可靠的传输信道之上提供可靠的抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整，等等。 采用TCP数据流可以确保发送的所有字节能够完整地被接收到，而且到达客户端的顺序也一样。也就是说，TCP 专门为精确传送做了优化，但并未过多顾及时间。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"是什么给TCP带来了网络延迟\"><a href=\"#是什么给TCP带来了网络延迟\" class=\"headerlink\" title=\"是什么给TCP带来了网络延迟\"></a>是什么给TCP带来了网络延迟</h2><p>众所周知，在现代的网络应用中我们几乎离不开TCP，从浏览器到微信，无一例外。但，我们在享受TCP给我们带来的便利的同时，却又对其所带来的网络延迟感到煎熬，总是尝试去改善它，那么究竟是什么给TCP带来了不小的网络延迟呢？下面便列举几种常见的因素。</p>\n<h3 id=\"TCP的3次握手\"><a href=\"#TCP的3次握手\" class=\"headerlink\" title=\"TCP的3次握手\"></a>TCP的3次握手</h3><p>所有TCP连接一开始都要经过3次握手，如下图。<br><img src=\"../images/shake_hand.png\" alt=\"3次握手\"><br>3次握手的过程如下：</p>\n<ul>\n<li>SYN<br>客户端选择一个随机序列号x，并发送一个SYN分组，其中可能还包括其他TCP标志和选项。</li>\n<li>SYN ACK<br>服务器给x加1，并选择自己的一个随机序列号y，追加自己的标志和选项，然后返回响应。</li>\n<li>ACK<br>客户端给x和y加1并发送握手期间的最后一个ACK分组。</li>\n</ul>\n<p>经过上面的3次握手之后，客户端与服务端就可以通信了。<strong>客户端在发送完ACK分组数据之后，可以马上发送数据，而服务端必须等接收到了ACK分组数据才能发送数据</strong>。可见，3次握手带来的延迟使得每创建一个新TCP连接都要付出很大代价。而这也决定了提高TCP应用性能的关键，在于想办法<strong>重用连接</strong>。</p>\n<h3 id=\"TCP的流量控制\"><a href=\"#TCP的流量控制\" class=\"headerlink\" title=\"TCP的流量控制\"></a>TCP的流量控制</h3><p>流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区既定而无法处理。为实现流量控制，TCP连接的每一方都要通告接收方自己的<strong>接收窗口(rwnd)</strong>，其中包含能够保存数据的<strong>缓冲区空间大小信息</strong>。</p>\n<p>如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口。 假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。<strong>这个过程贯穿于每个TCP连接的整个生命周期:如上图，每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力</strong>。</p>\n<h3 id=\"TCP的慢启动\"><a href=\"#TCP的慢启动\" class=\"headerlink\" title=\"TCP的慢启动\"></a>TCP的慢启动</h3><p>发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件 而动态改变速度。</p>\n<p>比如：在家中开始以宽带全速8M/s的速度观看在线视频，中途有人更新软件，此时视频的下载速度根本达不到8M/s，如果依然以原来的速度传输，那么数据很快就会在某个中间的网关越积越多，最终会导致分组被删除，从而降低网络传输效率。</p>\n<p>慢启动就是用来应对这种问题的方案。首先通信的发送端会初始化一个叫做<strong>拥塞窗口(cwnd)</strong>的变量，其值就是在收到对方ACK之前可以发送数据大小，并且是一个保守的值。发送端最大可以传输(未经ACK确认的)数据量取<code>rwnd</code>和<code>cwnd</code>变量中的最小值。在接下来得发送过程中，每收到一个ACK（未收到则等待），发送数据量就以指数增长的方式往上增加，直到超过接收端的流量控制窗口<code>rwnd</code>，即系统配置的拥塞阈值(ssthresh)窗口，或者有分组丢失为止，此时拥塞预防算法介入。<strong>由此可见在TCP三次握手到达最大传输速度之间会有一段慢启动导致的耗时</strong>。减少慢启动导致的耗时的方案有：</p>\n<ul>\n<li><strong>减少通信双方的往返时间</strong>。（比如选择就近的服务器向客户端发送数据）</li>\n<li><strong>加大初始拥塞窗口(cwnd)的值</strong>。（一般这个值是伴随着系统版本而更新的）</li>\n</ul>\n<h3 id=\"TCP的拥塞预防\"><a href=\"#TCP的拥塞预防\" class=\"headerlink\" title=\"TCP的拥塞预防\"></a>TCP的拥塞预防</h3><p>拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了， 以至于必须采取删包措施。因此，必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。</p>\n<p>重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。某个时刻，可能又会有包丢失，于是这个过程再从头开始。如果你看到过TCP连接的吞吐量跟踪曲线，发现该曲线呈锯齿状，那现在就该明白为什么了。这是拥塞控制和预防算法在调整拥塞窗口，进而消除网络中的丢包问题。</p>\n<h3 id=\"队首阻塞\"><a href=\"#队首阻塞\" class=\"headerlink\" title=\"队首阻塞\"></a>队首阻塞</h3><p>TCP在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发，以及保证网络最高效率的流量控制、拥塞控制和预防机制，让TCP成为大多数网络应用中最常见的传输协议。</p>\n<p>每个TCP分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端(如下图)。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的TCP缓冲区，等待丢失的分组重发并到达接收端。这一切都发生在TCP层，应用程序对TCP重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到延迟交付。这种效应称为TCP的<strong>队首(HOL，Head of Line)阻塞</strong>。</p>\n<p><img src=\"../images/TCP_HOL.png\" alt=\"3次握手\"></p>\n<h2 id=\"怎么让TCP网络延迟小一些\"><a href=\"#怎么让TCP网络延迟小一些\" class=\"headerlink\" title=\"怎么让TCP网络延迟小一些\"></a>怎么让TCP网络延迟小一些</h2><p>TCP是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此，优化TCP的<strong>最佳途径就是调整它感知当前网络状况的方式</strong>，根据它之上或之下的抽象层的类型和需求来改变它的行为。无线网络可能需要不同的拥塞算法，<strong>而某些应用程序可能需要自定义服务品质(QoS，Quality of Service)的含义</strong>，从而 交付最佳的体验。</p>\n<p>上面只蜻蜓点水般地介绍了影响TCP性能的几个典型因素，而没有探讨的选择性应答(SACK)、延迟应答、快速转发等，随 便一个都能让你领略到 TCP 的复杂性(或者乐趣)，感受到理解、分析和调优之难。</p>\n<p>尽管如此，而且每个算法和反馈机制的具体细节可能会继续发展，但核心原理以及它们的影响是不变的:</p>\n<ul>\n<li>TCP三次握手增加了整整一次往返时间。</li>\n<li>TCP慢启动将被应用到每个新连接。</li>\n<li>TCP流量及拥塞控制会影响所有连接的吞吐量。</li>\n<li>TCP的吞吐量由当前拥塞窗口大小控制。</li>\n</ul>\n<h3 id=\"服务器配置调优\"><a href=\"#服务器配置调优\" class=\"headerlink\" title=\"服务器配置调优\"></a>服务器配置调优</h3><ul>\n<li><strong>增大TCP的初始拥塞窗口。</strong></li>\n<li><strong>在连接空闲时禁用慢启动可以改善瞬时发送数据的长TCP连接的性能。</strong></li>\n<li><strong>启用窗口缩放可以增大最大接收窗口大小，可以让高延迟的连接达到更好吞吐量。</strong></li>\n<li><strong>TCP快速打开。</strong></li>\n</ul>\n<h3 id=\"应用程序行为调优\"><a href=\"#应用程序行为调优\" class=\"headerlink\" title=\"应用程序行为调优\"></a>应用程序行为调优</h3><ul>\n<li><strong>消除不必要的数据传输本身就是很大的优化。</strong>比如，减少下载不必要的资源， 或者通过压缩算法把要发送的比特数降到最低。</li>\n<li><strong>通过在不同的地区部署服务器(比如，使用 CDN)，把数据放到接近客户端的地方，可以减少网络往返的延迟，从而显著提升TCP性能</strong>。</li>\n<li><strong>重用TCP连接</strong>，把慢启动和其他拥塞控制机制的影响降到最低。。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>通过上面的介绍，我可以知道影响TCP性能的因素很多，有TCP的3次握手、流量控制、慢启动、拥塞预防等，这些因素既是TCP的特性也是导致TCP延迟的原因，让人又爱又恨。然而，为了让我们的应用快起来，我们又不得不尝试去优化TCP的速度，可悲的是过程很艰难，可喜的是并不是无计可施，针对TCP不同阶段的不同因素我们可以采取相应的措施，对其加以优化，便可以减少TCP特性所带来的网络延迟。</p>\n"},{"title":"iOS的事件处理顺序","date":"2016-10-27T09:23:51.000Z","description":"通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。","_content":"\n\n通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。\n\n## 事件分发\n当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：\n\n![Hit-testing returns the subview that was touched][1]\n\n假设点击了View E。那么这个触摸事件传递的顺序是这样子的：\n\n1. 由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。\n2. 由于触摸区域在C内，因此会检查它的子view D和E。\n3. 最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。\n\n## 事件响应链\n事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。\n\n![The responder chain on iOS][2]\n\n由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：\n\n**view** -> **view'superView** -> ... -> **viewController** -> **window** -> **application**\n\n## 最后\n至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。\n\n## 参考文档\n[Event Delivery: The Responder Chain][3]\n\n---\n\n[1]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\n\n[2]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\n\n[3]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\n","source":"_posts/TheResponderChain.md","raw":"---\ntitle: iOS的事件处理顺序\ncategories: \n- Apple Development\n- iOS开发笔记\ntags: \n- 事件响应链\ndate: 2016-10-27 17:23:51\ndescription: \"通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。\"\n\n---\n\n\n通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。\n\n## 事件分发\n当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：\n\n![Hit-testing returns the subview that was touched][1]\n\n假设点击了View E。那么这个触摸事件传递的顺序是这样子的：\n\n1. 由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。\n2. 由于触摸区域在C内，因此会检查它的子view D和E。\n3. 最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。\n\n## 事件响应链\n事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。\n\n![The responder chain on iOS][2]\n\n由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：\n\n**view** -> **view'superView** -> ... -> **viewController** -> **window** -> **application**\n\n## 最后\n至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。\n\n## 参考文档\n[Event Delivery: The Responder Chain][3]\n\n---\n\n[1]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\n\n[2]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\n\n[3]: https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\n","slug":"TheResponderChain","published":1,"updated":"2016-11-15T07:07:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth44000zgivb5sepqmlq","content":"<p>通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。</p>\n<h2 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h2><p>当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\" alt=\"Hit-testing returns the subview that was touched\"></p>\n<p>假设点击了View E。那么这个触摸事件传递的顺序是这样子的：</p>\n<ol>\n<li>由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。</li>\n<li>由于触摸区域在C内，因此会检查它的子view D和E。</li>\n<li>最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。</li>\n</ol>\n<h2 id=\"事件响应链\"><a href=\"#事件响应链\" class=\"headerlink\" title=\"事件响应链\"></a>事件响应链</h2><p>事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\" alt=\"The responder chain on iOS\"></p>\n<p>由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：</p>\n<p><strong>view</strong> -&gt; <strong>view’superView</strong> -&gt; … -&gt; <strong>viewController</strong> -&gt; <strong>window</strong> -&gt; <strong>application</strong></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\" target=\"_blank\" rel=\"external\">Event Delivery: The Responder Chain</a></p>\n<hr>\n","excerpt":"","more":"<p>通常我们开发的app的UI元素都是有一个个view对堆叠起来的，也就是说我们点击屏幕的某一个区域的时候，会触动所有包含这个区域的view。那么这个触摸事件该由哪个View来处理，或者我们想更改iOS默认的处理方式又该如何下手，我们就需要先了解iOS中的事件是如何分发以及如何响应的。接下来介绍的是从官方文档精选出来的一部内容并加以了说明。</p>\n<h2 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h2><p>当用户触发一个事件，UIKit会创建一个对应的对象来表示该事件（比如：触摸事件：UIEvent），并把该事件对象传递给app的事件队列里面，然后由UIApplication的单列从队首取出一个事件，通常会分发到UIWindow，再由UIWindow传递到下一个responder，直到找到一个能相应该事件的responder为止(对于触摸事件，通常就是hit-test View)。例如：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png\" alt=\"Hit-testing returns the subview that was touched\"></p>\n<p>假设点击了View E。那么这个触摸事件传递的顺序是这样子的：</p>\n<ol>\n<li>由于触摸的区域在最外层的A之内，所以会检查它的子view B跟C。</li>\n<li>由于触摸区域在C内，因此会检查它的子view D和E。</li>\n<li>最后由于该触摸区域在E内，并且E是最顶层的View，因此它会成为hit-test view。</li>\n</ol>\n<h2 id=\"事件响应链\"><a href=\"#事件响应链\" class=\"headerlink\" title=\"事件响应链\"></a>事件响应链</h2><p>事件响应的顺序跟事件分发的顺序是相反的。通常事件首先都是由first responder处理的，如果它不想处理，则交由它的nextResponder处理，此时该responder就变成了first responder，反复如此，直到有一个responder愿意处理，如果到了最后都没有responder处理，则丢弃该事件。UIApplication, UIViewController以及UIView都是responder（都是UIResponder的子类）。</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png\" alt=\"The responder chain on iOS\"></p>\n<p>由上图可以看出，事件处理的的优先级从高到低，大概是这样子的：</p>\n<p><strong>view</strong> -&gt; <strong>view’superView</strong> -&gt; … -&gt; <strong>viewController</strong> -&gt; <strong>window</strong> -&gt; <strong>application</strong></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>至此，我们已经知道了iOS是如何处理事件，我们大致可以将这个过程分为两部分：事件分发以及事件响应，这两个过程的顺序是相反的。对于一个app来说，事件分发，就是从application开始找到一个最上面的view或者controller来处理事件。如果最上面的view不愿意处理，就进入事件响应的流程，会将这个事件一直往下抛，直到找到一个愿意处理的view或者controller，如果大家都不愿处理，就丢弃这个事件。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html\">Event Delivery: The Responder Chain</a></p>\n<hr>\n"},{"title":"理解TLS","_content":"\n*本文大部分内容整理自《Web性能权威指南》，仅供学习所用。*\n\n## 1. 什么是TLS\nSSL(SecureSocketsLayer，安全套接字层)协议最初是网景公司为了保障网上交易安全而开发的，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。为达到这个目标，SSL协议在直接位于TCP上一层的应用层被实现(如下图)。SSL不会影响上层协议(如HTTP、电子邮件、即时通讯)，但能够保证上层协议的网络通信安全。\n\nSSL2.0是该协议第一个公开发布的版本，但由于存在很多安全缺陷很快就被SSL3.0取代。鉴于SSL协议是网景公司专有的，IETF成立了一个小组负责标准化该协议，后来就有了RFC2246，即TLS1.0，也就是SSL3.0的升级版。**TLS包含两部分：握手协议、记录协议**。\n\n![传输层安全(TLS](../images/TLS_in_OSI.png)\n\n## 2. TLS握手协议\n\n### 2.1 一般握手\n客户端与服务器在通过TLS交换数据之前，必须协商建立加密信道。协商内容包括TLS版本、加密套件，必要时还会验证证书。然而，协商过程的每一步都需要一个分组在客户端和服务器之间往返一次(如下图)，因而所有TLS连接启动时都要经历一定的延迟（最多需要两次额外往返）。\n\n![TLS握手协议](../images/TLS_HandShake.png)\n\n- 0ms : TLS在可靠的传输层(TCP)之上运行，这意味着首先必须完成TCP的“三次握手”，即一次完整的往返。\r- 56ms : TCP连接建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的TLS协议的版本、它所支持的加密套件列表，以及它支持或希望使用的另外一些TLS选项。\r- 84ms : 然后，服务器取得TLS协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，再附上自己的证书，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他TLS扩展参数。\r- 112ms : 假设两端经过协商确定了共同的版本和加密套件，客户端也高高兴兴地把自己的证书提供给了服务器。然后，客户端会生成一个新的对称密钥，用服务器的公钥来加密，加密后发送给服务器，告诉服务器可以开始加密通信了。到目前为止，除了用服务器公钥加密的新对称密钥之外，所有数据都以明文形式发送。\r- 140ms : 最后，服务器解密出客户端发来的对称密钥，通过验证消息的MAC检测消息完整性，再返回给客户端一个加密的“Finished”消息。\r- 168ms : 客户端用它之前生成的对称密钥解密这条消息，验证MAC，如果一切顺利，则建立信道并开始发送应用数据。\n \n> 公钥加密系统(http://en.wikipedia.org/wiki/Public-key_cryptography)只在建立TLS信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称 密钥并使用服务器的公钥对其加密，然后再将加密的对称密钥返回服务器。服务器继而用自己的私钥解密出客户端发来的对称密钥。接下来，客户端与服务器间的通信就全都使用客户端生成的共享密钥加密，这就是对称密钥加密。之所以这样设计，很大程度上是出于性能考虑，因为公钥加密需要很大的计算量。为了演示两者的差别，假如你的电脑上安装了 OpenSSL，可以试试以下两条命令:`openssl speed rsa`、`openssl speed aes`。\n\n### 2.2 TLS会话恢复（简短握手）\n\n#### 2.2.1 会话标识符\n从上面我们可以知道一次握手需要两次额外的往返时间，为了挽回这些损失，TLS提供了恢复功能，即在多个连接间共享协商后的安全密钥。即，服务器创建32字节的会话标识符，并在上一节我们讨论的完整的TLS协商期间作为其“ServerHello”消息的一部分发送。**借助会话标识符可以节省一次往返（参见下图），还可以省掉用于协商共享加密密钥的公钥加密计算**。\n\n![简短TLS握手协议](../images/TLS_Handshare_simple.png)\n\n#### 2.2.2 会话记录单\n由于服务器必须为每个客户端都创建和维护一段会话缓存，这样的话，请求量大的服务器就需要维护大量的会话ID，并且还要指定一个高效的缓存、清除策略。为了解决这个问题，**会话记录单**应运而生，即，**服务器可以在完整TLS握手的最后一次交换中添加一条“新会话记录单”(New Session Ticket)记录，包含只有服务器知道的安 全密钥加密过的所有会话数据。\r然后，客户端将这个会话记录单保存起来，在后续会话的 ClientHello 消息中，以将其包含在SessionTicket扩展中。这样，所有会话数据只保存在客户端，而由于数据被加密过，且密钥只有服务器知道，因此仍然是安全的。**\n\n### 2.3 证书链\n身份验证是建立每个TLS连接必不可少的部分。毕竟，加密信道两端可以是任何机 器，包括攻击者的机器。为此，必须确保我们与之交谈的计算机是可信任的，否则 之前的工作都是徒劳。为理解如何验证通信两端的身份，下面我们以张三和李四之间的验证为例简单说明一下:\r\r- 张三和李四分别生成自己的公钥和私钥;\r- 张三和李四分别隐藏自己的私钥;\r- 张三向李四公开自己的公钥，李四也向张三公开自己的公钥; - 张三向李四发送一条新消息，并用自己的私钥签名;\r- 李四使用张三的公钥验证收到的消息签名。\n\r信任是上述交流的关键。公钥加密可以让我们使用发送端的公钥验证消息是否使用了正确的私钥签名，但认可发送端仍然是基于信任。在上述交流中，张三和李四可以当面交换自己的公钥，因为他们互相认识，能够保证不被别人冒名顶替。可以说，他们已经通过之前安全(物理)的握手确认了对方。\n\r接下来，张三收到王五发来的一条消息。张三从未见过王五，但王五自称是李四的朋友。事实上，为了证明自己是李四的朋友，王五还请李四用李四的私钥签署了自己的公钥，并在消息中附上了签名(见下图)。此时，张三首先检查王五公钥中李四 的签名。他知道李四的公钥，因而可以验证李四确实签署了王五的公钥。由于他信任李四对王五的签名，所以就接受了王五的消息，并对消息进行完整性检查，以确保消息确实来自王五。刚才这个过程建立了一个信任链:张三信任李四，李四信任王五，通过信任的传递，张三信任王五。只要这条链上的人不会被冒名顶替，我们就可以继续扩展这个信任网络。\n\n![张三、李四和王五的信任链](../images/TLS_cer_sample.png)\n\nTLS的证书验证就跟上面的例子类似。只不过类似李四这样的中间人（中间证书）很多，这些证书是一级一级网上验证，直到根证书（一般浏览器内置了几百个可信任的根证书）。证书颁发机构签署数字证书如下图。\n\n![证书颁发机构签署数字证书](../images/TLS_Cer_auth.png)\n\n证书颁发过程：\n\n- 根证书颁发中间证书。\n- 中间证书颁发站点证书。\n\n证书验证过程：\n\n- 从站点证书出发一直往上找到根证书。\n- 根证书验证中间证书。\n- 中间证书验证站点证书。\n\n\n## 3. TLS记录协议\n\n与位于其下的IP或TCP层没有什么不同，TLS会话中交换的所有数据同样使用规格明确的协议进行分帧(如下图)。TLS记录协议负责识别不同的消息类型(握手、警告或数据，通过“内容类型”字段)，以及每条消息的安全和完整性验证。\n\n![TLS记录结构](../images/TLS_Record_Struct.png)\n\n交付应用数据的典型流程如下：\n\n- 记录协议接收应用数据。\r- 接收到的数据被切分为块:最大为每条记录214字节，即 16 KB。\r- 压缩应用数据(可选)。\r- 添加MAC(Message Authentication Code)或HMAC。\r- 使用商定的加密套件加密数据。\n\n以上几步完成后，加密数据就会被交给TCP层传输。接收端的流程相同，顺序相反:使用商定的加密套件解密数据、验证 MAC、提取并把数据转交给上层的应用。\r同样，值得庆幸的是以上过程都由TLS层帮我们处理，而且对大多数应用都是完全透明的。不过，记录协议也带来了一些重要的限制，务必要注意:\n\r- TLS记录最大为16KB;\r- 每条记录包含5字节的首部、MAC(在 SSL 3.0、TLS 1.0、TLS 1.1 中最多 20 字节，\r在 TLS 1.2 中最多 32 字节)，如果使用块加密则还有填充;\r- 必须接收到整条记录才能开始解密和验证。\n\r有可能的话，应该自主选择记录大小，这也是一项重要的优化。小记录会因记录分帧而招致较大开销，大记录在被TLS层处理并交付应用之前，必须通过TCP传输和重新组装。\n\n## 4. TLS性能检查清单\n- 要最大限制提升TCP性能;\r- 把TLS库升级到最新版本，在此基础上构建(或重新构建)服务器;\r- 启用并配置会话缓存和无状态恢复;\r- 监控会话缓存的使用情况并作出相应调整;\r- 在接近用户的地方完成TLS会话，尽量减少往返延迟;\r- 配置TLS记录大小，使其恰好能封装在一个TCP段内;\r- 确保证书链不会超过拥塞窗口的大小;\r- 从信任链中去掉不必要的证书，减少链条层次;\r- 禁用服务器的TLS压缩功能;\r- 启用服务器对SNI 的支持;\r- 启用服务器的OCSP封套功能;\r- 追加HTTP严格传输安全首部。\n\n> 要验证和测试你的配置，可以使用 Qualys SSL Server Test(https://www. ssllabs.com/ssltest/)等在线服务来扫描你的服务器，以发现常见的配置和安全漏洞。也可以通过`openssl s_client -state -CAfile startssl.ca.crt -connect igvita.com:443`来检查整个握手和本地服务器配置情况。\n\n","source":"_posts/TLS.md","raw":"---\ntitle:  理解TLS\ncategories: \n- Web性能调优\ntags: \n- 网络\n- 安全\n- SSL/TLS\n---\n\n*本文大部分内容整理自《Web性能权威指南》，仅供学习所用。*\n\n## 1. 什么是TLS\nSSL(SecureSocketsLayer，安全套接字层)协议最初是网景公司为了保障网上交易安全而开发的，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。为达到这个目标，SSL协议在直接位于TCP上一层的应用层被实现(如下图)。SSL不会影响上层协议(如HTTP、电子邮件、即时通讯)，但能够保证上层协议的网络通信安全。\n\nSSL2.0是该协议第一个公开发布的版本，但由于存在很多安全缺陷很快就被SSL3.0取代。鉴于SSL协议是网景公司专有的，IETF成立了一个小组负责标准化该协议，后来就有了RFC2246，即TLS1.0，也就是SSL3.0的升级版。**TLS包含两部分：握手协议、记录协议**。\n\n![传输层安全(TLS](../images/TLS_in_OSI.png)\n\n## 2. TLS握手协议\n\n### 2.1 一般握手\n客户端与服务器在通过TLS交换数据之前，必须协商建立加密信道。协商内容包括TLS版本、加密套件，必要时还会验证证书。然而，协商过程的每一步都需要一个分组在客户端和服务器之间往返一次(如下图)，因而所有TLS连接启动时都要经历一定的延迟（最多需要两次额外往返）。\n\n![TLS握手协议](../images/TLS_HandShake.png)\n\n- 0ms : TLS在可靠的传输层(TCP)之上运行，这意味着首先必须完成TCP的“三次握手”，即一次完整的往返。\r- 56ms : TCP连接建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的TLS协议的版本、它所支持的加密套件列表，以及它支持或希望使用的另外一些TLS选项。\r- 84ms : 然后，服务器取得TLS协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，再附上自己的证书，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他TLS扩展参数。\r- 112ms : 假设两端经过协商确定了共同的版本和加密套件，客户端也高高兴兴地把自己的证书提供给了服务器。然后，客户端会生成一个新的对称密钥，用服务器的公钥来加密，加密后发送给服务器，告诉服务器可以开始加密通信了。到目前为止，除了用服务器公钥加密的新对称密钥之外，所有数据都以明文形式发送。\r- 140ms : 最后，服务器解密出客户端发来的对称密钥，通过验证消息的MAC检测消息完整性，再返回给客户端一个加密的“Finished”消息。\r- 168ms : 客户端用它之前生成的对称密钥解密这条消息，验证MAC，如果一切顺利，则建立信道并开始发送应用数据。\n \n> 公钥加密系统(http://en.wikipedia.org/wiki/Public-key_cryptography)只在建立TLS信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称 密钥并使用服务器的公钥对其加密，然后再将加密的对称密钥返回服务器。服务器继而用自己的私钥解密出客户端发来的对称密钥。接下来，客户端与服务器间的通信就全都使用客户端生成的共享密钥加密，这就是对称密钥加密。之所以这样设计，很大程度上是出于性能考虑，因为公钥加密需要很大的计算量。为了演示两者的差别，假如你的电脑上安装了 OpenSSL，可以试试以下两条命令:`openssl speed rsa`、`openssl speed aes`。\n\n### 2.2 TLS会话恢复（简短握手）\n\n#### 2.2.1 会话标识符\n从上面我们可以知道一次握手需要两次额外的往返时间，为了挽回这些损失，TLS提供了恢复功能，即在多个连接间共享协商后的安全密钥。即，服务器创建32字节的会话标识符，并在上一节我们讨论的完整的TLS协商期间作为其“ServerHello”消息的一部分发送。**借助会话标识符可以节省一次往返（参见下图），还可以省掉用于协商共享加密密钥的公钥加密计算**。\n\n![简短TLS握手协议](../images/TLS_Handshare_simple.png)\n\n#### 2.2.2 会话记录单\n由于服务器必须为每个客户端都创建和维护一段会话缓存，这样的话，请求量大的服务器就需要维护大量的会话ID，并且还要指定一个高效的缓存、清除策略。为了解决这个问题，**会话记录单**应运而生，即，**服务器可以在完整TLS握手的最后一次交换中添加一条“新会话记录单”(New Session Ticket)记录，包含只有服务器知道的安 全密钥加密过的所有会话数据。\r然后，客户端将这个会话记录单保存起来，在后续会话的 ClientHello 消息中，以将其包含在SessionTicket扩展中。这样，所有会话数据只保存在客户端，而由于数据被加密过，且密钥只有服务器知道，因此仍然是安全的。**\n\n### 2.3 证书链\n身份验证是建立每个TLS连接必不可少的部分。毕竟，加密信道两端可以是任何机 器，包括攻击者的机器。为此，必须确保我们与之交谈的计算机是可信任的，否则 之前的工作都是徒劳。为理解如何验证通信两端的身份，下面我们以张三和李四之间的验证为例简单说明一下:\r\r- 张三和李四分别生成自己的公钥和私钥;\r- 张三和李四分别隐藏自己的私钥;\r- 张三向李四公开自己的公钥，李四也向张三公开自己的公钥; - 张三向李四发送一条新消息，并用自己的私钥签名;\r- 李四使用张三的公钥验证收到的消息签名。\n\r信任是上述交流的关键。公钥加密可以让我们使用发送端的公钥验证消息是否使用了正确的私钥签名，但认可发送端仍然是基于信任。在上述交流中，张三和李四可以当面交换自己的公钥，因为他们互相认识，能够保证不被别人冒名顶替。可以说，他们已经通过之前安全(物理)的握手确认了对方。\n\r接下来，张三收到王五发来的一条消息。张三从未见过王五，但王五自称是李四的朋友。事实上，为了证明自己是李四的朋友，王五还请李四用李四的私钥签署了自己的公钥，并在消息中附上了签名(见下图)。此时，张三首先检查王五公钥中李四 的签名。他知道李四的公钥，因而可以验证李四确实签署了王五的公钥。由于他信任李四对王五的签名，所以就接受了王五的消息，并对消息进行完整性检查，以确保消息确实来自王五。刚才这个过程建立了一个信任链:张三信任李四，李四信任王五，通过信任的传递，张三信任王五。只要这条链上的人不会被冒名顶替，我们就可以继续扩展这个信任网络。\n\n![张三、李四和王五的信任链](../images/TLS_cer_sample.png)\n\nTLS的证书验证就跟上面的例子类似。只不过类似李四这样的中间人（中间证书）很多，这些证书是一级一级网上验证，直到根证书（一般浏览器内置了几百个可信任的根证书）。证书颁发机构签署数字证书如下图。\n\n![证书颁发机构签署数字证书](../images/TLS_Cer_auth.png)\n\n证书颁发过程：\n\n- 根证书颁发中间证书。\n- 中间证书颁发站点证书。\n\n证书验证过程：\n\n- 从站点证书出发一直往上找到根证书。\n- 根证书验证中间证书。\n- 中间证书验证站点证书。\n\n\n## 3. TLS记录协议\n\n与位于其下的IP或TCP层没有什么不同，TLS会话中交换的所有数据同样使用规格明确的协议进行分帧(如下图)。TLS记录协议负责识别不同的消息类型(握手、警告或数据，通过“内容类型”字段)，以及每条消息的安全和完整性验证。\n\n![TLS记录结构](../images/TLS_Record_Struct.png)\n\n交付应用数据的典型流程如下：\n\n- 记录协议接收应用数据。\r- 接收到的数据被切分为块:最大为每条记录214字节，即 16 KB。\r- 压缩应用数据(可选)。\r- 添加MAC(Message Authentication Code)或HMAC。\r- 使用商定的加密套件加密数据。\n\n以上几步完成后，加密数据就会被交给TCP层传输。接收端的流程相同，顺序相反:使用商定的加密套件解密数据、验证 MAC、提取并把数据转交给上层的应用。\r同样，值得庆幸的是以上过程都由TLS层帮我们处理，而且对大多数应用都是完全透明的。不过，记录协议也带来了一些重要的限制，务必要注意:\n\r- TLS记录最大为16KB;\r- 每条记录包含5字节的首部、MAC(在 SSL 3.0、TLS 1.0、TLS 1.1 中最多 20 字节，\r在 TLS 1.2 中最多 32 字节)，如果使用块加密则还有填充;\r- 必须接收到整条记录才能开始解密和验证。\n\r有可能的话，应该自主选择记录大小，这也是一项重要的优化。小记录会因记录分帧而招致较大开销，大记录在被TLS层处理并交付应用之前，必须通过TCP传输和重新组装。\n\n## 4. TLS性能检查清单\n- 要最大限制提升TCP性能;\r- 把TLS库升级到最新版本，在此基础上构建(或重新构建)服务器;\r- 启用并配置会话缓存和无状态恢复;\r- 监控会话缓存的使用情况并作出相应调整;\r- 在接近用户的地方完成TLS会话，尽量减少往返延迟;\r- 配置TLS记录大小，使其恰好能封装在一个TCP段内;\r- 确保证书链不会超过拥塞窗口的大小;\r- 从信任链中去掉不必要的证书，减少链条层次;\r- 禁用服务器的TLS压缩功能;\r- 启用服务器对SNI 的支持;\r- 启用服务器的OCSP封套功能;\r- 追加HTTP严格传输安全首部。\n\n> 要验证和测试你的配置，可以使用 Qualys SSL Server Test(https://www. ssllabs.com/ssltest/)等在线服务来扫描你的服务器，以发现常见的配置和安全漏洞。也可以通过`openssl s_client -state -CAfile startssl.ca.crt -connect igvita.com:443`来检查整个握手和本地服务器配置情况。\n\n","slug":"TLS","published":1,"date":"2016-12-23T03:55:05.000Z","updated":"2016-12-23T03:55:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth450012givbl4s38lsp","content":"<p><em>本文大部分内容整理自《Web性能权威指南》，仅供学习所用。</em></p>\n<h2 id=\"1-什么是TLS\"><a href=\"#1-什么是TLS\" class=\"headerlink\" title=\"1. 什么是TLS\"></a>1. 什么是TLS</h2><p>SSL(SecureSocketsLayer，安全套接字层)协议最初是网景公司为了保障网上交易安全而开发的，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。为达到这个目标，SSL协议在直接位于TCP上一层的应用层被实现(如下图)。SSL不会影响上层协议(如HTTP、电子邮件、即时通讯)，但能够保证上层协议的网络通信安全。</p>\n<p>SSL2.0是该协议第一个公开发布的版本，但由于存在很多安全缺陷很快就被SSL3.0取代。鉴于SSL协议是网景公司专有的，IETF成立了一个小组负责标准化该协议，后来就有了RFC2246，即TLS1.0，也就是SSL3.0的升级版。<strong>TLS包含两部分：握手协议、记录协议</strong>。</p>\n<p><img src=\"../images/TLS_in_OSI.png\" alt=\"传输层安全(TLS\"></p>\n<h2 id=\"2-TLS握手协议\"><a href=\"#2-TLS握手协议\" class=\"headerlink\" title=\"2. TLS握手协议\"></a>2. TLS握手协议</h2><h3 id=\"2-1-一般握手\"><a href=\"#2-1-一般握手\" class=\"headerlink\" title=\"2.1 一般握手\"></a>2.1 一般握手</h3><p>客户端与服务器在通过TLS交换数据之前，必须协商建立加密信道。协商内容包括TLS版本、加密套件，必要时还会验证证书。然而，协商过程的每一步都需要一个分组在客户端和服务器之间往返一次(如下图)，因而所有TLS连接启动时都要经历一定的延迟（最多需要两次额外往返）。</p>\n<p><img src=\"../images/TLS_HandShake.png\" alt=\"TLS握手协议\"></p>\n<ul>\n<li>0ms : TLS在可靠的传输层(TCP)之上运行，这意味着首先必须完成TCP的“三次握手”，即一次完整的往返。</li>\n<li>56ms : TCP连接建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的TLS协议的版本、它所支持的加密套件列表，以及它支持或希望使用的另外一些TLS选项。</li>\n<li>84ms : 然后，服务器取得TLS协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，再附上自己的证书，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他TLS扩展参数。</li>\n<li>112ms : 假设两端经过协商确定了共同的版本和加密套件，客户端也高高兴兴地把自己的证书提供给了服务器。然后，客户端会生成一个新的对称密钥，用服务器的公钥来加密，加密后发送给服务器，告诉服务器可以开始加密通信了。到目前为止，除了用服务器公钥加密的新对称密钥之外，所有数据都以明文形式发送。</li>\n<li>140ms : 最后，服务器解密出客户端发来的对称密钥，通过验证消息的MAC检测消息完整性，再返回给客户端一个加密的“Finished”消息。</li>\n<li>168ms : 客户端用它之前生成的对称密钥解密这条消息，验证MAC，如果一切顺利，则建立信道并开始发送应用数据。</li>\n</ul>\n<blockquote>\n<p>公钥加密系统(<a href=\"http://en.wikipedia.org/wiki/Public-key_cryptography)只在建立TLS信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Public-key_cryptography)只在建立TLS信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称</a> 密钥并使用服务器的公钥对其加密，然后再将加密的对称密钥返回服务器。服务器继而用自己的私钥解密出客户端发来的对称密钥。接下来，客户端与服务器间的通信就全都使用客户端生成的共享密钥加密，这就是对称密钥加密。之所以这样设计，很大程度上是出于性能考虑，因为公钥加密需要很大的计算量。为了演示两者的差别，假如你的电脑上安装了 OpenSSL，可以试试以下两条命令:<code>openssl speed rsa</code>、<code>openssl speed aes</code>。</p>\n</blockquote>\n<h3 id=\"2-2-TLS会话恢复（简短握手）\"><a href=\"#2-2-TLS会话恢复（简短握手）\" class=\"headerlink\" title=\"2.2 TLS会话恢复（简短握手）\"></a>2.2 TLS会话恢复（简短握手）</h3><h4 id=\"2-2-1-会话标识符\"><a href=\"#2-2-1-会话标识符\" class=\"headerlink\" title=\"2.2.1 会话标识符\"></a>2.2.1 会话标识符</h4><p>从上面我们可以知道一次握手需要两次额外的往返时间，为了挽回这些损失，TLS提供了恢复功能，即在多个连接间共享协商后的安全密钥。即，服务器创建32字节的会话标识符，并在上一节我们讨论的完整的TLS协商期间作为其“ServerHello”消息的一部分发送。<strong>借助会话标识符可以节省一次往返（参见下图），还可以省掉用于协商共享加密密钥的公钥加密计算</strong>。</p>\n<p><img src=\"../images/TLS_Handshare_simple.png\" alt=\"简短TLS握手协议\"></p>\n<h4 id=\"2-2-2-会话记录单\"><a href=\"#2-2-2-会话记录单\" class=\"headerlink\" title=\"2.2.2 会话记录单\"></a>2.2.2 会话记录单</h4><p>由于服务器必须为每个客户端都创建和维护一段会话缓存，这样的话，请求量大的服务器就需要维护大量的会话ID，并且还要指定一个高效的缓存、清除策略。为了解决这个问题，<strong>会话记录单</strong>应运而生，即，<strong>服务器可以在完整TLS握手的最后一次交换中添加一条“新会话记录单”(New Session Ticket)记录，包含只有服务器知道的安 全密钥加密过的所有会话数据。<br>然后，客户端将这个会话记录单保存起来，在后续会话的 ClientHello 消息中，以将其包含在SessionTicket扩展中。这样，所有会话数据只保存在客户端，而由于数据被加密过，且密钥只有服务器知道，因此仍然是安全的。</strong></p>\n<h3 id=\"2-3-证书链\"><a href=\"#2-3-证书链\" class=\"headerlink\" title=\"2.3 证书链\"></a>2.3 证书链</h3><p>身份验证是建立每个TLS连接必不可少的部分。毕竟，加密信道两端可以是任何机 器，包括攻击者的机器。为此，必须确保我们与之交谈的计算机是可信任的，否则 之前的工作都是徒劳。为理解如何验证通信两端的身份，下面我们以张三和李四之间的验证为例简单说明一下:</p>\n<ul>\n<li>张三和李四分别生成自己的公钥和私钥;</li>\n<li>张三和李四分别隐藏自己的私钥;</li>\n<li>张三向李四公开自己的公钥，李四也向张三公开自己的公钥; - 张三向李四发送一条新消息，并用自己的私钥签名;</li>\n<li>李四使用张三的公钥验证收到的消息签名。</li>\n</ul>\n<p>信任是上述交流的关键。公钥加密可以让我们使用发送端的公钥验证消息是否使用了正确的私钥签名，但认可发送端仍然是基于信任。在上述交流中，张三和李四可以当面交换自己的公钥，因为他们互相认识，能够保证不被别人冒名顶替。可以说，他们已经通过之前安全(物理)的握手确认了对方。</p>\n<p>接下来，张三收到王五发来的一条消息。张三从未见过王五，但王五自称是李四的朋友。事实上，为了证明自己是李四的朋友，王五还请李四用李四的私钥签署了自己的公钥，并在消息中附上了签名(见下图)。此时，张三首先检查王五公钥中李四 的签名。他知道李四的公钥，因而可以验证李四确实签署了王五的公钥。由于他信任李四对王五的签名，所以就接受了王五的消息，并对消息进行完整性检查，以确保消息确实来自王五。刚才这个过程建立了一个信任链:张三信任李四，李四信任王五，通过信任的传递，张三信任王五。只要这条链上的人不会被冒名顶替，我们就可以继续扩展这个信任网络。</p>\n<p><img src=\"../images/TLS_cer_sample.png\" alt=\"张三、李四和王五的信任链\"></p>\n<p>TLS的证书验证就跟上面的例子类似。只不过类似李四这样的中间人（中间证书）很多，这些证书是一级一级网上验证，直到根证书（一般浏览器内置了几百个可信任的根证书）。证书颁发机构签署数字证书如下图。</p>\n<p><img src=\"../images/TLS_Cer_auth.png\" alt=\"证书颁发机构签署数字证书\"></p>\n<p>证书颁发过程：</p>\n<ul>\n<li>根证书颁发中间证书。</li>\n<li>中间证书颁发站点证书。</li>\n</ul>\n<p>证书验证过程：</p>\n<ul>\n<li>从站点证书出发一直往上找到根证书。</li>\n<li>根证书验证中间证书。</li>\n<li>中间证书验证站点证书。</li>\n</ul>\n<h2 id=\"3-TLS记录协议\"><a href=\"#3-TLS记录协议\" class=\"headerlink\" title=\"3. TLS记录协议\"></a>3. TLS记录协议</h2><p>与位于其下的IP或TCP层没有什么不同，TLS会话中交换的所有数据同样使用规格明确的协议进行分帧(如下图)。TLS记录协议负责识别不同的消息类型(握手、警告或数据，通过“内容类型”字段)，以及每条消息的安全和完整性验证。</p>\n<p><img src=\"../images/TLS_Record_Struct.png\" alt=\"TLS记录结构\"></p>\n<p>交付应用数据的典型流程如下：</p>\n<ul>\n<li>记录协议接收应用数据。</li>\n<li>接收到的数据被切分为块:最大为每条记录214字节，即 16 KB。</li>\n<li>压缩应用数据(可选)。</li>\n<li>添加MAC(Message Authentication Code)或HMAC。</li>\n<li>使用商定的加密套件加密数据。</li>\n</ul>\n<p>以上几步完成后，加密数据就会被交给TCP层传输。接收端的流程相同，顺序相反:使用商定的加密套件解密数据、验证 MAC、提取并把数据转交给上层的应用。<br>同样，值得庆幸的是以上过程都由TLS层帮我们处理，而且对大多数应用都是完全透明的。不过，记录协议也带来了一些重要的限制，务必要注意:</p>\n<ul>\n<li>TLS记录最大为16KB;</li>\n<li>每条记录包含5字节的首部、MAC(在 SSL 3.0、TLS 1.0、TLS 1.1 中最多 20 字节，<br>在 TLS 1.2 中最多 32 字节)，如果使用块加密则还有填充;</li>\n<li>必须接收到整条记录才能开始解密和验证。</li>\n</ul>\n<p>有可能的话，应该自主选择记录大小，这也是一项重要的优化。小记录会因记录分帧而招致较大开销，大记录在被TLS层处理并交付应用之前，必须通过TCP传输和重新组装。</p>\n<h2 id=\"4-TLS性能检查清单\"><a href=\"#4-TLS性能检查清单\" class=\"headerlink\" title=\"4. TLS性能检查清单\"></a>4. TLS性能检查清单</h2><ul>\n<li>要最大限制提升TCP性能;</li>\n<li>把TLS库升级到最新版本，在此基础上构建(或重新构建)服务器;</li>\n<li>启用并配置会话缓存和无状态恢复;</li>\n<li>监控会话缓存的使用情况并作出相应调整;</li>\n<li>在接近用户的地方完成TLS会话，尽量减少往返延迟;</li>\n<li>配置TLS记录大小，使其恰好能封装在一个TCP段内;</li>\n<li>确保证书链不会超过拥塞窗口的大小;</li>\n<li>从信任链中去掉不必要的证书，减少链条层次;</li>\n<li>禁用服务器的TLS压缩功能;</li>\n<li>启用服务器对SNI 的支持;</li>\n<li>启用服务器的OCSP封套功能;</li>\n<li>追加HTTP严格传输安全首部。</li>\n</ul>\n<blockquote>\n<p>要验证和测试你的配置，可以使用 Qualys SSL Server Test(<a href=\"https://www\" target=\"_blank\" rel=\"external\">https://www</a>. ssllabs.com/ssltest/)等在线服务来扫描你的服务器，以发现常见的配置和安全漏洞。也可以通过<code>openssl s_client -state -CAfile startssl.ca.crt -connect igvita.com:443</code>来检查整个握手和本地服务器配置情况。</p>\n</blockquote>\n","excerpt":"","more":"<p><em>本文大部分内容整理自《Web性能权威指南》，仅供学习所用。</em></p>\n<h2 id=\"1-什么是TLS\"><a href=\"#1-什么是TLS\" class=\"headerlink\" title=\"1. 什么是TLS\"></a>1. 什么是TLS</h2><p>SSL(SecureSocketsLayer，安全套接字层)协议最初是网景公司为了保障网上交易安全而开发的，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。为达到这个目标，SSL协议在直接位于TCP上一层的应用层被实现(如下图)。SSL不会影响上层协议(如HTTP、电子邮件、即时通讯)，但能够保证上层协议的网络通信安全。</p>\n<p>SSL2.0是该协议第一个公开发布的版本，但由于存在很多安全缺陷很快就被SSL3.0取代。鉴于SSL协议是网景公司专有的，IETF成立了一个小组负责标准化该协议，后来就有了RFC2246，即TLS1.0，也就是SSL3.0的升级版。<strong>TLS包含两部分：握手协议、记录协议</strong>。</p>\n<p><img src=\"../images/TLS_in_OSI.png\" alt=\"传输层安全(TLS\"></p>\n<h2 id=\"2-TLS握手协议\"><a href=\"#2-TLS握手协议\" class=\"headerlink\" title=\"2. TLS握手协议\"></a>2. TLS握手协议</h2><h3 id=\"2-1-一般握手\"><a href=\"#2-1-一般握手\" class=\"headerlink\" title=\"2.1 一般握手\"></a>2.1 一般握手</h3><p>客户端与服务器在通过TLS交换数据之前，必须协商建立加密信道。协商内容包括TLS版本、加密套件，必要时还会验证证书。然而，协商过程的每一步都需要一个分组在客户端和服务器之间往返一次(如下图)，因而所有TLS连接启动时都要经历一定的延迟（最多需要两次额外往返）。</p>\n<p><img src=\"../images/TLS_HandShake.png\" alt=\"TLS握手协议\"></p>\n<ul>\n<li>0ms : TLS在可靠的传输层(TCP)之上运行，这意味着首先必须完成TCP的“三次握手”，即一次完整的往返。</li>\n<li>56ms : TCP连接建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的TLS协议的版本、它所支持的加密套件列表，以及它支持或希望使用的另外一些TLS选项。</li>\n<li>84ms : 然后，服务器取得TLS协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，再附上自己的证书，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他TLS扩展参数。</li>\n<li>112ms : 假设两端经过协商确定了共同的版本和加密套件，客户端也高高兴兴地把自己的证书提供给了服务器。然后，客户端会生成一个新的对称密钥，用服务器的公钥来加密，加密后发送给服务器，告诉服务器可以开始加密通信了。到目前为止，除了用服务器公钥加密的新对称密钥之外，所有数据都以明文形式发送。</li>\n<li>140ms : 最后，服务器解密出客户端发来的对称密钥，通过验证消息的MAC检测消息完整性，再返回给客户端一个加密的“Finished”消息。</li>\n<li>168ms : 客户端用它之前生成的对称密钥解密这条消息，验证MAC，如果一切顺利，则建立信道并开始发送应用数据。</li>\n</ul>\n<blockquote>\n<p>公钥加密系统(<a href=\"http://en.wikipedia.org/wiki/Public-key_cryptography)只在建立TLS信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称\">http://en.wikipedia.org/wiki/Public-key_cryptography)只在建立TLS信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称</a> 密钥并使用服务器的公钥对其加密，然后再将加密的对称密钥返回服务器。服务器继而用自己的私钥解密出客户端发来的对称密钥。接下来，客户端与服务器间的通信就全都使用客户端生成的共享密钥加密，这就是对称密钥加密。之所以这样设计，很大程度上是出于性能考虑，因为公钥加密需要很大的计算量。为了演示两者的差别，假如你的电脑上安装了 OpenSSL，可以试试以下两条命令:<code>openssl speed rsa</code>、<code>openssl speed aes</code>。</p>\n</blockquote>\n<h3 id=\"2-2-TLS会话恢复（简短握手）\"><a href=\"#2-2-TLS会话恢复（简短握手）\" class=\"headerlink\" title=\"2.2 TLS会话恢复（简短握手）\"></a>2.2 TLS会话恢复（简短握手）</h3><h4 id=\"2-2-1-会话标识符\"><a href=\"#2-2-1-会话标识符\" class=\"headerlink\" title=\"2.2.1 会话标识符\"></a>2.2.1 会话标识符</h4><p>从上面我们可以知道一次握手需要两次额外的往返时间，为了挽回这些损失，TLS提供了恢复功能，即在多个连接间共享协商后的安全密钥。即，服务器创建32字节的会话标识符，并在上一节我们讨论的完整的TLS协商期间作为其“ServerHello”消息的一部分发送。<strong>借助会话标识符可以节省一次往返（参见下图），还可以省掉用于协商共享加密密钥的公钥加密计算</strong>。</p>\n<p><img src=\"../images/TLS_Handshare_simple.png\" alt=\"简短TLS握手协议\"></p>\n<h4 id=\"2-2-2-会话记录单\"><a href=\"#2-2-2-会话记录单\" class=\"headerlink\" title=\"2.2.2 会话记录单\"></a>2.2.2 会话记录单</h4><p>由于服务器必须为每个客户端都创建和维护一段会话缓存，这样的话，请求量大的服务器就需要维护大量的会话ID，并且还要指定一个高效的缓存、清除策略。为了解决这个问题，<strong>会话记录单</strong>应运而生，即，<strong>服务器可以在完整TLS握手的最后一次交换中添加一条“新会话记录单”(New Session Ticket)记录，包含只有服务器知道的安 全密钥加密过的所有会话数据。<br>然后，客户端将这个会话记录单保存起来，在后续会话的 ClientHello 消息中，以将其包含在SessionTicket扩展中。这样，所有会话数据只保存在客户端，而由于数据被加密过，且密钥只有服务器知道，因此仍然是安全的。</strong></p>\n<h3 id=\"2-3-证书链\"><a href=\"#2-3-证书链\" class=\"headerlink\" title=\"2.3 证书链\"></a>2.3 证书链</h3><p>身份验证是建立每个TLS连接必不可少的部分。毕竟，加密信道两端可以是任何机 器，包括攻击者的机器。为此，必须确保我们与之交谈的计算机是可信任的，否则 之前的工作都是徒劳。为理解如何验证通信两端的身份，下面我们以张三和李四之间的验证为例简单说明一下:</p>\n<ul>\n<li>张三和李四分别生成自己的公钥和私钥;</li>\n<li>张三和李四分别隐藏自己的私钥;</li>\n<li>张三向李四公开自己的公钥，李四也向张三公开自己的公钥; - 张三向李四发送一条新消息，并用自己的私钥签名;</li>\n<li>李四使用张三的公钥验证收到的消息签名。</li>\n</ul>\n<p>信任是上述交流的关键。公钥加密可以让我们使用发送端的公钥验证消息是否使用了正确的私钥签名，但认可发送端仍然是基于信任。在上述交流中，张三和李四可以当面交换自己的公钥，因为他们互相认识，能够保证不被别人冒名顶替。可以说，他们已经通过之前安全(物理)的握手确认了对方。</p>\n<p>接下来，张三收到王五发来的一条消息。张三从未见过王五，但王五自称是李四的朋友。事实上，为了证明自己是李四的朋友，王五还请李四用李四的私钥签署了自己的公钥，并在消息中附上了签名(见下图)。此时，张三首先检查王五公钥中李四 的签名。他知道李四的公钥，因而可以验证李四确实签署了王五的公钥。由于他信任李四对王五的签名，所以就接受了王五的消息，并对消息进行完整性检查，以确保消息确实来自王五。刚才这个过程建立了一个信任链:张三信任李四，李四信任王五，通过信任的传递，张三信任王五。只要这条链上的人不会被冒名顶替，我们就可以继续扩展这个信任网络。</p>\n<p><img src=\"../images/TLS_cer_sample.png\" alt=\"张三、李四和王五的信任链\"></p>\n<p>TLS的证书验证就跟上面的例子类似。只不过类似李四这样的中间人（中间证书）很多，这些证书是一级一级网上验证，直到根证书（一般浏览器内置了几百个可信任的根证书）。证书颁发机构签署数字证书如下图。</p>\n<p><img src=\"../images/TLS_Cer_auth.png\" alt=\"证书颁发机构签署数字证书\"></p>\n<p>证书颁发过程：</p>\n<ul>\n<li>根证书颁发中间证书。</li>\n<li>中间证书颁发站点证书。</li>\n</ul>\n<p>证书验证过程：</p>\n<ul>\n<li>从站点证书出发一直往上找到根证书。</li>\n<li>根证书验证中间证书。</li>\n<li>中间证书验证站点证书。</li>\n</ul>\n<h2 id=\"3-TLS记录协议\"><a href=\"#3-TLS记录协议\" class=\"headerlink\" title=\"3. TLS记录协议\"></a>3. TLS记录协议</h2><p>与位于其下的IP或TCP层没有什么不同，TLS会话中交换的所有数据同样使用规格明确的协议进行分帧(如下图)。TLS记录协议负责识别不同的消息类型(握手、警告或数据，通过“内容类型”字段)，以及每条消息的安全和完整性验证。</p>\n<p><img src=\"../images/TLS_Record_Struct.png\" alt=\"TLS记录结构\"></p>\n<p>交付应用数据的典型流程如下：</p>\n<ul>\n<li>记录协议接收应用数据。</li>\n<li>接收到的数据被切分为块:最大为每条记录214字节，即 16 KB。</li>\n<li>压缩应用数据(可选)。</li>\n<li>添加MAC(Message Authentication Code)或HMAC。</li>\n<li>使用商定的加密套件加密数据。</li>\n</ul>\n<p>以上几步完成后，加密数据就会被交给TCP层传输。接收端的流程相同，顺序相反:使用商定的加密套件解密数据、验证 MAC、提取并把数据转交给上层的应用。<br>同样，值得庆幸的是以上过程都由TLS层帮我们处理，而且对大多数应用都是完全透明的。不过，记录协议也带来了一些重要的限制，务必要注意:</p>\n<ul>\n<li>TLS记录最大为16KB;</li>\n<li>每条记录包含5字节的首部、MAC(在 SSL 3.0、TLS 1.0、TLS 1.1 中最多 20 字节，<br>在 TLS 1.2 中最多 32 字节)，如果使用块加密则还有填充;</li>\n<li>必须接收到整条记录才能开始解密和验证。</li>\n</ul>\n<p>有可能的话，应该自主选择记录大小，这也是一项重要的优化。小记录会因记录分帧而招致较大开销，大记录在被TLS层处理并交付应用之前，必须通过TCP传输和重新组装。</p>\n<h2 id=\"4-TLS性能检查清单\"><a href=\"#4-TLS性能检查清单\" class=\"headerlink\" title=\"4. TLS性能检查清单\"></a>4. TLS性能检查清单</h2><ul>\n<li>要最大限制提升TCP性能;</li>\n<li>把TLS库升级到最新版本，在此基础上构建(或重新构建)服务器;</li>\n<li>启用并配置会话缓存和无状态恢复;</li>\n<li>监控会话缓存的使用情况并作出相应调整;</li>\n<li>在接近用户的地方完成TLS会话，尽量减少往返延迟;</li>\n<li>配置TLS记录大小，使其恰好能封装在一个TCP段内;</li>\n<li>确保证书链不会超过拥塞窗口的大小;</li>\n<li>从信任链中去掉不必要的证书，减少链条层次;</li>\n<li>禁用服务器的TLS压缩功能;</li>\n<li>启用服务器对SNI 的支持;</li>\n<li>启用服务器的OCSP封套功能;</li>\n<li>追加HTTP严格传输安全首部。</li>\n</ul>\n<blockquote>\n<p>要验证和测试你的配置，可以使用 Qualys SSL Server Test(<a href=\"https://www\">https://www</a>. ssllabs.com/ssltest/)等在线服务来扫描你的服务器，以发现常见的配置和安全漏洞。也可以通过<code>openssl s_client -state -CAfile startssl.ca.crt -connect igvita.com:443</code>来检查整个握手和本地服务器配置情况。</p>\n</blockquote>\n"},{"title":"Thrift的二进制数据编解码--以OC为例","date":"2016-04-16T14:56:14.000Z","description":"Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码...","_content":"\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","source":"_posts/Thrift的二进制数据编解码-以OC为例.md","raw":"---\ntitle: Thrift的二进制数据编解码--以OC为例\ndate: 2016-04-16 22:56:14\ndescription: \"Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码...\"\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 什么是Thrift\nThrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过[这里](https://zh.wikipedia.org/wiki/Thrift)了解。\n\n## 为什么使用Thrift\n在本人的实际项目中主要考虑到这两个优点：\n* RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。\n* Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。\n\n## Thrift的数据编解码\n我们知道json中一个对象类似于这样的：{\"key\":\"content\"},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：\n![write:方法][1]\n![read:方法][2]\n\n我们看到1中`[outProtocol writeFieldBeginWithName: @\"actionId\" type: TType_I64 fieldID: 1];`的实现是这样的：\n```- (void) writeFieldBeginWithName: (NSString *) name\n                            type: (int) fieldType\n                         fieldID: (int) fieldID\n{\n  [self writeByte: CheckedCastIntToUInt8(fieldType)];\n  [self writeI16: CheckedCastIntToUInt8(fieldID)];\n}```\n注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required\ti64\tactionId\t 中的1）。再看看2中```[inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：\n```- (void) readFieldBeginReturningName: (NSString **) name\n                                type: (int *) fieldType\n                             fieldID: (int *) fieldID\n{\n  if (name != NULL) {\n    *name = nil;\n  }\n  int ft = [self readByte];\n  if (fieldType != NULL) {\n    *fieldType = ft;\n  }\n  if (ft != TType_STOP) {\n    int fid = [self readI16];\n    if (fieldID != NULL) {\n      *fieldID = fid;\n    }\n  }\n}```\n同样的也没有使用到参数name。\n我们再看下面这个例子：\n假如服务器使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId\t \n\t2:required  string\tvalue\n}```\n而客户端使用的ExamConfig定义是这样的：\n```struct ExamConfig\n{\n\t1:required\ti64\tactionId2\t \n\t2:required  string\tvalue2\n}```\n请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。\n## 结论\n这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true","slug":"Thrift的二进制数据编解码-以OC为例","published":1,"updated":"2016-11-15T09:31:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth470014givbx0h4riqt","content":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\" target=\"_blank\" rel=\"external\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是Thrift\"><a href=\"#什么是Thrift\" class=\"headerlink\" title=\"什么是Thrift\"></a>什么是Thrift</h2><p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。更多详情可以通过<a href=\"https://zh.wikipedia.org/wiki/Thrift\">这里</a>了解。</p>\n<h2 id=\"为什么使用Thrift\"><a href=\"#为什么使用Thrift\" class=\"headerlink\" title=\"为什么使用Thrift\"></a>为什么使用Thrift</h2><p>在本人的实际项目中主要考虑到这两个优点：</p>\n<ul>\n<li>RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</li>\n<li>Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。这也是本文讨论的重点。</li>\n</ul>\n<h2 id=\"Thrift的数据编解码\"><a href=\"#Thrift的数据编解码\" class=\"headerlink\" title=\"Thrift的数据编解码\"></a>Thrift的数据编解码</h2><p>我们知道json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。这是怎么做到的呢？首先我们在Example.thrift文件中定义了这么一个结构：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后用命令thrift -gen cocoa编译出来的OC代码，我们随便打开一个Thrift编出来的对象可以看到都会有一个write:方法和一个read:方法，例如：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/1.png?raw=true\" alt=\"write:方法\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Thrift_protocol/2.png?raw=true\" alt=\"read:方法\"></p>\n<p>我们看到1中<code>[outProtocol writeFieldBeginWithName: @&quot;actionId&quot; type: TType_I64 fieldID: 1];</code>的实现是这样的：<br><figure class=\"highlight plain\"><figcaption><span>(void) writeFieldBeginWithName: (NSString *) name</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">                            type: (int) fieldType</div><div class=\"line\">                         fieldID: (int) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  [self writeByte: CheckedCastIntToUInt8(fieldType)];</div><div class=\"line\">  [self writeI16: CheckedCastIntToUInt8(fieldID)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意到参数name实际中并没有被使用，只使用了fieldType（数据类型）、fieldID（协议定义中的序号,比如1:required    i64    actionId     中的1）。再看看2中<figure class=\"highlight plain\"><figcaption><span>readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];```的实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```- (void) readFieldBeginReturningName: (NSString **) name</div><div class=\"line\">                                type: (int *) fieldType</div><div class=\"line\">                             fieldID: (int *) fieldID</div><div class=\"line\">&#123;</div><div class=\"line\">  if (name != NULL) &#123;</div><div class=\"line\">    *name = nil;</div><div class=\"line\">  &#125;</div><div class=\"line\">  int ft = [self readByte];</div><div class=\"line\">  if (fieldType != NULL) &#123;</div><div class=\"line\">    *fieldType = ft;</div><div class=\"line\">  &#125;</div><div class=\"line\">  if (ft != TType_STOP) &#123;</div><div class=\"line\">    int fid = [self readI16];</div><div class=\"line\">    if (fieldID != NULL) &#123;</div><div class=\"line\">      *fieldID = fid;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同样的也没有使用到参数name。<br>我们再看下面这个例子：<br>假如服务器使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId\t </div><div class=\"line\">\t2:required  string\tvalue</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而客户端使用的ExamConfig定义是这样的：<br><figure class=\"highlight plain\"><figcaption><span>ExamConfig</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t1:required\ti64\tactionId2\t </div><div class=\"line\">\t2:required  string\tvalue2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>请问服务器发送ExamConfig数据到客户端客户端能正确的解析出数据吗？答案是YES。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>这就说明了我们定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p>\n<hr>\n"},{"title":"iOS中的MAX(A,B)，需要注意的点","date":"2016-04-19T03:22:30.000Z","_content":"\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","source":"_posts/iOS中的MAX-A-B-，需要注意的点.md","raw":"---\ntitle: iOS中的MAX(A,B)，需要注意的点\ndate: 2016-04-19 11:22:30\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 问题由来\n今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：\n![代码1][1]\n\n而执行的结果竟然是这样的：\n![结果1][2]\n\n“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：\n![MAX源码][3]\n\n## 验证过程\n然后我做了如下两个实验（请注意调试区a的类型）：\n\n### 实验1：（a的类型为unsigned long）\n![实验1][4]\n\n### 实验2：（a的类型为int）\n![实验2][5]\n\n通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此__typeof_(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：\n![结果][6]\n\n## 结论：\n当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：\n![结论][7]\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\n[7]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true","slug":"iOS中的MAX-A-B-，需要注意的点","published":1,"updated":"2016-10-15T11:24:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth480016givb4ot9c18p","content":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"问题由来\"><a href=\"#问题由来\" class=\"headerlink\" title=\"问题由来\"></a>问题由来</h2><p>今天有朋友在使用MAX(A,B)的时候出现了一个诡异的问题,代码是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/1.jpeg?raw=true\" alt=\"代码1\"></p>\n<p>而执行的结果竟然是这样的：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/2.jpeg?raw=true\" alt=\"结果1\"></p>\n<p>“我是不是眼花了？max(-1,0)返回了-1？”我的朋友惊讶到。这不科学啊，怎么会负数比0大呢？于是我查看了MAX(A,B)的源码：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/3.png?raw=true\" alt=\"MAX源码\"></p>\n<h2 id=\"验证过程\"><a href=\"#验证过程\" class=\"headerlink\" title=\"验证过程\"></a>验证过程</h2><p>然后我做了如下两个实验（请注意调试区a的类型）：</p>\n<h3 id=\"实验1：（a的类型为unsigned-long）\"><a href=\"#实验1：（a的类型为unsigned-long）\" class=\"headerlink\" title=\"实验1：（a的类型为unsigned long）\"></a>实验1：（a的类型为unsigned long）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/4.jpeg?raw=true\" alt=\"实验1\"></p>\n<h3 id=\"实验2：（a的类型为int）\"><a href=\"#实验2：（a的类型为int）\" class=\"headerlink\" title=\"实验2：（a的类型为int）\"></a>实验2：（a的类型为int）</h3><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/5.png?raw=true\" alt=\"实验2\"></p>\n<p>通过这两个实验我们可以发现：由于NSArray的count属性是个NSUInteger类型，因此_<em>typeof</em>(array.count - 1) 会得到一个无符号的类型，当array.count - 1为负数的时候，就相当于(NSUInteger)(负数) = 正数，因此会有MAX(array.count - 1, 0) = (NSUInteger)（array.count - 1）。如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/6.png?raw=true\" alt=\"结果\"></p>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><p>当使用MAX(A,B)取大值的时候要注意A、B是否是无符号型，可以统一将它们转换成有符号型来进行比较。如下图：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/Max(A,B)/7.png?raw=true\" alt=\"结论\"></p>\n<hr>\n"},{"title":"iOS引导页的镂空效果","date":"2016-04-29T14:06:55.000Z","description":"最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库...","_content":"\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","source":"_posts/iOS引导页的镂空效果.md","raw":"---\ntitle: iOS引导页的镂空效果\ndate: 2016-04-29 22:06:55\ndescription: \"最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库...\"\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n## 初衷\n最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：[EAFeatureGuideView](https://github.com/Easence/EAFeatureGuideView)。\n## EAFeatureGuideView能做什么\nEAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：\n- 局部区域高亮（可以设置圆角）\n- 有箭头指向高亮区域\n- 可以设置一段介绍文字（可以是图片、也可以是文字）\n- 可以对应一个按钮，可以通过配置事件、标题。\n最后的效果如下：\n![效果图1][1]\n![效果图2][2]\n\n## 如何使用\n如果安装了Cocoapods,可以在Podfile中加入如下代码：\n\n```\npod 'EAFeatureGuideView\npod install\n```\n接着在需要展示提示的页面引入头文件：\n\n```\n#import \"UIView+EAFeatureGuideView.h\"\n```\n最后添加如下代码：\n```\nEAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];\nitem.introduce = @\"txt_feature_post_activity_4.1.png\";\nitem.actionTitle = @\"太好了\";\nitem.action = ^(id sender){\n        NSLog(@\"touched ..\");  \n    };\n\nEAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    \nrecents.introduce = @\"recents\";\n\n[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@\"keyName\" inVersion:nil];\n```\n## 可以优化的地方\n- 介绍文案没有支持多颜色。\n- 当高亮区域是圆形的时候，箭头的指向没有对中圆心。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true","slug":"iOS引导页的镂空效果","published":1,"updated":"2016-11-15T09:30:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth49001agivbx0d7ujd4","content":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h2><p>最近项目新功能更改较大，产品童鞋要求加入新功能引导，于是一口气花了两天的时间做了一个引导页，当然加上后面的修修补补的时间，就不只两天了，不过这事情其实是一劳永逸的事情，值得做。同时为了能够更好的复用，我把它做成了pod库，项目地址在这里：<a href=\"https://github.com/Easence/EAFeatureGuideView\">EAFeatureGuideView</a>。</p>\n<h2 id=\"EAFeatureGuideView能做什么\"><a href=\"#EAFeatureGuideView能做什么\" class=\"headerlink\" title=\"EAFeatureGuideView能做什么\"></a>EAFeatureGuideView能做什么</h2><p>EAFeatureGuideView是UIView的一个扩展，用来做新功能引导提示，达到这样的效果：</p>\n<ul>\n<li>局部区域高亮（可以设置圆角）</li>\n<li>有箭头指向高亮区域</li>\n<li>可以设置一段介绍文字（可以是图片、也可以是文字）</li>\n<li>可以对应一个按钮，可以通过配置事件、标题。<br>最后的效果如下：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/1.png?raw=true\" alt=\"效果图1\"><br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAFeatureGuideView/2.png?raw=true\" alt=\"效果图2\"></li>\n</ul>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>如果安装了Cocoapods,可以在Podfile中加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;EAFeatureGuideView</div><div class=\"line\">pod install</div></pre></td></tr></table></figure>\n<p>接着在需要展示提示的页面引入头文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIView+EAFeatureGuideView.h&quot;</div></pre></td></tr></table></figure>\n<p>最后添加如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">EAFeatureItem *item = [[EAFeatureItem alloc] initWithFocusView:self.exampleCell focusCornerRadius:0 focusInsets:UIEdgeInsetsZero];</div><div class=\"line\">item.introduce = @&quot;txt_feature_post_activity_4.1.png&quot;;</div><div class=\"line\">item.actionTitle = @&quot;太好了&quot;;</div><div class=\"line\">item.action = ^(id sender)&#123;</div><div class=\"line\">        NSLog(@&quot;touched ..&quot;);  </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">EAFeatureItem *recents = [[EAFeatureItem alloc] initWithFocusRect:CGRectMake(centerX - 25, centerY - 25, 50, 50) focusCornerRadius:25 focusInsets:UIEdgeInsetsZero];    </div><div class=\"line\">recents.introduce = @&quot;recents&quot;;</div><div class=\"line\"></div><div class=\"line\">[self.navigationController.view showWithFeatureItems:@[item, recents] saveKeyName:@&quot;keyName&quot; inVersion:nil];</div></pre></td></tr></table></figure></p>\n<h2 id=\"可以优化的地方\"><a href=\"#可以优化的地方\" class=\"headerlink\" title=\"可以优化的地方\"></a>可以优化的地方</h2><ul>\n<li>介绍文案没有支持多颜色。</li>\n<li>当高亮区域是圆形的时候，箭头的指向没有对中圆心。</li>\n</ul>\n<hr>\n"},{"title":"iOS开发之新版APNs搭建必备知识","date":"2016-12-20T10:31:37.000Z","_content":"\n*本文的大部分内容是对苹果关于APNs官方文档的翻译以及整理。*\n\n## 一、设备token和消息的生命周期\n关于设备token以及推送消息的生命周期需要注意下面几点：\n\n- Token会在iOS系统更新或者设备数据、设置被擦除的时候改变。\n- 当设备离线的时候，APNS会将消息数据存储一段时间，等设备上线后重发。如果设备在离线期间，向APNS发送了多条推送消息，APNS将会丢弃掉前面的一些消息，只保留后面的消息，要是设备长时间离线，则会将所有的消息丢弃掉。\n- 可以通过设置http/2头中的`apns-collapse-id`键值对来合并消息，比如：`apns-collapse-id : 2`，那么value为2的消息将被APNS合并成一条消息推送给设备。\n\n## 二、Provider（后台）与APNs的交互\n\nProvider（即，APP的后台）与APNS有两种安全的交互方式，都必须采用TLS以保证可靠性，更详细的内容继续往下看。\n> `TLS`的简单理解是，为了保证数据传输安全，在HTTP层与TCP层之间插入的一个安全校验层，它所做的事情简单来说就是：**“通过CA申请的证书验证client与server是可靠的之后，通过相应的公私钥加密一个`协商的公钥`，之后的真实数据传输就使用这个公钥进行加密，以保证数据的安全可靠性”**，关于TLS的更详细的介绍，可以参考[这篇文章](https://segmentfault.com/a/1190000002554673)\n\n### 基于Token的方式（Token-Based Provider-to-APNs Trust）\n\n#### 1、流程概述\n这种方式适合在基于HTTP/2协议的Provider使用，它与APNs之间的连接通过[JWT（JSON web tokens）](https://tools.ietf.org/html/rfc7519)来验证。在这种方式下不需要使用证书+私钥的方式来建立可靠连接。Provider只需要提供一个一对公私钥（私钥给APNs保存，公钥Provider自己保存）,并使用其中的私钥生成并加密JWT Token，每次向APNs请求推送的时候带上这个Token即可。\n\n具体步骤如下：\n\n1. Provider通过`TLS`向APNs发起请求。\n2. APNs返回一个证书给Provider。\n3. Provier验证这个证书。通过后，发送push数据并带上JWT token。\n4. APNs验证token，并返回请求的结果。\n\n![Establishing and using token-based connection trust between a provider and APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_2x.png)\n\n\n> 建立TLS连接必须要有一个`GeoTrust Global CA root certificate`，在macOS中，这个证书已经安装在keychain中，如果是其他操作系统则可以在[GeoTrust Root Certificates website](https://www.geotrust.com/resources/root-certificates/)下载。\n\n#### 2、Provider Authentication Tokens\n关于JWT（JSON Web Token）的详细资料可以通过[这里](https://tools.ietf.org/html/rfc7519)了解。同时也可以从[这里](https://jwt.io)找到一些现成可用的库。\n\n下面对JWT进行详细的介绍，一个JWT实际上是一个JSON对象，它的头部必须包含：\n\n- 用以加密token的加密算法(**alg**) ，比如：ES256。\n- 10个字符长度的标识符(**kid**)，（登入苹果开发者账号后，进入到**Certificates, Identifiers & Profiles**，然后点击**APNs Auth Key**，最后在右侧找到**Apple Push Notification Authentication Key (Sandbox & Production)**选项，点击创建后可以创建一个p8文件。）\n\n同时他的claims payload部分必须包含：\n\n- issuer(**iss**) registered claim key，其值就是10个字符长的Team ID。\n- issued at (**iat**) registered claim key，其值是一个秒级的UTC时间戳。\n\n比如：\n\n```\n{\n    \"alg\": \"ES256\",\n    \"kid\": \"ABC123DEFG\"\n}\n{\n    \"iss\": \"DEF123GHIJ\",\n    \"iat\": 1437179036\n }\n```\n创建完这个token后，必须使用自己的私钥对其进行加密，然后再采用基于P-256曲线和SHA-256哈希算法的椭圆曲线数字签名算法（ECDSA）进行签名，并将`alg`键的值设置为`ES256`。(注意：APNs只支持**ES256**签名的JWT，否则会返回`InvalidProviderToken(403)`错误)\n\n为了保证安全，APNs要求定期更新token，时间间隔为1小时，如果APNs发现当前的时间戳与`iat`值中的时间戳相比，大于一个小时，那么APNs会拒绝推送消息，并返回`ExpiredProviderToken (403)`错误。\n\n### 基于证书的方式（Certificate-based connection trust)\n\n#### 流程概述\n\n这种方式是指Provider可以采用一个唯一的证书以及一个加密的私钥来与APNs交互，其中证书是由苹果产生的（通过苹果账号登录到[developer account](https://developer.apple.com/account/#/welcome)配置创建）。整个交互过程如下：\n\n1. Provider通过`TLS`向APNs请求连接。\n2. APNs向Provider返回一个APNs证书。\n3. Provider验证这个APNs证书，并将从苹果官网获取的证书返回给APNs。\n4. APNs验证通过后，这个链接就算是建立了。\n\n![Establishing certificate-based connection trust between a provider and APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_certificate_2x.png)\n\n#### APNs Provider Certificates\n创建步骤可以参考[Configure push notifications](https://help.apple.com/xcode/mac/8.1/index.html?localePath=en.lproj#/dev11b059073)中的Generate a universal APNs client SSL certificate章节。\n\n## 三、APNs连接\n\n### 连接的管理\n苹果的两个APNs server分别为：\n\n- **Development server:** `api.development.push.apple.com:443`\n- **Production server:** `api.push.apple.com:443`\n\n要与APNs交互要求server必须支持1.2及上版本的TLS协议。通过上面的介绍我们已经知道，server跟APNs交互有两种方式：基于JWT的方式以及基于证书的方式。为了保证高质量的使用APNs应该注意如下几点：\n\n- 对于基于JWT的方式，应该定时更新token，token的有效期为1小时。\n- 对于基于JWT的方式，能每次请求都创建新的token，尽量在一小时内使用同一个token。\n- 不能频繁的建立、关闭连接，否则APNs会把这当做是黑客攻击，拒绝访问。应该尽量将连接保活，直到你认为这个连接接下来会长时间不使用为止。\n- 当需要发送大量的推送数据的时候，可以同时创建多个连接，以改善性能。\n- 当吊销证书或者token时，应该关闭所有相关的连接。\n\n### HTTP/2的请求与响应\n详情可参见苹果官方文档[HTTP/2 Request to APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2)。这里介绍了接口的**请求参数**、**返回结果**，**错误码**以及**示例代码**。下面仅截取了其中的例子，以加深对APNs的使用的理解：\n\n- 基于证书的方式的request：\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t  :method = POST\n\t  :scheme = https\n\t  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0\n\t  host = api.development.push.apple.com\n\t  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b //可以不填，如果不填APNs会自己创建一个UUID并在response中返回\n\t  apns-expiration = 0\n\t  apns-priority = 10\n\tDATA\n\t  + END_STREAM\n\t    { \"aps\" : { \"alert\" : \"Hello\" } }\n\t```\n\t\n- 基于token方式的request：\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t  :method = POST\n\t  :scheme = https\n\t  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0\n\t  host = api.development.push.apple.com\n\t  authorization = bearer eyAia2lkIjogIjhZTDNHM1JSWDciIH0.eyAiaXNzIjogIkM4Nk5WOUpYM0QiLCAiaWF0I\n\t jogIjE0NTkxNDM1ODA2NTAiIH0.MEYCIQDzqyahmH1rz1s-LFNkylXEa2lZ_aOCX4daxxTZkVEGzwIhALvkClnx5m5eAT6\n\t Lxw7LZtEQcH6JENhJTMArwLf3sXwi\n\t  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n\t  apns-expiration = 0\n\t  apns-priority = 10\n\t  apns-topic = <MyAppTopic>\n\tDATA\n\t  + END_STREAM\n\t    { \"aps\" : { \"alert\" : \"Hello\" } }\n\n\t```\n\t\n- 失败后的response:\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t  :status = 400\n\t  content-type = application/json\n\t    apns-id: <a_UUID>\n\tDATA\n\t  + END_STREAM\n\t  { \"reason\" : \"BadDeviceToken\" }\n\t```\n\t\n- 成功后的response：\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t\tapns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n\t\t:status = 200\n\t``` \n\n## 四、设备token的生成与分发\n在app启动的时候，必须向iOS系统注册远程推送，成功后，苹果将会返回一个设备token给app，此时app就可以将这个token上报给自己的后台。\n\n如果有必要产生一个新的token，APNs会使用设备证书生成一个token（其中包含了一个设备ID），并使用token key加密后返回给设备。同时设备会将这个token以`NSData`对象的形式返回给app，app获取到该token之后应该将其发送到自己后台，后台之后就可以通过这个token来发送推送数据。过程如下图：\n\n![Managing the device token](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/token_generation_2x.png)\n\n## 最后\n通过苹果的官方文档我们可以知道provider与APNs的交互过程中，需要注意一下几点：\n\n- 推荐使用`HTTP/2`协议。\n- 必须加入`TLS`层。\n- 基于JWT的方式，token的最大有效期为1小时，并且不能频繁更换token。\n- 不能频繁创建、关闭连接，应该尽量少开连接，如果过于频繁，APNs将把其当做是黑客攻击，但是如果数据量大，可以同时多个连接向APNs发送消息。\n- 吊销token或者证书的时候，应该及时关闭老的连接。\n\n## 参考文献\n1. [APNs Overview](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1)\n2. [Communicating with APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2)\n\n\n\n\n","source":"_posts/iOS_APNs.md","raw":"---\ntitle: iOS开发之新版APNs搭建必备知识\ndate: 2016-12-20 18:31:37\ncategories:\n - Apple Development\n - iOS开发笔记\ntags: \n- 推送\n- APNs\n---\n\n*本文的大部分内容是对苹果关于APNs官方文档的翻译以及整理。*\n\n## 一、设备token和消息的生命周期\n关于设备token以及推送消息的生命周期需要注意下面几点：\n\n- Token会在iOS系统更新或者设备数据、设置被擦除的时候改变。\n- 当设备离线的时候，APNS会将消息数据存储一段时间，等设备上线后重发。如果设备在离线期间，向APNS发送了多条推送消息，APNS将会丢弃掉前面的一些消息，只保留后面的消息，要是设备长时间离线，则会将所有的消息丢弃掉。\n- 可以通过设置http/2头中的`apns-collapse-id`键值对来合并消息，比如：`apns-collapse-id : 2`，那么value为2的消息将被APNS合并成一条消息推送给设备。\n\n## 二、Provider（后台）与APNs的交互\n\nProvider（即，APP的后台）与APNS有两种安全的交互方式，都必须采用TLS以保证可靠性，更详细的内容继续往下看。\n> `TLS`的简单理解是，为了保证数据传输安全，在HTTP层与TCP层之间插入的一个安全校验层，它所做的事情简单来说就是：**“通过CA申请的证书验证client与server是可靠的之后，通过相应的公私钥加密一个`协商的公钥`，之后的真实数据传输就使用这个公钥进行加密，以保证数据的安全可靠性”**，关于TLS的更详细的介绍，可以参考[这篇文章](https://segmentfault.com/a/1190000002554673)\n\n### 基于Token的方式（Token-Based Provider-to-APNs Trust）\n\n#### 1、流程概述\n这种方式适合在基于HTTP/2协议的Provider使用，它与APNs之间的连接通过[JWT（JSON web tokens）](https://tools.ietf.org/html/rfc7519)来验证。在这种方式下不需要使用证书+私钥的方式来建立可靠连接。Provider只需要提供一个一对公私钥（私钥给APNs保存，公钥Provider自己保存）,并使用其中的私钥生成并加密JWT Token，每次向APNs请求推送的时候带上这个Token即可。\n\n具体步骤如下：\n\n1. Provider通过`TLS`向APNs发起请求。\n2. APNs返回一个证书给Provider。\n3. Provier验证这个证书。通过后，发送push数据并带上JWT token。\n4. APNs验证token，并返回请求的结果。\n\n![Establishing and using token-based connection trust between a provider and APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_2x.png)\n\n\n> 建立TLS连接必须要有一个`GeoTrust Global CA root certificate`，在macOS中，这个证书已经安装在keychain中，如果是其他操作系统则可以在[GeoTrust Root Certificates website](https://www.geotrust.com/resources/root-certificates/)下载。\n\n#### 2、Provider Authentication Tokens\n关于JWT（JSON Web Token）的详细资料可以通过[这里](https://tools.ietf.org/html/rfc7519)了解。同时也可以从[这里](https://jwt.io)找到一些现成可用的库。\n\n下面对JWT进行详细的介绍，一个JWT实际上是一个JSON对象，它的头部必须包含：\n\n- 用以加密token的加密算法(**alg**) ，比如：ES256。\n- 10个字符长度的标识符(**kid**)，（登入苹果开发者账号后，进入到**Certificates, Identifiers & Profiles**，然后点击**APNs Auth Key**，最后在右侧找到**Apple Push Notification Authentication Key (Sandbox & Production)**选项，点击创建后可以创建一个p8文件。）\n\n同时他的claims payload部分必须包含：\n\n- issuer(**iss**) registered claim key，其值就是10个字符长的Team ID。\n- issued at (**iat**) registered claim key，其值是一个秒级的UTC时间戳。\n\n比如：\n\n```\n{\n    \"alg\": \"ES256\",\n    \"kid\": \"ABC123DEFG\"\n}\n{\n    \"iss\": \"DEF123GHIJ\",\n    \"iat\": 1437179036\n }\n```\n创建完这个token后，必须使用自己的私钥对其进行加密，然后再采用基于P-256曲线和SHA-256哈希算法的椭圆曲线数字签名算法（ECDSA）进行签名，并将`alg`键的值设置为`ES256`。(注意：APNs只支持**ES256**签名的JWT，否则会返回`InvalidProviderToken(403)`错误)\n\n为了保证安全，APNs要求定期更新token，时间间隔为1小时，如果APNs发现当前的时间戳与`iat`值中的时间戳相比，大于一个小时，那么APNs会拒绝推送消息，并返回`ExpiredProviderToken (403)`错误。\n\n### 基于证书的方式（Certificate-based connection trust)\n\n#### 流程概述\n\n这种方式是指Provider可以采用一个唯一的证书以及一个加密的私钥来与APNs交互，其中证书是由苹果产生的（通过苹果账号登录到[developer account](https://developer.apple.com/account/#/welcome)配置创建）。整个交互过程如下：\n\n1. Provider通过`TLS`向APNs请求连接。\n2. APNs向Provider返回一个APNs证书。\n3. Provider验证这个APNs证书，并将从苹果官网获取的证书返回给APNs。\n4. APNs验证通过后，这个链接就算是建立了。\n\n![Establishing certificate-based connection trust between a provider and APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_certificate_2x.png)\n\n#### APNs Provider Certificates\n创建步骤可以参考[Configure push notifications](https://help.apple.com/xcode/mac/8.1/index.html?localePath=en.lproj#/dev11b059073)中的Generate a universal APNs client SSL certificate章节。\n\n## 三、APNs连接\n\n### 连接的管理\n苹果的两个APNs server分别为：\n\n- **Development server:** `api.development.push.apple.com:443`\n- **Production server:** `api.push.apple.com:443`\n\n要与APNs交互要求server必须支持1.2及上版本的TLS协议。通过上面的介绍我们已经知道，server跟APNs交互有两种方式：基于JWT的方式以及基于证书的方式。为了保证高质量的使用APNs应该注意如下几点：\n\n- 对于基于JWT的方式，应该定时更新token，token的有效期为1小时。\n- 对于基于JWT的方式，能每次请求都创建新的token，尽量在一小时内使用同一个token。\n- 不能频繁的建立、关闭连接，否则APNs会把这当做是黑客攻击，拒绝访问。应该尽量将连接保活，直到你认为这个连接接下来会长时间不使用为止。\n- 当需要发送大量的推送数据的时候，可以同时创建多个连接，以改善性能。\n- 当吊销证书或者token时，应该关闭所有相关的连接。\n\n### HTTP/2的请求与响应\n详情可参见苹果官方文档[HTTP/2 Request to APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2)。这里介绍了接口的**请求参数**、**返回结果**，**错误码**以及**示例代码**。下面仅截取了其中的例子，以加深对APNs的使用的理解：\n\n- 基于证书的方式的request：\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t  :method = POST\n\t  :scheme = https\n\t  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0\n\t  host = api.development.push.apple.com\n\t  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b //可以不填，如果不填APNs会自己创建一个UUID并在response中返回\n\t  apns-expiration = 0\n\t  apns-priority = 10\n\tDATA\n\t  + END_STREAM\n\t    { \"aps\" : { \"alert\" : \"Hello\" } }\n\t```\n\t\n- 基于token方式的request：\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t  :method = POST\n\t  :scheme = https\n\t  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0\n\t  host = api.development.push.apple.com\n\t  authorization = bearer eyAia2lkIjogIjhZTDNHM1JSWDciIH0.eyAiaXNzIjogIkM4Nk5WOUpYM0QiLCAiaWF0I\n\t jogIjE0NTkxNDM1ODA2NTAiIH0.MEYCIQDzqyahmH1rz1s-LFNkylXEa2lZ_aOCX4daxxTZkVEGzwIhALvkClnx5m5eAT6\n\t Lxw7LZtEQcH6JENhJTMArwLf3sXwi\n\t  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n\t  apns-expiration = 0\n\t  apns-priority = 10\n\t  apns-topic = <MyAppTopic>\n\tDATA\n\t  + END_STREAM\n\t    { \"aps\" : { \"alert\" : \"Hello\" } }\n\n\t```\n\t\n- 失败后的response:\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t  :status = 400\n\t  content-type = application/json\n\t    apns-id: <a_UUID>\n\tDATA\n\t  + END_STREAM\n\t  { \"reason\" : \"BadDeviceToken\" }\n\t```\n\t\n- 成功后的response：\n\n\t```\n\tHEADERS\n\t  - END_STREAM\n\t  + END_HEADERS\n\t\tapns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n\t\t:status = 200\n\t``` \n\n## 四、设备token的生成与分发\n在app启动的时候，必须向iOS系统注册远程推送，成功后，苹果将会返回一个设备token给app，此时app就可以将这个token上报给自己的后台。\n\n如果有必要产生一个新的token，APNs会使用设备证书生成一个token（其中包含了一个设备ID），并使用token key加密后返回给设备。同时设备会将这个token以`NSData`对象的形式返回给app，app获取到该token之后应该将其发送到自己后台，后台之后就可以通过这个token来发送推送数据。过程如下图：\n\n![Managing the device token](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/token_generation_2x.png)\n\n## 最后\n通过苹果的官方文档我们可以知道provider与APNs的交互过程中，需要注意一下几点：\n\n- 推荐使用`HTTP/2`协议。\n- 必须加入`TLS`层。\n- 基于JWT的方式，token的最大有效期为1小时，并且不能频繁更换token。\n- 不能频繁创建、关闭连接，应该尽量少开连接，如果过于频繁，APNs将把其当做是黑客攻击，但是如果数据量大，可以同时多个连接向APNs发送消息。\n- 吊销token或者证书的时候，应该及时关闭老的连接。\n\n## 参考文献\n1. [APNs Overview](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1)\n2. [Communicating with APNs](https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2)\n\n\n\n\n","slug":"iOS_APNs","published":1,"updated":"2016-12-21T03:30:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4b001dgivbgbcrorfj","content":"<p><em>本文的大部分内容是对苹果关于APNs官方文档的翻译以及整理。</em></p>\n<h2 id=\"一、设备token和消息的生命周期\"><a href=\"#一、设备token和消息的生命周期\" class=\"headerlink\" title=\"一、设备token和消息的生命周期\"></a>一、设备token和消息的生命周期</h2><p>关于设备token以及推送消息的生命周期需要注意下面几点：</p>\n<ul>\n<li>Token会在iOS系统更新或者设备数据、设置被擦除的时候改变。</li>\n<li>当设备离线的时候，APNS会将消息数据存储一段时间，等设备上线后重发。如果设备在离线期间，向APNS发送了多条推送消息，APNS将会丢弃掉前面的一些消息，只保留后面的消息，要是设备长时间离线，则会将所有的消息丢弃掉。</li>\n<li>可以通过设置http/2头中的<code>apns-collapse-id</code>键值对来合并消息，比如：<code>apns-collapse-id : 2</code>，那么value为2的消息将被APNS合并成一条消息推送给设备。</li>\n</ul>\n<h2 id=\"二、Provider（后台）与APNs的交互\"><a href=\"#二、Provider（后台）与APNs的交互\" class=\"headerlink\" title=\"二、Provider（后台）与APNs的交互\"></a>二、Provider（后台）与APNs的交互</h2><p>Provider（即，APP的后台）与APNS有两种安全的交互方式，都必须采用TLS以保证可靠性，更详细的内容继续往下看。</p>\n<blockquote>\n<p><code>TLS</code>的简单理解是，为了保证数据传输安全，在HTTP层与TCP层之间插入的一个安全校验层，它所做的事情简单来说就是：<strong>“通过CA申请的证书验证client与server是可靠的之后，通过相应的公私钥加密一个<code>协商的公钥</code>，之后的真实数据传输就使用这个公钥进行加密，以保证数据的安全可靠性”</strong>，关于TLS的更详细的介绍，可以参考<a href=\"https://segmentfault.com/a/1190000002554673\" target=\"_blank\" rel=\"external\">这篇文章</a></p>\n</blockquote>\n<h3 id=\"基于Token的方式（Token-Based-Provider-to-APNs-Trust）\"><a href=\"#基于Token的方式（Token-Based-Provider-to-APNs-Trust）\" class=\"headerlink\" title=\"基于Token的方式（Token-Based Provider-to-APNs Trust）\"></a>基于Token的方式（Token-Based Provider-to-APNs Trust）</h3><h4 id=\"1、流程概述\"><a href=\"#1、流程概述\" class=\"headerlink\" title=\"1、流程概述\"></a>1、流程概述</h4><p>这种方式适合在基于HTTP/2协议的Provider使用，它与APNs之间的连接通过<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"external\">JWT（JSON web tokens）</a>来验证。在这种方式下不需要使用证书+私钥的方式来建立可靠连接。Provider只需要提供一个一对公私钥（私钥给APNs保存，公钥Provider自己保存）,并使用其中的私钥生成并加密JWT Token，每次向APNs请求推送的时候带上这个Token即可。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li>Provider通过<code>TLS</code>向APNs发起请求。</li>\n<li>APNs返回一个证书给Provider。</li>\n<li>Provier验证这个证书。通过后，发送push数据并带上JWT token。</li>\n<li>APNs验证token，并返回请求的结果。</li>\n</ol>\n<p><img src=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_2x.png\" alt=\"Establishing and using token-based connection trust between a provider and APNs\"></p>\n<blockquote>\n<p>建立TLS连接必须要有一个<code>GeoTrust Global CA root certificate</code>，在macOS中，这个证书已经安装在keychain中，如果是其他操作系统则可以在<a href=\"https://www.geotrust.com/resources/root-certificates/\" target=\"_blank\" rel=\"external\">GeoTrust Root Certificates website</a>下载。</p>\n</blockquote>\n<h4 id=\"2、Provider-Authentication-Tokens\"><a href=\"#2、Provider-Authentication-Tokens\" class=\"headerlink\" title=\"2、Provider Authentication Tokens\"></a>2、Provider Authentication Tokens</h4><p>关于JWT（JSON Web Token）的详细资料可以通过<a href=\"https://tools.ietf.org/html/rfc7519\" target=\"_blank\" rel=\"external\">这里</a>了解。同时也可以从<a href=\"https://jwt.io\" target=\"_blank\" rel=\"external\">这里</a>找到一些现成可用的库。</p>\n<p>下面对JWT进行详细的介绍，一个JWT实际上是一个JSON对象，它的头部必须包含：</p>\n<ul>\n<li>用以加密token的加密算法(<strong>alg</strong>) ，比如：ES256。</li>\n<li>10个字符长度的标识符(<strong>kid</strong>)，（登入苹果开发者账号后，进入到<strong>Certificates, Identifiers &amp; Profiles</strong>，然后点击<strong>APNs Auth Key</strong>，最后在右侧找到<strong>Apple Push Notification Authentication Key (Sandbox &amp; Production)</strong>选项，点击创建后可以创建一个p8文件。）</li>\n</ul>\n<p>同时他的claims payload部分必须包含：</p>\n<ul>\n<li>issuer(<strong>iss</strong>) registered claim key，其值就是10个字符长的Team ID。</li>\n<li>issued at (<strong>iat</strong>) registered claim key，其值是一个秒级的UTC时间戳。</li>\n</ul>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;alg&quot;: &quot;ES256&quot;,</div><div class=\"line\">    &quot;kid&quot;: &quot;ABC123DEFG&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;iss&quot;: &quot;DEF123GHIJ&quot;,</div><div class=\"line\">    &quot;iat&quot;: 1437179036</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>创建完这个token后，必须使用自己的私钥对其进行加密，然后再采用基于P-256曲线和SHA-256哈希算法的椭圆曲线数字签名算法（ECDSA）进行签名，并将<code>alg</code>键的值设置为<code>ES256</code>。(注意：APNs只支持<strong>ES256</strong>签名的JWT，否则会返回<code>InvalidProviderToken(403)</code>错误)</p>\n<p>为了保证安全，APNs要求定期更新token，时间间隔为1小时，如果APNs发现当前的时间戳与<code>iat</code>值中的时间戳相比，大于一个小时，那么APNs会拒绝推送消息，并返回<code>ExpiredProviderToken (403)</code>错误。</p>\n<h3 id=\"基于证书的方式（Certificate-based-connection-trust\"><a href=\"#基于证书的方式（Certificate-based-connection-trust\" class=\"headerlink\" title=\"基于证书的方式（Certificate-based connection trust)\"></a>基于证书的方式（Certificate-based connection trust)</h3><h4 id=\"流程概述\"><a href=\"#流程概述\" class=\"headerlink\" title=\"流程概述\"></a>流程概述</h4><p>这种方式是指Provider可以采用一个唯一的证书以及一个加密的私钥来与APNs交互，其中证书是由苹果产生的（通过苹果账号登录到<a href=\"https://developer.apple.com/account/#/welcome\" target=\"_blank\" rel=\"external\">developer account</a>配置创建）。整个交互过程如下：</p>\n<ol>\n<li>Provider通过<code>TLS</code>向APNs请求连接。</li>\n<li>APNs向Provider返回一个APNs证书。</li>\n<li>Provider验证这个APNs证书，并将从苹果官网获取的证书返回给APNs。</li>\n<li>APNs验证通过后，这个链接就算是建立了。</li>\n</ol>\n<p><img src=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_certificate_2x.png\" alt=\"Establishing certificate-based connection trust between a provider and APNs\"></p>\n<h4 id=\"APNs-Provider-Certificates\"><a href=\"#APNs-Provider-Certificates\" class=\"headerlink\" title=\"APNs Provider Certificates\"></a>APNs Provider Certificates</h4><p>创建步骤可以参考<a href=\"https://help.apple.com/xcode/mac/8.1/index.html?localePath=en.lproj#/dev11b059073\" target=\"_blank\" rel=\"external\">Configure push notifications</a>中的Generate a universal APNs client SSL certificate章节。</p>\n<h2 id=\"三、APNs连接\"><a href=\"#三、APNs连接\" class=\"headerlink\" title=\"三、APNs连接\"></a>三、APNs连接</h2><h3 id=\"连接的管理\"><a href=\"#连接的管理\" class=\"headerlink\" title=\"连接的管理\"></a>连接的管理</h3><p>苹果的两个APNs server分别为：</p>\n<ul>\n<li><strong>Development server:</strong> <code>api.development.push.apple.com:443</code></li>\n<li><strong>Production server:</strong> <code>api.push.apple.com:443</code></li>\n</ul>\n<p>要与APNs交互要求server必须支持1.2及上版本的TLS协议。通过上面的介绍我们已经知道，server跟APNs交互有两种方式：基于JWT的方式以及基于证书的方式。为了保证高质量的使用APNs应该注意如下几点：</p>\n<ul>\n<li>对于基于JWT的方式，应该定时更新token，token的有效期为1小时。</li>\n<li>对于基于JWT的方式，能每次请求都创建新的token，尽量在一小时内使用同一个token。</li>\n<li>不能频繁的建立、关闭连接，否则APNs会把这当做是黑客攻击，拒绝访问。应该尽量将连接保活，直到你认为这个连接接下来会长时间不使用为止。</li>\n<li>当需要发送大量的推送数据的时候，可以同时创建多个连接，以改善性能。</li>\n<li>当吊销证书或者token时，应该关闭所有相关的连接。</li>\n</ul>\n<h3 id=\"HTTP-2的请求与响应\"><a href=\"#HTTP-2的请求与响应\" class=\"headerlink\" title=\"HTTP/2的请求与响应\"></a>HTTP/2的请求与响应</h3><p>详情可参见苹果官方文档<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2\" target=\"_blank\" rel=\"external\">HTTP/2 Request to APNs</a>。这里介绍了接口的<strong>请求参数</strong>、<strong>返回结果</strong>，<strong>错误码</strong>以及<strong>示例代码</strong>。下面仅截取了其中的例子，以加深对APNs的使用的理解：</p>\n<ul>\n<li><p>基于证书的方式的request：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS</div><div class=\"line\">  - END_STREAM</div><div class=\"line\">  + END_HEADERS</div><div class=\"line\">  :method = POST</div><div class=\"line\">  :scheme = https</div><div class=\"line\">  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0</div><div class=\"line\">  host = api.development.push.apple.com</div><div class=\"line\">  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b //可以不填，如果不填APNs会自己创建一个UUID并在response中返回</div><div class=\"line\">  apns-expiration = 0</div><div class=\"line\">  apns-priority = 10</div><div class=\"line\">DATA</div><div class=\"line\">  + END_STREAM</div><div class=\"line\">    &#123; &quot;aps&quot; : &#123; &quot;alert&quot; : &quot;Hello&quot; &#125; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>基于token方式的request：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS</div><div class=\"line\">  - END_STREAM</div><div class=\"line\">  + END_HEADERS</div><div class=\"line\">  :method = POST</div><div class=\"line\">  :scheme = https</div><div class=\"line\">  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0</div><div class=\"line\">  host = api.development.push.apple.com</div><div class=\"line\">  authorization = bearer eyAia2lkIjogIjhZTDNHM1JSWDciIH0.eyAiaXNzIjogIkM4Nk5WOUpYM0QiLCAiaWF0I</div><div class=\"line\"> jogIjE0NTkxNDM1ODA2NTAiIH0.MEYCIQDzqyahmH1rz1s-LFNkylXEa2lZ_aOCX4daxxTZkVEGzwIhALvkClnx5m5eAT6</div><div class=\"line\"> Lxw7LZtEQcH6JENhJTMArwLf3sXwi</div><div class=\"line\">  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b</div><div class=\"line\">  apns-expiration = 0</div><div class=\"line\">  apns-priority = 10</div><div class=\"line\">  apns-topic = &lt;MyAppTopic&gt;</div><div class=\"line\">DATA</div><div class=\"line\">  + END_STREAM</div><div class=\"line\">    &#123; &quot;aps&quot; : &#123; &quot;alert&quot; : &quot;Hello&quot; &#125; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>失败后的response:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS</div><div class=\"line\">  - END_STREAM</div><div class=\"line\">  + END_HEADERS</div><div class=\"line\">  :status = 400</div><div class=\"line\">  content-type = application/json</div><div class=\"line\">    apns-id: &lt;a_UUID&gt;</div><div class=\"line\">DATA</div><div class=\"line\">  + END_STREAM</div><div class=\"line\">  &#123; &quot;reason&quot; : &quot;BadDeviceToken&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>成功后的response：</p>\n<pre><code>HEADERS\n  - END_STREAM\n  + END_HEADERS\n    apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n    :status = 200\n</code></pre></li>\n</ul>\n<h2 id=\"四、设备token的生成与分发\"><a href=\"#四、设备token的生成与分发\" class=\"headerlink\" title=\"四、设备token的生成与分发\"></a>四、设备token的生成与分发</h2><p>在app启动的时候，必须向iOS系统注册远程推送，成功后，苹果将会返回一个设备token给app，此时app就可以将这个token上报给自己的后台。</p>\n<p>如果有必要产生一个新的token，APNs会使用设备证书生成一个token（其中包含了一个设备ID），并使用token key加密后返回给设备。同时设备会将这个token以<code>NSData</code>对象的形式返回给app，app获取到该token之后应该将其发送到自己后台，后台之后就可以通过这个token来发送推送数据。过程如下图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/token_generation_2x.png\" alt=\"Managing the device token\"></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>通过苹果的官方文档我们可以知道provider与APNs的交互过程中，需要注意一下几点：</p>\n<ul>\n<li>推荐使用<code>HTTP/2</code>协议。</li>\n<li>必须加入<code>TLS</code>层。</li>\n<li>基于JWT的方式，token的最大有效期为1小时，并且不能频繁更换token。</li>\n<li>不能频繁创建、关闭连接，应该尽量少开连接，如果过于频繁，APNs将把其当做是黑客攻击，但是如果数据量大，可以同时多个连接向APNs发送消息。</li>\n<li>吊销token或者证书的时候，应该及时关闭老的连接。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1\" target=\"_blank\" rel=\"external\">APNs Overview</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2\" target=\"_blank\" rel=\"external\">Communicating with APNs</a></li>\n</ol>\n","excerpt":"","more":"<p><em>本文的大部分内容是对苹果关于APNs官方文档的翻译以及整理。</em></p>\n<h2 id=\"一、设备token和消息的生命周期\"><a href=\"#一、设备token和消息的生命周期\" class=\"headerlink\" title=\"一、设备token和消息的生命周期\"></a>一、设备token和消息的生命周期</h2><p>关于设备token以及推送消息的生命周期需要注意下面几点：</p>\n<ul>\n<li>Token会在iOS系统更新或者设备数据、设置被擦除的时候改变。</li>\n<li>当设备离线的时候，APNS会将消息数据存储一段时间，等设备上线后重发。如果设备在离线期间，向APNS发送了多条推送消息，APNS将会丢弃掉前面的一些消息，只保留后面的消息，要是设备长时间离线，则会将所有的消息丢弃掉。</li>\n<li>可以通过设置http/2头中的<code>apns-collapse-id</code>键值对来合并消息，比如：<code>apns-collapse-id : 2</code>，那么value为2的消息将被APNS合并成一条消息推送给设备。</li>\n</ul>\n<h2 id=\"二、Provider（后台）与APNs的交互\"><a href=\"#二、Provider（后台）与APNs的交互\" class=\"headerlink\" title=\"二、Provider（后台）与APNs的交互\"></a>二、Provider（后台）与APNs的交互</h2><p>Provider（即，APP的后台）与APNS有两种安全的交互方式，都必须采用TLS以保证可靠性，更详细的内容继续往下看。</p>\n<blockquote>\n<p><code>TLS</code>的简单理解是，为了保证数据传输安全，在HTTP层与TCP层之间插入的一个安全校验层，它所做的事情简单来说就是：<strong>“通过CA申请的证书验证client与server是可靠的之后，通过相应的公私钥加密一个<code>协商的公钥</code>，之后的真实数据传输就使用这个公钥进行加密，以保证数据的安全可靠性”</strong>，关于TLS的更详细的介绍，可以参考<a href=\"https://segmentfault.com/a/1190000002554673\">这篇文章</a></p>\n</blockquote>\n<h3 id=\"基于Token的方式（Token-Based-Provider-to-APNs-Trust）\"><a href=\"#基于Token的方式（Token-Based-Provider-to-APNs-Trust）\" class=\"headerlink\" title=\"基于Token的方式（Token-Based Provider-to-APNs Trust）\"></a>基于Token的方式（Token-Based Provider-to-APNs Trust）</h3><h4 id=\"1、流程概述\"><a href=\"#1、流程概述\" class=\"headerlink\" title=\"1、流程概述\"></a>1、流程概述</h4><p>这种方式适合在基于HTTP/2协议的Provider使用，它与APNs之间的连接通过<a href=\"https://tools.ietf.org/html/rfc7519\">JWT（JSON web tokens）</a>来验证。在这种方式下不需要使用证书+私钥的方式来建立可靠连接。Provider只需要提供一个一对公私钥（私钥给APNs保存，公钥Provider自己保存）,并使用其中的私钥生成并加密JWT Token，每次向APNs请求推送的时候带上这个Token即可。</p>\n<p>具体步骤如下：</p>\n<ol>\n<li>Provider通过<code>TLS</code>向APNs发起请求。</li>\n<li>APNs返回一个证书给Provider。</li>\n<li>Provier验证这个证书。通过后，发送push数据并带上JWT token。</li>\n<li>APNs验证token，并返回请求的结果。</li>\n</ol>\n<p><img src=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_2x.png\" alt=\"Establishing and using token-based connection trust between a provider and APNs\"></p>\n<blockquote>\n<p>建立TLS连接必须要有一个<code>GeoTrust Global CA root certificate</code>，在macOS中，这个证书已经安装在keychain中，如果是其他操作系统则可以在<a href=\"https://www.geotrust.com/resources/root-certificates/\">GeoTrust Root Certificates website</a>下载。</p>\n</blockquote>\n<h4 id=\"2、Provider-Authentication-Tokens\"><a href=\"#2、Provider-Authentication-Tokens\" class=\"headerlink\" title=\"2、Provider Authentication Tokens\"></a>2、Provider Authentication Tokens</h4><p>关于JWT（JSON Web Token）的详细资料可以通过<a href=\"https://tools.ietf.org/html/rfc7519\">这里</a>了解。同时也可以从<a href=\"https://jwt.io\">这里</a>找到一些现成可用的库。</p>\n<p>下面对JWT进行详细的介绍，一个JWT实际上是一个JSON对象，它的头部必须包含：</p>\n<ul>\n<li>用以加密token的加密算法(<strong>alg</strong>) ，比如：ES256。</li>\n<li>10个字符长度的标识符(<strong>kid</strong>)，（登入苹果开发者账号后，进入到<strong>Certificates, Identifiers &amp; Profiles</strong>，然后点击<strong>APNs Auth Key</strong>，最后在右侧找到<strong>Apple Push Notification Authentication Key (Sandbox &amp; Production)</strong>选项，点击创建后可以创建一个p8文件。）</li>\n</ul>\n<p>同时他的claims payload部分必须包含：</p>\n<ul>\n<li>issuer(<strong>iss</strong>) registered claim key，其值就是10个字符长的Team ID。</li>\n<li>issued at (<strong>iat</strong>) registered claim key，其值是一个秒级的UTC时间戳。</li>\n</ul>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;alg&quot;: &quot;ES256&quot;,</div><div class=\"line\">    &quot;kid&quot;: &quot;ABC123DEFG&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;iss&quot;: &quot;DEF123GHIJ&quot;,</div><div class=\"line\">    &quot;iat&quot;: 1437179036</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>创建完这个token后，必须使用自己的私钥对其进行加密，然后再采用基于P-256曲线和SHA-256哈希算法的椭圆曲线数字签名算法（ECDSA）进行签名，并将<code>alg</code>键的值设置为<code>ES256</code>。(注意：APNs只支持<strong>ES256</strong>签名的JWT，否则会返回<code>InvalidProviderToken(403)</code>错误)</p>\n<p>为了保证安全，APNs要求定期更新token，时间间隔为1小时，如果APNs发现当前的时间戳与<code>iat</code>值中的时间戳相比，大于一个小时，那么APNs会拒绝推送消息，并返回<code>ExpiredProviderToken (403)</code>错误。</p>\n<h3 id=\"基于证书的方式（Certificate-based-connection-trust\"><a href=\"#基于证书的方式（Certificate-based-connection-trust\" class=\"headerlink\" title=\"基于证书的方式（Certificate-based connection trust)\"></a>基于证书的方式（Certificate-based connection trust)</h3><h4 id=\"流程概述\"><a href=\"#流程概述\" class=\"headerlink\" title=\"流程概述\"></a>流程概述</h4><p>这种方式是指Provider可以采用一个唯一的证书以及一个加密的私钥来与APNs交互，其中证书是由苹果产生的（通过苹果账号登录到<a href=\"https://developer.apple.com/account/#/welcome\">developer account</a>配置创建）。整个交互过程如下：</p>\n<ol>\n<li>Provider通过<code>TLS</code>向APNs请求连接。</li>\n<li>APNs向Provider返回一个APNs证书。</li>\n<li>Provider验证这个APNs证书，并将从苹果官网获取的证书返回给APNs。</li>\n<li>APNs验证通过后，这个链接就算是建立了。</li>\n</ol>\n<p><img src=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct_certificate_2x.png\" alt=\"Establishing certificate-based connection trust between a provider and APNs\"></p>\n<h4 id=\"APNs-Provider-Certificates\"><a href=\"#APNs-Provider-Certificates\" class=\"headerlink\" title=\"APNs Provider Certificates\"></a>APNs Provider Certificates</h4><p>创建步骤可以参考<a href=\"https://help.apple.com/xcode/mac/8.1/index.html?localePath=en.lproj#/dev11b059073\">Configure push notifications</a>中的Generate a universal APNs client SSL certificate章节。</p>\n<h2 id=\"三、APNs连接\"><a href=\"#三、APNs连接\" class=\"headerlink\" title=\"三、APNs连接\"></a>三、APNs连接</h2><h3 id=\"连接的管理\"><a href=\"#连接的管理\" class=\"headerlink\" title=\"连接的管理\"></a>连接的管理</h3><p>苹果的两个APNs server分别为：</p>\n<ul>\n<li><strong>Development server:</strong> <code>api.development.push.apple.com:443</code></li>\n<li><strong>Production server:</strong> <code>api.push.apple.com:443</code></li>\n</ul>\n<p>要与APNs交互要求server必须支持1.2及上版本的TLS协议。通过上面的介绍我们已经知道，server跟APNs交互有两种方式：基于JWT的方式以及基于证书的方式。为了保证高质量的使用APNs应该注意如下几点：</p>\n<ul>\n<li>对于基于JWT的方式，应该定时更新token，token的有效期为1小时。</li>\n<li>对于基于JWT的方式，能每次请求都创建新的token，尽量在一小时内使用同一个token。</li>\n<li>不能频繁的建立、关闭连接，否则APNs会把这当做是黑客攻击，拒绝访问。应该尽量将连接保活，直到你认为这个连接接下来会长时间不使用为止。</li>\n<li>当需要发送大量的推送数据的时候，可以同时创建多个连接，以改善性能。</li>\n<li>当吊销证书或者token时，应该关闭所有相关的连接。</li>\n</ul>\n<h3 id=\"HTTP-2的请求与响应\"><a href=\"#HTTP-2的请求与响应\" class=\"headerlink\" title=\"HTTP/2的请求与响应\"></a>HTTP/2的请求与响应</h3><p>详情可参见苹果官方文档<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2\">HTTP/2 Request to APNs</a>。这里介绍了接口的<strong>请求参数</strong>、<strong>返回结果</strong>，<strong>错误码</strong>以及<strong>示例代码</strong>。下面仅截取了其中的例子，以加深对APNs的使用的理解：</p>\n<ul>\n<li><p>基于证书的方式的request：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS</div><div class=\"line\">  - END_STREAM</div><div class=\"line\">  + END_HEADERS</div><div class=\"line\">  :method = POST</div><div class=\"line\">  :scheme = https</div><div class=\"line\">  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0</div><div class=\"line\">  host = api.development.push.apple.com</div><div class=\"line\">  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b //可以不填，如果不填APNs会自己创建一个UUID并在response中返回</div><div class=\"line\">  apns-expiration = 0</div><div class=\"line\">  apns-priority = 10</div><div class=\"line\">DATA</div><div class=\"line\">  + END_STREAM</div><div class=\"line\">    &#123; &quot;aps&quot; : &#123; &quot;alert&quot; : &quot;Hello&quot; &#125; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>基于token方式的request：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS</div><div class=\"line\">  - END_STREAM</div><div class=\"line\">  + END_HEADERS</div><div class=\"line\">  :method = POST</div><div class=\"line\">  :scheme = https</div><div class=\"line\">  :path = /3/device/00fc13adff785122b4ad28809a3420982341241421348097878e577c991de8f0</div><div class=\"line\">  host = api.development.push.apple.com</div><div class=\"line\">  authorization = bearer eyAia2lkIjogIjhZTDNHM1JSWDciIH0.eyAiaXNzIjogIkM4Nk5WOUpYM0QiLCAiaWF0I</div><div class=\"line\"> jogIjE0NTkxNDM1ODA2NTAiIH0.MEYCIQDzqyahmH1rz1s-LFNkylXEa2lZ_aOCX4daxxTZkVEGzwIhALvkClnx5m5eAT6</div><div class=\"line\"> Lxw7LZtEQcH6JENhJTMArwLf3sXwi</div><div class=\"line\">  apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b</div><div class=\"line\">  apns-expiration = 0</div><div class=\"line\">  apns-priority = 10</div><div class=\"line\">  apns-topic = &lt;MyAppTopic&gt;</div><div class=\"line\">DATA</div><div class=\"line\">  + END_STREAM</div><div class=\"line\">    &#123; &quot;aps&quot; : &#123; &quot;alert&quot; : &quot;Hello&quot; &#125; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>失败后的response:</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">HEADERS</div><div class=\"line\">  - END_STREAM</div><div class=\"line\">  + END_HEADERS</div><div class=\"line\">  :status = 400</div><div class=\"line\">  content-type = application/json</div><div class=\"line\">    apns-id: &lt;a_UUID&gt;</div><div class=\"line\">DATA</div><div class=\"line\">  + END_STREAM</div><div class=\"line\">  &#123; &quot;reason&quot; : &quot;BadDeviceToken&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>成功后的response：</p>\n<pre><code>HEADERS\n  - END_STREAM\n  + END_HEADERS\n    apns-id = eabeae54-14a8-11e5-b60b-1697f925ec7b\n    :status = 200\n</code></pre></li>\n</ul>\n<h2 id=\"四、设备token的生成与分发\"><a href=\"#四、设备token的生成与分发\" class=\"headerlink\" title=\"四、设备token的生成与分发\"></a>四、设备token的生成与分发</h2><p>在app启动的时候，必须向iOS系统注册远程推送，成功后，苹果将会返回一个设备token给app，此时app就可以将这个token上报给自己的后台。</p>\n<p>如果有必要产生一个新的token，APNs会使用设备证书生成一个token（其中包含了一个设备ID），并使用token key加密后返回给设备。同时设备会将这个token以<code>NSData</code>对象的形式返回给app，app获取到该token之后应该将其发送到自己后台，后台之后就可以通过这个token来发送推送数据。过程如下图：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/token_generation_2x.png\" alt=\"Managing the device token\"></p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>通过苹果的官方文档我们可以知道provider与APNs的交互过程中，需要注意一下几点：</p>\n<ul>\n<li>推荐使用<code>HTTP/2</code>协议。</li>\n<li>必须加入<code>TLS</code>层。</li>\n<li>基于JWT的方式，token的最大有效期为1小时，并且不能频繁更换token。</li>\n<li>不能频繁创建、关闭连接，应该尽量少开连接，如果过于频繁，APNs将把其当做是黑客攻击，但是如果数据量大，可以同时多个连接向APNs发送消息。</li>\n<li>吊销token或者证书的时候，应该及时关闭老的连接。</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1\">APNs Overview</a></li>\n<li><a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingwithAPNs.html#//apple_ref/doc/uid/TP40008194-CH11-SW2\">Communicating with APNs</a></li>\n</ol>\n"},{"title":"iOS支持懒加载的PageViewController","date":"2016-09-01T16:12:18.000Z","description":"相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，同样也可以用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果...","_content":"\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","source":"_posts/iOS支持懒加载的PageViewController.md","raw":"---\ntitle: iOS支持懒加载的PageViewController\ndate: 2016-09-02 00:12:18\ndescription: \"相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，同样也可以用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果...\"\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n---\n\n# 简介\n这个控件包含两个部分：\n- TWPageViewController（底部主体部分）\n- TWPageTitleViewController（顶部标题部分）\n\n相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在[这里][1]看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：\n\n![效果图1][1]\n\n![效果图2][2]\n\n# 如何使用\n\n- （推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。\n```\npod 'TWPageViewController'\n```\n-   直接拷贝源码到自己的工程目录。\n\n# 具体实现\n## TWPageViewController\n### 为什么要写这么一个PageViewController\n在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：\n\n- UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。\n- UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。\n\n主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。\n\n\n### 实现\n其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。\n\nTWPageViewController实现了以下几个特性：\n\n#####  **支持UI部分的复用**\n以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。\n\n#####  **实现了懒加载**\n在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。\n\n##### **控制了内存的增长**\n如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。\n\n#####  **跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数**\n比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。\n#####  ** 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作**\n这些回调有：\n\n```\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n\n- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;\n```\n\n## TWPageTitleViewController\n- TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。\n- 支持自定义高亮条\n调用`- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;`设置即可，如Demo中的：\n\n```\nUIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];\nindicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];\nindicatorView.alpha = 0.3;\nindicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;\nindicatorView.layer.masksToBounds = YES;\nindicatorView.layer.borderWidth = 1;\nindicatorView.layer.borderColor = [UIColor greenColor].CGColor;\n\n[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];\n\n```\n\n## 计划优化的地方\n- TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。\n\n## 最后\n如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击[这里][3]。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\n[3]:  https://github.com/Easence/TWPageViewController","slug":"iOS支持懒加载的PageViewController","published":1,"updated":"2016-11-15T09:30:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4c001igivbh0rcmxb1","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>这个控件包含两个部分：</p>\n<ul>\n<li>TWPageViewController（底部主体部分）</li>\n<li>TWPageTitleViewController（顶部标题部分）</li>\n</ul>\n<p>相信大家都知道iOS原生的UIPageViewController，用它可以实现横向翻页的效果，TWPageViewController(可以在<a href=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\">这里</a>看到源码)同样也是用来实现横向翻页的效果，配合TWPageTitleViewController使用，可以实现类似于腾讯新闻、今日头条这样的app的效果。如下图所示：</p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/1.png?raw=true\" alt=\"效果图1\"></p>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/PageViewController/2.gif?raw=true\" alt=\"效果图2\"></p>\n<h1 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h1><ul>\n<li><p>（推荐）使用Cocoapods安装，在Podfile中添加如下代码，然后pod install一下就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;TWPageViewController&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>直接拷贝源码到自己的工程目录。</p>\n</li>\n</ul>\n<h1 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h1><h2 id=\"TWPageViewController\"><a href=\"#TWPageViewController\" class=\"headerlink\" title=\"TWPageViewController\"></a>TWPageViewController</h2><h3 id=\"为什么要写这么一个PageViewController\"><a href=\"#为什么要写这么一个PageViewController\" class=\"headerlink\" title=\"为什么要写这么一个PageViewController\"></a>为什么要写这么一个PageViewController</h3><p>在新功能开发中，其实也考虑过使用系统的UIPageViewController，但是UIPageViewController有如下的缺点：</p>\n<ul>\n<li>UIPageViewController不支持懒加载模式，即当用手快速横向滑动的时候，会按顺序一个个加载到内存中，当每个子Controller都有网络请求的时候，就会多出一些无用的网络请求，并且滑动过程中可能会卡顿，会影响用户体验。</li>\n<li>UIPageViewController不支持复用的机制（也许苹果认为根本不需要复用机制，这也是可以理解的）。</li>\n</ul>\n<p>主要还是因为UIPageViewController不支持懒加载，所以才打算自己动手写一个类似UIPageViewController的控件。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>其实实现起来，原理是很简单的，基于UIScrollView去开发就行了，只不过需要细心的处理好子Controller的生命周期，比如：什么时候调用viewWillAppear：，什么时候调用viewWillDisappear:等。</p>\n<p>TWPageViewController实现了以下几个特性：</p>\n<h5 id=\"支持UI部分的复用\"><a href=\"#支持UI部分的复用\" class=\"headerlink\" title=\"支持UI部分的复用\"></a><strong>支持UI部分的复用</strong></h5><p>以子Controller的class做key，放入复用池，下回加载同类型的viewcontroller则从复用池里面取去来，每种类型的viewcontroller会缓存一个。这样省去了开辟viewcontroller的内存以及cpu的消耗。如果复用池没有相应类型的viewcontroller则会创建一个。在实际应用中可以将UI部分以及数据部分剥离开来，UI部分复用，而数据部分缓存起来，一遍下回直接加载。</p>\n<h5 id=\"实现了懒加载\"><a href=\"#实现了懒加载\" class=\"headerlink\" title=\"实现了懒加载\"></a><strong>实现了懒加载</strong></h5><p>在滚动停止以后（其实就是在scrollViewDidEndDecelerating:中去调用加载子Controller的回调函数）才会去加载ViewController。以保证快速滑动过程的流畅，同时可以免去过程中的其他操作的资源消耗（比如途中的子Controller的网络请求）。</p>\n<h5 id=\"控制了内存的增长\"><a href=\"#控制了内存的增长\" class=\"headerlink\" title=\"控制了内存的增长\"></a><strong>控制了内存的增长</strong></h5><p>如果子Controller的数目大于3，则内存中只会保存3+N个viewController，3表示前一个、当前、后一个子Controller，N等于viewController类型的数目。小于等于3就等于实际的子Controller的数目。</p>\n<h5 id=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"><a href=\"#跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\" class=\"headerlink\" title=\"跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数\"></a><strong>跟iOS原生的UIPageViewController一样的时刻回调子Controller的生命周期函数</strong></h5><p>比如向左拖拽不放的情况下，当前子Controller的viewWillDisappear：会被回调，同时会回调下一个子Controller的viewWillAppear:，停下后，如果是停留在下一个子Controller，那么它的viewDidAppear：会被回调，同时上一个的viewDidDisappear：会被回调。</p>\n<h5 id=\"提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"><a href=\"#提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\" class=\"headerlink\" title=\" 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作\"></a><strong> 提供了子viewController各个生命周期的回调，可以用来做统一的数据的缓存、读取缓存等操作</strong></h5><p>这些回调有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController prepareReuseController:(UIViewController * _Nonnull) controller;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didAppearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController willDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">- (void)pageViewController:(TWPageViewController * _Nonnull)pageViewController didDisappearController:(UIViewController * _Nonnull) controller atIndex:(NSInteger)index;</div></pre></td></tr></table></figure>\n<h2 id=\"TWPageTitleViewController\"><a href=\"#TWPageTitleViewController\" class=\"headerlink\" title=\"TWPageTitleViewController\"></a>TWPageTitleViewController</h2><ul>\n<li>TWPageTitleViewController则只是简单容器，继承自UICollectionViewController，它只是一个横向滚动的容器，具体的每个条目的样式可以像现实自定义的UICollectionViewCell样式一样使用。</li>\n<li>支持自定义高亮条<br>调用<code>- (void)setCustomIndicatorView:(UIView *)indicatorView toFront:(BOOL)toFront;</code>设置即可，如Demo中的：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *indicatorView = [[UIView alloc] initWithFrame:CGRectMake(0, 5, 0, CGRectGetHeight(self.pageTitleViewController.view.bounds) - 10)];</div><div class=\"line\">indicatorView.backgroundColor = [UIColor colorWithRed:0.8362 green:1.0 blue:0.9041 alpha:1.0];</div><div class=\"line\">indicatorView.alpha = 0.3;</div><div class=\"line\">indicatorView.layer.cornerRadius = CGRectGetHeight(indicatorView.bounds) / 2;</div><div class=\"line\">indicatorView.layer.masksToBounds = YES;</div><div class=\"line\">indicatorView.layer.borderWidth = 1;</div><div class=\"line\">indicatorView.layer.borderColor = [UIColor greenColor].CGColor;</div><div class=\"line\"></div><div class=\"line\">[self.pageTitleViewController setCustomIndicatorView:indicatorView toFront:NO];</div></pre></td></tr></table></figure>\n<h2 id=\"计划优化的地方\"><a href=\"#计划优化的地方\" class=\"headerlink\" title=\"计划优化的地方\"></a>计划优化的地方</h2><ul>\n<li>TWPageTitleViewController高亮条的移动可以根据TWPageViewController的滑动平滑的过度过去。</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>如果发现有任何问题，麻烦指出，我会及时修正，同时需要查看完整实现以及Demo，请点击<a href=\"https://github.com/Easence/TWPageViewController\">这里</a>。</p>\n<hr>\n"},{"title":"iOS签名","_content":"\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","source":"_posts/iOS签名.md","raw":"---\ntitle: iOS签名\ncategories: \n - Apple Development \n - 安全\ntags:\n - 安全\n - JS\n---\n\n## 签名证书（开发者证书）生成过程\n- 本地生成CertificateSigningRequest.certSigningRequest（包含`用本地私钥加密的申请者信息`、`公钥`、`摘要算法、非对称加密算法`）。而私钥秘密的保存在本地。\n- 苹果拿出CertificateSigningRequest.certSigningRequest里面的`公钥`,并将MC账号的用户信息封装到证书里面。\n\n## 授权描述文件（provisioning profile）\n- AppID\n- 哪些证书合法\n- 哪些设备(UUID)可以运行\n- 拥有哪些特权\n- 苹果的签名\n> 查看mobileprovision文件的方法：\n`security cms -D -i embedded.mobileprovision`\n\n##授权文件（entitlements）\n- 描述app有哪些功能（如：Push、iCloud等）的文件。\n```\n$ codesign -d --entitlements - Example.app\n```\n## app重签流程\n- 首先解压ipa\n- 如果mobileprovision需要替换，替换\n- \n- 如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework\n- 对xxx.app签名(实际上用的是证书对应的私钥进行签名)\n- 重新打包\n\n## 签名相关命令\n- 解压ipa包\n```\nunzip -q xxx.ipa -d <destination>\n```\n- 找出本机可以用来签名的证书信息\n```\nsecurity find-identity -v -p codesigning\n```\n- 列出app使用的签名信息\n```\ncodesign -dvvv xxx.app\n```\n- 查看entitlement.plist\n```\n$ codesign -d --entitlements - Example.app\n```\n- 对app重签\n```\ncodesign -fs \"iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)\" --no-strict xxx.app\n```\n- 检验签名是否合法\n```\ncodesign -v xxx.app\n```\n- 重新打包ipa包\n```\nzip -qry destination source\n```\n---\n参考文章：\n[漫谈iOS程序的证书和签名机制](https://segmentfault.com/a/1190000004144556)\n[iReSign](https://github.com/maciekish/iReSign)\n[re-sign-ios-app](https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7)\n[iOS Code Signing 学习笔记](http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/)\n\n\n\n\n\n\n","slug":"iOS签名","published":1,"date":"2016-10-17T05:11:54.000Z","updated":"2016-10-17T05:11:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4d001lgivb94saeket","content":"<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\" target=\"_blank\" rel=\"external\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\" target=\"_blank\" rel=\"external\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\" target=\"_blank\" rel=\"external\">iOS Code Signing 学习笔记</a></p>\n","excerpt":"","more":"<h2 id=\"签名证书（开发者证书）生成过程\"><a href=\"#签名证书（开发者证书）生成过程\" class=\"headerlink\" title=\"签名证书（开发者证书）生成过程\"></a>签名证书（开发者证书）生成过程</h2><ul>\n<li>本地生成CertificateSigningRequest.certSigningRequest（包含<code>用本地私钥加密的申请者信息</code>、<code>公钥</code>、<code>摘要算法、非对称加密算法</code>）。而私钥秘密的保存在本地。</li>\n<li>苹果拿出CertificateSigningRequest.certSigningRequest里面的<code>公钥</code>,并将MC账号的用户信息封装到证书里面。</li>\n</ul>\n<h2 id=\"授权描述文件（provisioning-profile）\"><a href=\"#授权描述文件（provisioning-profile）\" class=\"headerlink\" title=\"授权描述文件（provisioning profile）\"></a>授权描述文件（provisioning profile）</h2><ul>\n<li>AppID</li>\n<li>哪些证书合法</li>\n<li>哪些设备(UUID)可以运行</li>\n<li>拥有哪些特权</li>\n<li>苹果的签名<blockquote>\n<p>查看mobileprovision文件的方法：<br><code>security cms -D -i embedded.mobileprovision</code></p>\n</blockquote>\n</li>\n</ul>\n<p>##授权文件（entitlements）</p>\n<ul>\n<li>描述app有哪些功能（如：Push、iCloud等）的文件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"app重签流程\"><a href=\"#app重签流程\" class=\"headerlink\" title=\"app重签流程\"></a>app重签流程</h2><ul>\n<li>首先解压ipa</li>\n<li>如果mobileprovision需要替换，替换</li>\n<li></li>\n<li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li>\n<li>对xxx.app签名(实际上用的是证书对应的私钥进行签名)</li>\n<li>重新打包</li>\n</ul>\n<h2 id=\"签名相关命令\"><a href=\"#签名相关命令\" class=\"headerlink\" title=\"签名相关命令\"></a>签名相关命令</h2><ul>\n<li><p>解压ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">unzip -q xxx.ipa -d &lt;destination&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>找出本机可以用来签名的证书信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">security find-identity -v -p codesigning</div></pre></td></tr></table></figure>\n</li>\n<li><p>列出app使用的签名信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -dvvv xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看entitlement.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ codesign -d --entitlements - Example.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>对app重签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -fs &quot;iPhone Developer: xxx@xxx.com (Z5YSB6PG5P)&quot; --no-strict xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>检验签名是否合法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codesign -v xxx.app</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新打包ipa包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zip -qry destination source</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://segmentfault.com/a/1190000004144556\">漫谈iOS程序的证书和签名机制</a><br><a href=\"https://github.com/maciekish/iReSign\">iReSign</a><br><a href=\"https://gist.github.com/chaitanyagupta/9a2a13f0a3e6755192f7\">re-sign-ios-app</a><br><a href=\"http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/\">iOS Code Signing 学习笔记</a></p>\n"},{"title":"创建pod库的步骤","_content":"\n标签（空格分隔）： 开发 iOS\n---\n## 注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n## 验证邮箱\n```\npod trunk me\n```\n## push源码到git仓库\n## 创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n## 编辑podspec文件\n## 检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n## 使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n## 成功后`pod setup`\n## 验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","source":"_posts/创建pod库的步骤.md","raw":"---\ntitle: 创建pod库的步骤\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n - Cocoapods\n---\n\n标签（空格分隔）： 开发 iOS\n---\n## 注册Trunk\n```\npod trunk register xxxxx@gmail.com 'xxxxx'\n```\n## 验证邮箱\n```\npod trunk me\n```\n## push源码到git仓库\n## 创建podspec文件\n```\npod spec create https://github.com/Easence/EAMiniAudioPlayerView.git\n```\n## 编辑podspec文件\n## 检查podspec文件格式是否符合规则\n```\npod lib lint --no-clean\n```\n成功后的信息：`EAMiniAudioPlayerView passed validation.`\n## 使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\n```\npod trunk push EAMiniAudioPlayerView.podspec\n```\n\n## 成功后`pod setup`\n## 验证是否成功：\n```\npod search EAMiniAudioPlayerView\n```\n\n\n\n","slug":"创建pod库的步骤","published":1,"date":"2016-10-17T04:09:25.000Z","updated":"2016-10-17T04:09:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4f001ogivbho55v4xu","content":"<h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><h2 id=\"注册Trunk\"><a href=\"#注册Trunk\" class=\"headerlink\" title=\"注册Trunk\"></a>注册Trunk</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure>\n<h2 id=\"push源码到git仓库\"><a href=\"#push源码到git仓库\" class=\"headerlink\" title=\"push源码到git仓库\"></a>push源码到git仓库</h2><h2 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>\n<h2 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h2><h2 id=\"检查podspec文件格式是否符合规则\"><a href=\"#检查podspec文件格式是否符合规则\" class=\"headerlink\" title=\"检查podspec文件格式是否符合规则\"></a>检查podspec文件格式是否符合规则</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<h2 id=\"使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\"><a href=\"#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\" class=\"headerlink\" title=\"使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>\n<h2 id=\"成功后pod-setup\"><a href=\"#成功后pod-setup\" class=\"headerlink\" title=\"成功后pod setup\"></a>成功后<code>pod setup</code></h2><h2 id=\"验证是否成功：\"><a href=\"#验证是否成功：\" class=\"headerlink\" title=\"验证是否成功：\"></a>验证是否成功：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"标签（空格分隔）：-开发-iOS\"><a href=\"#标签（空格分隔）：-开发-iOS\" class=\"headerlink\" title=\"标签（空格分隔）： 开发 iOS\"></a>标签（空格分隔）： 开发 iOS</h2><h2 id=\"注册Trunk\"><a href=\"#注册Trunk\" class=\"headerlink\" title=\"注册Trunk\"></a>注册Trunk</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk register xxxxx@gmail.com &apos;xxxxx&apos;</div></pre></td></tr></table></figure>\n<h2 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk me</div></pre></td></tr></table></figure>\n<h2 id=\"push源码到git仓库\"><a href=\"#push源码到git仓库\" class=\"headerlink\" title=\"push源码到git仓库\"></a>push源码到git仓库</h2><h2 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create https://github.com/Easence/EAMiniAudioPlayerView.git</div></pre></td></tr></table></figure>\n<h2 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h2><h2 id=\"检查podspec文件格式是否符合规则\"><a href=\"#检查podspec文件格式是否符合规则\" class=\"headerlink\" title=\"检查podspec文件格式是否符合规则\"></a>检查podspec文件格式是否符合规则</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod lib lint --no-clean</div></pre></td></tr></table></figure>\n<p>成功后的信息：<code>EAMiniAudioPlayerView passed validation.</code></p>\n<h2 id=\"使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\"><a href=\"#使用pod-trunk-push命令把刚才创建的podspec文件推送到Github的specs-repo远程库\" class=\"headerlink\" title=\"使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库\"></a>使用pod trunk push命令把刚才创建的podspec文件推送到Github的specs repo远程库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod trunk push EAMiniAudioPlayerView.podspec</div></pre></td></tr></table></figure>\n<h2 id=\"成功后pod-setup\"><a href=\"#成功后pod-setup\" class=\"headerlink\" title=\"成功后pod setup\"></a>成功后<code>pod setup</code></h2><h2 id=\"验证是否成功：\"><a href=\"#验证是否成功：\" class=\"headerlink\" title=\"验证是否成功：\"></a>验证是否成功：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod search EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n"},{"title":"内核架构","comments":1,"description":"内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的...","_content":"\n# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","source":"_posts/内核架构.md","raw":"---\ntitle: 内核架构\ncomments: true\ndescription: \"内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n- 内核架构 \n---\n\n# 内核架构\n内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。\n\n## 1. 内核的分类\n### 1.1 巨内核（内核空间和用户空间共享）\n- 将所有的内核功能--线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。\n- 所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。\n\n### 1.2 微内核\n微内核只包含核心代码--内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：\n\n- 正确性，得益于两点：\n\t1. 代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。\n\t2. 各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。\n- 灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。\n\n缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。\n\n### 1.3 混合内核\n内核**最核心的部分**支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。**最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务**。\n\n## 2. 内核态\nCPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。\n\n### 2.1 内核态/用户态的转换机制\n- 自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）\n- 非自愿转换（发生异常、中断、处理陷阱的时候）\n\n### 2.2 非自愿转换\n\n#### 2.2.1 异常（Mach当中将所有异常都称作**陷阱**）\n异常分为：错误、陷阱、终止。\n\n#### 2.2.2 中断\n中断能被分发出去的的条件：\n\n- 对应的中断请求线当前不忙。\n- 没有编号更低（编号越多优先级越高）的中断线的状态为忙。\n- 本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。\n\n#### 2.2.3 异常/中断的分发过程\n![公共分发器][1]\n\n### 2.3 自愿的内核转换\n\n#### 2.3.1 模拟中断\n\n#### 2.3.2 SYSENTER/SYSCALL\n\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\n\n","slug":"内核架构","published":1,"date":"2016-11-15T09:28:55.000Z","updated":"2016-11-15T09:28:55.000Z","layout":"post","photos":[],"link":"","_id":"cj0brth4g001sgivb6m8q7795","content":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>","excerpt":"","more":"<h1 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h1><p>内核架构的分类，其实是按照内核态、内核所在的内存空间和用户态进程的内存空间之间的共享程度来区分的。</p>\n<h2 id=\"1-内核的分类\"><a href=\"#1-内核的分类\" class=\"headerlink\" title=\"1. 内核的分类\"></a>1. 内核的分类</h2><h3 id=\"1-1-巨内核（内核空间和用户空间共享）\"><a href=\"#1-1-巨内核（内核空间和用户空间共享）\" class=\"headerlink\" title=\"1.1 巨内核（内核空间和用户空间共享）\"></a>1.1 巨内核（内核空间和用户空间共享）</h3><ul>\n<li>将所有的内核功能–线程调度、内存管理、文件系统、安全管理、设备驱动等都放到一起。</li>\n<li>所有的功能都实现在同一内存空间中，并且这个地址空间还会映射到每一个进程的内存中。这样做的好处就是：内核态到用户态的切换效率非常高，基本上就是一次线程切换的开销。</li>\n</ul>\n<h3 id=\"1-2-微内核\"><a href=\"#1-2-微内核\" class=\"headerlink\" title=\"1.2 微内核\"></a>1.2 微内核</h3><p>微内核只包含核心代码–内存管理、任务调度。其他的功能全部交给外部的服务程序完成，并且服务程序之间完全隔离开，它们之间的所有通信都是通过消息传递来完成。这样做的好处有两点：</p>\n<ul>\n<li>正确性，得益于两点：<ol>\n<li>代码量少。所以可以遍历代码验证其功能的正确性、稳定性和健壮性。</li>\n<li>各个服务程序之间内存空间的隔离，因此，如果出现问题只重启出问题的服务就可以了。</li>\n</ol>\n</li>\n<li>灵活性：由于微内核的功能定义的非常好，所以移植到其他架构的工作比较简单直接。</li>\n</ul>\n<p>缺点就是：性能。微内核的消息传递在底层需要通过内存复制操作以及数次的上下文切换来实现，而这些对计算速度的影响都不小。这一点太严重了，所以“纯粹”的微内核操作系统基本上只有学术意义。</p>\n<h3 id=\"1-3-混合内核\"><a href=\"#1-3-混合内核\" class=\"headerlink\" title=\"1.3 混合内核\"></a>1.3 混合内核</h3><p>内核<strong>最核心的部分</strong>支持底层服务，包括：调度、进程间通信（IPC）和虚拟内存，这部分跟微内核一样。所有其他的服务都在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间。<strong>最核心的部分只能调用自己的组件、其他的服务则可以调内核的所有服务</strong>。</p>\n<h2 id=\"2-内核态\"><a href=\"#2-内核态\" class=\"headerlink\" title=\"2. 内核态\"></a>2. 内核态</h2><p>CPU通过设置特殊的寄存器来标记当前程序是是在何种模式下。</p>\n<h3 id=\"2-1-内核态-用户态的转换机制\"><a href=\"#2-1-内核态-用户态的转换机制\" class=\"headerlink\" title=\"2.1 内核态/用户态的转换机制\"></a>2.1 内核态/用户态的转换机制</h3><ul>\n<li>自愿转换（应用程序要求内核服务的时候，即调用系统服务的时候可以进入内核态）</li>\n<li>非自愿转换（发生异常、中断、处理陷阱的时候）</li>\n</ul>\n<h3 id=\"2-2-非自愿转换\"><a href=\"#2-2-非自愿转换\" class=\"headerlink\" title=\"2.2 非自愿转换\"></a>2.2 非自愿转换</h3><h4 id=\"2-2-1-异常（Mach当中将所有异常都称作陷阱）\"><a href=\"#2-2-1-异常（Mach当中将所有异常都称作陷阱）\" class=\"headerlink\" title=\"2.2.1 异常（Mach当中将所有异常都称作陷阱）\"></a>2.2.1 异常（Mach当中将所有异常都称作<strong>陷阱</strong>）</h4><p>异常分为：错误、陷阱、终止。</p>\n<h4 id=\"2-2-2-中断\"><a href=\"#2-2-2-中断\" class=\"headerlink\" title=\"2.2.2 中断\"></a>2.2.2 中断</h4><p>中断能被分发出去的的条件：</p>\n<ul>\n<li>对应的中断请求线当前不忙。</li>\n<li>没有编号更低（编号越多优先级越高）的中断线的状态为忙。</li>\n<li>本地CPU/处理器核心（通过底层CLI/STI汇编指令）禁用所有的中断。</li>\n</ul>\n<h4 id=\"2-2-3-异常-中断的分发过程\"><a href=\"#2-2-3-异常-中断的分发过程\" class=\"headerlink\" title=\"2.2.3 异常/中断的分发过程\"></a>2.2.3 异常/中断的分发过程</h4><p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/exception-interruption.png?raw=true\" alt=\"公共分发器\"></p>\n<h3 id=\"2-3-自愿的内核转换\"><a href=\"#2-3-自愿的内核转换\" class=\"headerlink\" title=\"2.3 自愿的内核转换\"></a>2.3 自愿的内核转换</h3><h4 id=\"2-3-1-模拟中断\"><a href=\"#2-3-1-模拟中断\" class=\"headerlink\" title=\"2.3.1 模拟中断\"></a>2.3.1 模拟中断</h4><h4 id=\"2-3-2-SYSENTER-SYSCALL\"><a href=\"#2-3-2-SYSENTER-SYSCALL\" class=\"headerlink\" title=\"2.3.2 SYSENTER/SYSCALL\"></a>2.3.2 SYSENTER/SYSCALL</h4>"},{"title":"引导过程：EFI和iBoot","description":"引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的...","_content":"\n## 什么是引导过程\n引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：\n\n1. 刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。\n2. 接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到`操作系统加载器`。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。\n3. 由操作系统加载器加载操作系统代码。\n\n## EFI（Extensible Firmware Interface，可扩展固件接口）\n\n### BIOS的局限性\n- BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。\n- 只允许4个可引导分区（或称为主分区）。\n\n### EFI的概念\n正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。\n> EFI自下而上的架构大概是：硬件->固件（包含：EFI引导服务和EFI运行时服务）->EFI二进制文件（EFI引导加载器）->软件\n\n### EFI提供的服务\n\n#### EFI引导服务\n当系统仍然在EFI环境中，并且没有调用`ExitBootServices()`这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了`ExitBootServices()`,引导服务就无法访问了。\n\n对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：\n\n- **控制台协议**（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）\n- **媒介访问**（和文件系统打交道）\n- **杂项协议**（）\n\n#### EFI运行时服务\n跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：\n\n- 时间管理\n- 闹钟\n- 固件变量\n- 其他杂项\n\n## OS X的boot.efi\n1. 调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。\n2. 引导内核，EFI引导服务退出。\n3. 内核回调EFI运行时服务。\n\n## iOS的iBoot\niOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：\n\n- **普通引导、恢复模式引导**\n- **DFU模式引导**\n\n![图1][1]\n\n整个引导过程大概是这样的：\n\n1. 首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)\n2. 接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。\n3. 普通引导或恢复模式引导：\n\t- 加载LLB（Low level Bootloader，底层引导加载器。\n\t- 加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 \n4. DFU模式引导，使用了两个镜像iBSS和iBEC。\n\t- iBSS：负责底层初始化以及iBEC的加载。\n\t- iBEC：负责iTunes通过USB升级的过程。\n\n### 普通引导或恢复模式引导\n#### LLB\n它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。\n#### iBoot\niBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：\n\n- **“main”线程**，负责苹果的logo，以及系统的引导。\n- **“uart reader”线程**，这个线程用户调试用。\n\n正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入**恢复模式**，main线程会派生几下几个任务：\n\n- **idleoff任务**，当用户不操作时，关闭设备。\n- **poweroff任务**，当电量不足的时候，关闭设备。\n- **usb-req任务**，处理iTunes的USB请求。\n- **usb-high-current和usb-no-current任务**，响应USB充电。（当设备充电或者断开充电，修改电池图标）\n- **command任务**,启动命令行接口，即通过串口操作的控制台。\n\n#### 恢复模式引导与普通引导的区别\n恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。\n\n### DFU模式引导\n再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。\n\n## OS X的安装过程\n### 步骤1：installXXX.app\n安装包包含的文件如下图所示：\n![图2][2]\n运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作`根文件系统`的镜像--BaseSystem.dmg，然后通过`bless`命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。\n\n### 步骤2：OSInstaller\n引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。\n### 步骤3：安装.pkg文件\n最后就是安装各种各样的软件包了。\n\n## iOS文件系统镜像（.ipsw文件）\n将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。\n![图3][3]\n\n> 可以使用工具[wpwntool][4]解密文件，使用[vfdecrypt][4]解密系统镜像。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/ipsw.png?raw=true\n[4]: http://theiphonewiki.com/\n\n\n\n\n\n\n\n","source":"_posts/引导过程：EFI和iBoot.md","raw":"---\ntitle: 引导过程：EFI和iBoot\ndescription: \"引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 引导过程\n---\n\n## 什么是引导过程\n引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：\n\n1. 刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。\n2. 接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到`操作系统加载器`。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。\n3. 由操作系统加载器加载操作系统代码。\n\n## EFI（Extensible Firmware Interface，可扩展固件接口）\n\n### BIOS的局限性\n- BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。\n- 只允许4个可引导分区（或称为主分区）。\n\n### EFI的概念\n正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。\n> EFI自下而上的架构大概是：硬件->固件（包含：EFI引导服务和EFI运行时服务）->EFI二进制文件（EFI引导加载器）->软件\n\n### EFI提供的服务\n\n#### EFI引导服务\n当系统仍然在EFI环境中，并且没有调用`ExitBootServices()`这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了`ExitBootServices()`,引导服务就无法访问了。\n\n对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：\n\n- **控制台协议**（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）\n- **媒介访问**（和文件系统打交道）\n- **杂项协议**（）\n\n#### EFI运行时服务\n跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：\n\n- 时间管理\n- 闹钟\n- 固件变量\n- 其他杂项\n\n## OS X的boot.efi\n1. 调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。\n2. 引导内核，EFI引导服务退出。\n3. 内核回调EFI运行时服务。\n\n## iOS的iBoot\niOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：\n\n- **普通引导、恢复模式引导**\n- **DFU模式引导**\n\n![图1][1]\n\n整个引导过程大概是这样的：\n\n1. 首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)\n2. 接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。\n3. 普通引导或恢复模式引导：\n\t- 加载LLB（Low level Bootloader，底层引导加载器。\n\t- 加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 \n4. DFU模式引导，使用了两个镜像iBSS和iBEC。\n\t- iBSS：负责底层初始化以及iBEC的加载。\n\t- iBEC：负责iTunes通过USB升级的过程。\n\n### 普通引导或恢复模式引导\n#### LLB\n它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。\n#### iBoot\niBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：\n\n- **“main”线程**，负责苹果的logo，以及系统的引导。\n- **“uart reader”线程**，这个线程用户调试用。\n\n正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入**恢复模式**，main线程会派生几下几个任务：\n\n- **idleoff任务**，当用户不操作时，关闭设备。\n- **poweroff任务**，当电量不足的时候，关闭设备。\n- **usb-req任务**，处理iTunes的USB请求。\n- **usb-high-current和usb-no-current任务**，响应USB充电。（当设备充电或者断开充电，修改电池图标）\n- **command任务**,启动命令行接口，即通过串口操作的控制台。\n\n#### 恢复模式引导与普通引导的区别\n恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。\n\n### DFU模式引导\n再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。\n\n## OS X的安装过程\n### 步骤1：installXXX.app\n安装包包含的文件如下图所示：\n![图2][2]\n运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作`根文件系统`的镜像--BaseSystem.dmg，然后通过`bless`命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。\n\n### 步骤2：OSInstaller\n引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。\n### 步骤3：安装.pkg文件\n最后就是安装各种各样的软件包了。\n\n## iOS文件系统镜像（.ipsw文件）\n将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。\n![图3][3]\n\n> 可以使用工具[wpwntool][4]解密文件，使用[vfdecrypt][4]解密系统镜像。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/ipsw.png?raw=true\n[4]: http://theiphonewiki.com/\n\n\n\n\n\n\n\n","slug":"引导过程：EFI和iBoot","published":1,"date":"2016-11-15T09:29:08.000Z","updated":"2016-11-15T09:29:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4i001vgivbmy0dk5f1","content":"<h2 id=\"什么是引导过程\"><a href=\"#什么是引导过程\" class=\"headerlink\" title=\"什么是引导过程\"></a>什么是引导过程</h2><p>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>\n<ol>\n<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>\n<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>\n<li>由操作系统加载器加载操作系统代码。</li>\n</ol>\n<h2 id=\"EFI（Extensible-Firmware-Interface，可扩展固件接口）\"><a href=\"#EFI（Extensible-Firmware-Interface，可扩展固件接口）\" class=\"headerlink\" title=\"EFI（Extensible Firmware Interface，可扩展固件接口）\"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id=\"BIOS的局限性\"><a href=\"#BIOS的局限性\" class=\"headerlink\" title=\"BIOS的局限性\"></a>BIOS的局限性</h3><ul>\n<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>\n<li>只允许4个可引导分区（或称为主分区）。</li>\n</ul>\n<h3 id=\"EFI的概念\"><a href=\"#EFI的概念\" class=\"headerlink\" title=\"EFI的概念\"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>\n<blockquote>\n<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>\n</blockquote>\n<h3 id=\"EFI提供的服务\"><a href=\"#EFI提供的服务\" class=\"headerlink\" title=\"EFI提供的服务\"></a>EFI提供的服务</h3><h4 id=\"EFI引导服务\"><a href=\"#EFI引导服务\" class=\"headerlink\" title=\"EFI引导服务\"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>\n<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>\n<ul>\n<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>\n<li><strong>媒介访问</strong>（和文件系统打交道）</li>\n<li><strong>杂项协议</strong>（）</li>\n</ul>\n<h4 id=\"EFI运行时服务\"><a href=\"#EFI运行时服务\" class=\"headerlink\" title=\"EFI运行时服务\"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>\n<ul>\n<li>时间管理</li>\n<li>闹钟</li>\n<li>固件变量</li>\n<li>其他杂项</li>\n</ul>\n<h2 id=\"OS-X的boot-efi\"><a href=\"#OS-X的boot-efi\" class=\"headerlink\" title=\"OS X的boot.efi\"></a>OS X的boot.efi</h2><ol>\n<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>\n<li>引导内核，EFI引导服务退出。</li>\n<li>内核回调EFI运行时服务。</li>\n</ol>\n<h2 id=\"iOS的iBoot\"><a href=\"#iOS的iBoot\" class=\"headerlink\" title=\"iOS的iBoot\"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>\n<ul>\n<li><strong>普通引导、恢复模式引导</strong></li>\n<li><strong>DFU模式引导</strong></li>\n</ul>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\" alt=\"图1\"></p>\n<p>整个引导过程大概是这样的：</p>\n<ol>\n<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>\n<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>\n<li>普通引导或恢复模式引导：<ul>\n<li>加载LLB（Low level Bootloader，底层引导加载器。</li>\n<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>\n</ul>\n</li>\n<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>\n<li>iBSS：负责底层初始化以及iBEC的加载。</li>\n<li>iBEC：负责iTunes通过USB升级的过程。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"普通引导或恢复模式引导\"><a href=\"#普通引导或恢复模式引导\" class=\"headerlink\" title=\"普通引导或恢复模式引导\"></a>普通引导或恢复模式引导</h3><h4 id=\"LLB\"><a href=\"#LLB\" class=\"headerlink\" title=\"LLB\"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>\n<h4 id=\"iBoot\"><a href=\"#iBoot\" class=\"headerlink\" title=\"iBoot\"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>\n<ul>\n<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>\n<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>\n</ul>\n<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>\n<ul>\n<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>\n<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>\n<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>\n<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>\n<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>\n</ul>\n<h4 id=\"恢复模式引导与普通引导的区别\"><a href=\"#恢复模式引导与普通引导的区别\" class=\"headerlink\" title=\"恢复模式引导与普通引导的区别\"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>\n<h3 id=\"DFU模式引导\"><a href=\"#DFU模式引导\" class=\"headerlink\" title=\"DFU模式引导\"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>\n<h2 id=\"OS-X的安装过程\"><a href=\"#OS-X的安装过程\" class=\"headerlink\" title=\"OS X的安装过程\"></a>OS X的安装过程</h2><h3 id=\"步骤1：installXXX-app\"><a href=\"#步骤1：installXXX-app\" class=\"headerlink\" title=\"步骤1：installXXX.app\"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\" alt=\"图2\"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>\n<h3 id=\"步骤2：OSInstaller\"><a href=\"#步骤2：OSInstaller\" class=\"headerlink\" title=\"步骤2：OSInstaller\"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>\n<h3 id=\"步骤3：安装-pkg文件\"><a href=\"#步骤3：安装-pkg文件\" class=\"headerlink\" title=\"步骤3：安装.pkg文件\"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>\n<h2 id=\"iOS文件系统镜像（-ipsw文件）\"><a href=\"#iOS文件系统镜像（-ipsw文件）\" class=\"headerlink\" title=\"iOS文件系统镜像（.ipsw文件）\"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true\" alt=\"图3\"></p>\n<blockquote>\n<p>可以使用工具<a href=\"http://theiphonewiki.com/\" target=\"_blank\" rel=\"external\">wpwntool</a>解密文件，使用<a href=\"http://theiphonewiki.com/\" target=\"_blank\" rel=\"external\">vfdecrypt</a>解密系统镜像。</p>\n</blockquote>\n<hr>\n","excerpt":"","more":"<h2 id=\"什么是引导过程\"><a href=\"#什么是引导过程\" class=\"headerlink\" title=\"什么是引导过程\"></a>什么是引导过程</h2><p>引导过程指的是：从计算机通电的那一瞬间到CPU开始执行操作系统代码时的整个过程。整个过程大概是这样子的：</p>\n<ol>\n<li>刚通电的时候，BIOS或者固件会加载一些自举代码（bootstrap）给CPU，这些代码会探测各种存在设备。</li>\n<li>接着寻找引导磁盘，在引导磁盘的活动分区的第一个扇区找到<code>操作系统加载器</code>。由于BIOS的局限性，只支持一个操作系统的加载，如果需要安装多个操作系统，则要接住第三方的引导加载（如：GRUB），来提供操作系统的选择菜单。</li>\n<li>由操作系统加载器加载操作系统代码。</li>\n</ol>\n<h2 id=\"EFI（Extensible-Firmware-Interface，可扩展固件接口）\"><a href=\"#EFI（Extensible-Firmware-Interface，可扩展固件接口）\" class=\"headerlink\" title=\"EFI（Extensible Firmware Interface，可扩展固件接口）\"></a>EFI（Extensible Firmware Interface，可扩展固件接口）</h2><h3 id=\"BIOS的局限性\"><a href=\"#BIOS的局限性\" class=\"headerlink\" title=\"BIOS的局限性\"></a>BIOS的局限性</h3><ul>\n<li>BIOS只能访问1M的内存。例如：在启动windows的时候，会发现开始的时候分辨率极低，在windows的logo出来以后才恢复正常。</li>\n<li>只允许4个可引导分区（或称为主分区）。</li>\n</ul>\n<h3 id=\"EFI的概念\"><a href=\"#EFI的概念\" class=\"headerlink\" title=\"EFI的概念\"></a>EFI的概念</h3><p>正因为BIOS的局限性，EFI应运而生。EFI是一套接口，它规范了一组应用程序编程的接口。基于EFI开发的程序通常都是引导加载器（如：基于Linux的GRUB，苹果的boot.efi和Boot Camp），但也可以是一些诊断程序（如：苹果的硬件测试工具），甚至还可以是编译时链接了EFI API的普通程序。</p>\n<blockquote>\n<p>EFI自下而上的架构大概是：硬件-&gt;固件（包含：EFI引导服务和EFI运行时服务）-&gt;EFI二进制文件（EFI引导加载器）-&gt;软件</p>\n</blockquote>\n<h3 id=\"EFI提供的服务\"><a href=\"#EFI提供的服务\" class=\"headerlink\" title=\"EFI提供的服务\"></a>EFI提供的服务</h3><h4 id=\"EFI引导服务\"><a href=\"#EFI引导服务\" class=\"headerlink\" title=\"EFI引导服务\"></a>EFI引导服务</h4><p>当系统仍然在EFI环境中，并且没有调用<code>ExitBootServices()</code>这个特殊的函数之前，可以访问引导服务。它提供了对内存、硬件的访问，还支持加载EFI程序，此时的资源都被认为归固件所有。一旦调用了<code>ExitBootServices()</code>,引导服务就无法访问了。</p>\n<p>对于硬件的访问，EFI定义了协议的概念，每个协议都是一个唯一的128位的GUID，它封装了和某个特定设备或某一类设备相关的API。这些协议有：</p>\n<ul>\n<li><strong>控制台协议</strong>（控制负责用户输入输出的设备，如：键盘、鼠标、串口、屏幕以及其他一些更复杂的设备）</li>\n<li><strong>媒介访问</strong>（和文件系统打交道）</li>\n<li><strong>杂项协议</strong>（）</li>\n</ul>\n<h4 id=\"EFI运行时服务\"><a href=\"#EFI运行时服务\" class=\"headerlink\" title=\"EFI运行时服务\"></a>EFI运行时服务</h4><p>跟引导服务一样可以运行在EFI模式下，但是跟引导不同之处在于，运行时服务在退出EFI模式依然可以使用。不过运行时服务不能提供引导服务所提供的各种服务。只包含一下这些服务：</p>\n<ul>\n<li>时间管理</li>\n<li>闹钟</li>\n<li>固件变量</li>\n<li>其他杂项</li>\n</ul>\n<h2 id=\"OS-X的boot-efi\"><a href=\"#OS-X的boot-efi\" class=\"headerlink\" title=\"OS X的boot.efi\"></a>OS X的boot.efi</h2><ol>\n<li>调用EFI引导服务来完成获取设备树、画logo、加载链接好的内核（loadKernelCache）、加载RAMDisk到内存、跳转到内核入口点等工作。</li>\n<li>引导内核，EFI引导服务退出。</li>\n<li>内核回调EFI运行时服务。</li>\n</ol>\n<h2 id=\"iOS的iBoot\"><a href=\"#iOS的iBoot\" class=\"headerlink\" title=\"iOS的iBoot\"></a>iOS的iBoot</h2><p>iOS的引导是苹果独创的，构成如下图所示，起引导过程分两条主线：</p>\n<ul>\n<li><strong>普通引导、恢复模式引导</strong></li>\n<li><strong>DFU模式引导</strong></li>\n</ul>\n<p><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/The%20iOS%20Boot%20Progress.png?raw=true\" alt=\"图1\"></p>\n<p>整个引导过程大概是这样的：</p>\n<ol>\n<li>首先加载Boot ROM。(只有这一步骤是未加密的，其他的步骤是都是加密的)</li>\n<li>接着判断是否是DFU模式，是则跳到步骤4，否则跳到步骤3。</li>\n<li>普通引导或恢复模式引导：<ul>\n<li>加载LLB（Low level Bootloader，底层引导加载器。</li>\n<li>加载iBoot这个主引导加载器，它负责定位、准备并加载kernelCache（链接好的内核）。 </li>\n</ul>\n</li>\n<li>DFU模式引导，使用了两个镜像iBSS和iBEC。<ul>\n<li>iBSS：负责底层初始化以及iBEC的加载。</li>\n<li>iBEC：负责iTunes通过USB升级的过程。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"普通引导或恢复模式引导\"><a href=\"#普通引导或恢复模式引导\" class=\"headerlink\" title=\"普通引导或恢复模式引导\"></a>普通引导或恢复模式引导</h3><h4 id=\"LLB\"><a href=\"#LLB\" class=\"headerlink\" title=\"LLB\"></a>LLB</h4><p>它是iOS镜像的一部分，可以在镜像中的Firmware/all_flash.xxxlp.production/下找到一个名为LLB.xxx.RELEASE.img3的文件。</p>\n<h4 id=\"iBoot\"><a href=\"#iBoot\" class=\"headerlink\" title=\"iBoot\"></a>iBoot</h4><p>iBoot自带一个内建的HFS+的驱动程序，可以访问iOS的文件系统，iBoot是多线程的，通常至少派生两个线程：</p>\n<ul>\n<li><strong>“main”线程</strong>，负责苹果的logo，以及系统的引导。</li>\n<li><strong>“uart reader”线程</strong>，这个线程用户调试用。</li>\n</ul>\n<p>正常情况下，iBoot会调用fsboot()函数，这个函数会挂在iOS文件系统分区，定位内核，准备设备树并引导系统。如果引导失败（或终止），iBoot进入<strong>恢复模式</strong>，main线程会派生几下几个任务：</p>\n<ul>\n<li><strong>idleoff任务</strong>，当用户不操作时，关闭设备。</li>\n<li><strong>poweroff任务</strong>，当电量不足的时候，关闭设备。</li>\n<li><strong>usb-req任务</strong>，处理iTunes的USB请求。</li>\n<li><strong>usb-high-current和usb-no-current任务</strong>，响应USB充电。（当设备充电或者断开充电，修改电池图标）</li>\n<li><strong>command任务</strong>,启动命令行接口，即通过串口操作的控制台。</li>\n</ul>\n<h4 id=\"恢复模式引导与普通引导的区别\"><a href=\"#恢复模式引导与普通引导的区别\" class=\"headerlink\" title=\"恢复模式引导与普通引导的区别\"></a>恢复模式引导与普通引导的区别</h4><p>恢复模式与普通引导的区别在于，恢复模式使用的文件系统是ramdisk，而不是使用包含了标准的iOS镜像的flash文件系统。它是一个完整的内存文件系统，可以用来替换根文件系统，并且flash文件系统可以挂载到这个文件系统，可以修改或更新文件系统。可以在iOS的镜像（ipsw）中找到。通常是iOS更新的第3个dmg。</p>\n<h3 id=\"DFU模式引导\"><a href=\"#DFU模式引导\" class=\"headerlink\" title=\"DFU模式引导\"></a>DFU模式引导</h3><p>再这个模式中，NAND闪存中的固件本省会被更新。当iOS有新版本更新或者越狱的时候会使用到这个模式。</p>\n<h2 id=\"OS-X的安装过程\"><a href=\"#OS-X的安装过程\" class=\"headerlink\" title=\"OS X的安装过程\"></a>OS X的安装过程</h2><h3 id=\"步骤1：installXXX-app\"><a href=\"#步骤1：installXXX-app\" class=\"headerlink\" title=\"步骤1：installXXX.app\"></a>步骤1：installXXX.app</h3><p>安装包包含的文件如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSX_Installer_files.png?raw=true\" alt=\"图2\"><br>运行这个app之后，会展示一个GUI界面，收集一些用户的输入信息之后，将kernelcache、boot.efi和InstallESD.dmg这些文件拷贝到/Mac OS X Install Data这个特殊目录下，然后告诉内核挂载InstallESD.dmg作为容器镜像，其目的是为了找到用作<code>根文件系统</code>的镜像–BaseSystem.dmg，然后通过<code>bless</code>命令修改引导盘，使得系统从InstallESD.dmg引导。操作成功后，系统自动重启至新的镜像。</p>\n<h3 id=\"步骤2：OSInstaller\"><a href=\"#步骤2：OSInstaller\" class=\"headerlink\" title=\"步骤2：OSInstaller\"></a>步骤2：OSInstaller</h3><p>引导进入新系统，运行对应的kernelcache后，镜像会让luanchd运行OSInstaller，OSInstaller会从minstallconfig.xml获取安装数据，并执行diskmanagementd，重新将所有需要的磁盘分区，接着会准备一个恢复卷，其实就是：BaseSystem.dmg。</p>\n<h3 id=\"步骤3：安装-pkg文件\"><a href=\"#步骤3：安装-pkg文件\" class=\"headerlink\" title=\"步骤3：安装.pkg文件\"></a>步骤3：安装.pkg文件</h3><p>最后就是安装各种各样的软件包了。</p>\n<h2 id=\"iOS文件系统镜像（-ipsw文件）\"><a href=\"#iOS文件系统镜像（-ipsw文件）\" class=\"headerlink\" title=\"iOS文件系统镜像（.ipsw文件）\"></a>iOS文件系统镜像（.ipsw文件）</h2><p>将.ipsw文件解压以后可以看到下图展示的文件，大部分都是img3格式的文件，它们都是加密过的。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/ipsw.png?raw=true\" alt=\"图3\"></p>\n<blockquote>\n<p>可以使用工具<a href=\"http://theiphonewiki.com/\">wpwntool</a>解密文件，使用<a href=\"http://theiphonewiki.com/\">vfdecrypt</a>解密系统镜像。</p>\n</blockquote>\n<hr>\n"},{"title":"从code7到xcode8都有哪些坑?","date":"2016-10-22T02:08:17.000Z","description":"自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。","_content":"\n\n## 冲动的惩罚\n\n自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。\n\n## 坑与填平坑\n\n### Storyboard\n对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。\n\n#### 所有UI控件的宽高设定了同一个初始值：1000。\n在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。\n但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：\n - **将Storyboar的打开方式选择xcode7.x**（在右侧Show the file inspector->interface Builder Document->open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。\n - 在代码要使用UI宽高做些计算之前，调用一下**layoutIfNeeded**。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。\n\n#### cornerRadius\n本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。\n\n#### TableView static cells\n当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。\n\n#### 不支持iOS7，却可以提交iOS7应用\nXcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？\n\n#### 卡卡卡\n最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！\n\n## 最后\n这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？\n\n","source":"_posts/从code7到xcode8都有哪些坑？.md","raw":"---\ntitle: 从code7到xcode8都有哪些坑?\ncategories:\n  - Apple Development\n  - iOS开发笔记\ndate: 2016-10-22 10:08:17\ndescription: \"自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。\"\n\ntags:\n---\n\n\n## 冲动的惩罚\n\n自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。\n\n## 坑与填平坑\n\n### Storyboard\n对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。\n\n#### 所有UI控件的宽高设定了同一个初始值：1000。\n在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。\n但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：\n - **将Storyboar的打开方式选择xcode7.x**（在右侧Show the file inspector->interface Builder Document->open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。\n - 在代码要使用UI宽高做些计算之前，调用一下**layoutIfNeeded**。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。\n\n#### cornerRadius\n本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。\n\n#### TableView static cells\n当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。\n\n#### 不支持iOS7，却可以提交iOS7应用\nXcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？\n\n#### 卡卡卡\n最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！\n\n## 最后\n这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？\n\n","slug":"从code7到xcode8都有哪些坑？","published":1,"updated":"2016-11-15T07:08:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4j001ygivb9o9bceb9","content":"<h2 id=\"冲动的惩罚\"><a href=\"#冲动的惩罚\" class=\"headerlink\" title=\"冲动的惩罚\"></a>冲动的惩罚</h2><p>自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。</p>\n<h2 id=\"坑与填平坑\"><a href=\"#坑与填平坑\" class=\"headerlink\" title=\"坑与填平坑\"></a>坑与填平坑</h2><h3 id=\"Storyboard\"><a href=\"#Storyboard\" class=\"headerlink\" title=\"Storyboard\"></a>Storyboard</h3><p>对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。</p>\n<h4 id=\"所有UI控件的宽高设定了同一个初始值：1000。\"><a href=\"#所有UI控件的宽高设定了同一个初始值：1000。\" class=\"headerlink\" title=\"所有UI控件的宽高设定了同一个初始值：1000。\"></a>所有UI控件的宽高设定了同一个初始值：1000。</h4><p>在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。<br>但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：</p>\n<ul>\n<li><strong>将Storyboar的打开方式选择xcode7.x</strong>（在右侧Show the file inspector-&gt;interface Builder Document-&gt;open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。</li>\n<li>在代码要使用UI宽高做些计算之前，调用一下<strong>layoutIfNeeded</strong>。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。</li>\n</ul>\n<h4 id=\"cornerRadius\"><a href=\"#cornerRadius\" class=\"headerlink\" title=\"cornerRadius\"></a>cornerRadius</h4><p>本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。</p>\n<h4 id=\"TableView-static-cells\"><a href=\"#TableView-static-cells\" class=\"headerlink\" title=\"TableView static cells\"></a>TableView static cells</h4><p>当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。</p>\n<h4 id=\"不支持iOS7，却可以提交iOS7应用\"><a href=\"#不支持iOS7，却可以提交iOS7应用\" class=\"headerlink\" title=\"不支持iOS7，却可以提交iOS7应用\"></a>不支持iOS7，却可以提交iOS7应用</h4><p>Xcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？</p>\n<h4 id=\"卡卡卡\"><a href=\"#卡卡卡\" class=\"headerlink\" title=\"卡卡卡\"></a>卡卡卡</h4><p>最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？</p>\n","excerpt":"","more":"<h2 id=\"冲动的惩罚\"><a href=\"#冲动的惩罚\" class=\"headerlink\" title=\"冲动的惩罚\"></a>冲动的惩罚</h2><p>自从有那段使用beta版本的Mac OSX系统，导致机器时常开机卡死的经历之后，就尽量不敢在第一时间使用苹果的beta版系统。但是，由于自己是名iOS开发者，当Xcode出了beta版本无疑是需要第一时间体验一下的，即使Xcode beta版本可以不体验，但是出了第一个Release版本却是不得不更新。接下来讲的就是在使用Xcode8.0所遇到的坑。</p>\n<h2 id=\"坑与填平坑\"><a href=\"#坑与填平坑\" class=\"headerlink\" title=\"坑与填平坑\"></a>坑与填平坑</h2><h3 id=\"Storyboard\"><a href=\"#Storyboard\" class=\"headerlink\" title=\"Storyboard\"></a>Storyboard</h3><p>对于Storyboard相信大家对它都不陌生，自从iOS5之后就开始支持了，是一种可视化开发组件。本人使用过Android、Windows Phone以及iOS的可视化组件，可以说Storyboard是这三个平台中最流畅、最好用的可视化开发组件，采用StoryBoard虽然会比纯代码写UI效率上会有那么一点损耗，但对于一般的应用，在开发之初它确实可以大大的提高开发效率、也易于维护（可以想想当年那些不采用Storyboard编写的代码，即使更改一个坐标位置都是极其痛苦的），可以说是利大于弊。但是就在最近升级到Xcode8之后，发现StoryBoard有如下几点变动（坑）。</p>\n<h4 id=\"所有UI控件的宽高设定了同一个初始值：1000。\"><a href=\"#所有UI控件的宽高设定了同一个初始值：1000。\" class=\"headerlink\" title=\"所有UI控件的宽高设定了同一个初始值：1000。\"></a>所有UI控件的宽高设定了同一个初始值：1000。</h4><p>在Xcode7的时候，StoryBoard生成的UI控件的默认宽高都是3.5英寸的宽高。采用自动布局时，在load完Storyboard之后，读取到UI控件的宽虽然不正确，但是大部分情况下高却是我们想要的，并且由于宽是320，是小于等于任何尺寸的宽，所以在UI渲染上并没有可见性的问题。<br>但是对于Xcode8则不同，只要是通过Storyboard生成的UI都是统一给定一个固定值：1000。在load完Storyboard之后，自动布局计算完高度之前，读出来的宽高都是1000。这就导致原先所有依赖于bounds计算位置宽高，没有任何问题的UI展示逻辑，采用Xcode8一编译就乱套了，比如会看到：图片无故拉长后再恢复原状，原先好好的布局出现了UI重叠在一起，有的UI甚至刷新不出来等。解决的办法主要有两个：</p>\n<ul>\n<li><strong>将Storyboar的打开方式选择xcode7.x</strong>（在右侧Show the file inspector-&gt;interface Builder Document-&gt;open in）。但这么做的缺点是：当你再次打开Storyboard，Xcode又帮你自动选中打开方式为Xcode8.0。而且为了以后着想，还是采用下面这种方式吧。</li>\n<li>在代码要使用UI宽高做些计算之前，调用一下<strong>layoutIfNeeded</strong>。这样就能获得在Storyboard设计的宽高（当使用4.0英寸来设计获得就是在4.0英寸下的宽高，采用的是3.0英寸来设计获得的就是3.0英寸的宽高）。</li>\n</ul>\n<h4 id=\"cornerRadius\"><a href=\"#cornerRadius\" class=\"headerlink\" title=\"cornerRadius\"></a>cornerRadius</h4><p>本人在开发过程中还遇到了这么一个问题：明明之前显示得好好的控件，为什么采用Xcode8编译之后，就消失不见了呢？并且采用Capture view Hierarchy工具查看又能看见这个控件，但是在模拟器或者真机上就是死活渲染不出来。经过各种调试最后发现是因为cornerRadius设置了一个比自己宽高还大的值（类似bounds.size.width / 2这样的逻辑，由于默认宽高为1000，因此计算出来的cornerRadius就是500了，比我的控件的宽高都大），导致了控件渲染不出来。这种情况采用上面的第二种方法，在使用bounds之前layoutIfNeeded一下，就基本跟以前一样了。</p>\n<h4 id=\"TableView-static-cells\"><a href=\"#TableView-static-cells\" class=\"headerlink\" title=\"TableView static cells\"></a>TableView static cells</h4><p>当采用Taleview的的静态cell之后，如果header的高度是动态变化的，不管你如何reload data，底下的cell的frame都不会发生改变，除非你自己手动设置目标cell的frame。</p>\n<h4 id=\"不支持iOS7，却可以提交iOS7应用\"><a href=\"#不支持iOS7，却可以提交iOS7应用\" class=\"headerlink\" title=\"不支持iOS7，却可以提交iOS7应用\"></a>不支持iOS7，却可以提交iOS7应用</h4><p>Xcode8之后就不支持iOS7设备的调试了，但是Apptore却可以提交iOS7系统的应用。当在iOS7设备上遇到bug的时候，调试就成了困难。你不得不再下载一个xcode7来进行iOS7的调试，并且前提是你没有升级macOS为10.12，否则你连xcode7都打不开，更谈不上调试了。虽然现在确实iOS7的用户量很少，可对于一个步入正轨的app，只能是慢慢的放弃。开发工具虽不支持调试，但却可以提交Appstore，这对于开发者来说，对老板，用户都不好交代。既然想要放弃iOS7，为啥不干脆整个入口都封死呢？</p>\n<h4 id=\"卡卡卡\"><a href=\"#卡卡卡\" class=\"headerlink\" title=\"卡卡卡\"></a>卡卡卡</h4><p>最后一点就是卡顿啊，特别是与macOS10.12配合一起，一编译，好几次机器几乎就变成了单进程应用了，其他的应用瞬间失灵。大好心情转瞬即逝啊！</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这次的Xcode8的升级之旅太不愉快了。经过这几年的iOS开发，一路走来感觉苹果的产品bug越来越多，也越来越不稳定，真为自己担忧啊。不知道看到这篇吐槽的iOS开发者们，你们是否也遇到了一些Xcode8的坑？</p>\n"},{"title":"文件系统和虚拟文件系统交换（VFS）","_content":"\n## 硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","source":"_posts/文件系统和虚拟文件系统交换（VFS）.md","raw":"---\ntitle: 文件系统和虚拟文件系统交换（VFS）\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 文件系统\n---\n\n## 硬盘分区\n### 主引导记录（Master Boot Record，MBR）\n- 只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。\n\n### Apple Partion Map\n- 32位方案，突破了4个分区的限制\n\n### GUID分区表（GUID Partion Table，GPT）\n- 64位方案\n\n## 软链接与硬链接\n- 通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。\n- 硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。\n- 软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。\n\n\n\n\n","slug":"文件系统和虚拟文件系统交换（VFS）","published":1,"date":"2016-10-18T13:05:19.000Z","updated":"2016-10-18T13:05:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4k0021givbxgsgxbvu","content":"<h2 id=\"硬盘分区\"><a href=\"#硬盘分区\" class=\"headerlink\" title=\"硬盘分区\"></a>硬盘分区</h2><h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"硬盘分区\"><a href=\"#硬盘分区\" class=\"headerlink\" title=\"硬盘分区\"></a>硬盘分区</h2><h3 id=\"主引导记录（Master-Boot-Record，MBR）\"><a href=\"#主引导记录（Master-Boot-Record，MBR）\" class=\"headerlink\" title=\"主引导记录（Master Boot Record，MBR）\"></a>主引导记录（Master Boot Record，MBR）</h3><ul>\n<li>只能有4个分区，2的32次方的扇区（一个扇区512字节），并且第一个扇区的前440个字节用来存储启动引导程序，从446开始的16*4个字节用来存储4个分区表的信息，剩下的2个字节则是MBR的签名。</li>\n</ul>\n<h3 id=\"Apple-Partion-Map\"><a href=\"#Apple-Partion-Map\" class=\"headerlink\" title=\"Apple Partion Map\"></a>Apple Partion Map</h3><ul>\n<li>32位方案，突破了4个分区的限制</li>\n</ul>\n<h3 id=\"GUID分区表（GUID-Partion-Table，GPT）\"><a href=\"#GUID分区表（GUID-Partion-Table，GPT）\" class=\"headerlink\" title=\"GUID分区表（GUID Partion Table，GPT）\"></a>GUID分区表（GUID Partion Table，GPT）</h3><ul>\n<li>64位方案</li>\n</ul>\n<h2 id=\"软链接与硬链接\"><a href=\"#软链接与硬链接\" class=\"headerlink\" title=\"软链接与硬链接\"></a>软链接与硬链接</h2><ul>\n<li>通常我们看到的文件名只是文件属性的一部分，而实际指向文件的是文件号（node）。</li>\n<li>硬链接就是指不同的文件名指向同一个文件号，只有所有的文件名删除掉了，该文件才会被删除。（可以类比成iOS的引用计数）。</li>\n<li>软链接则拥有自己的文件号（node），而node指向的文件数据则跟一般的文件数据不一样，它里面包含了目标文件的文件路径。（可以类比成浅拷贝），因此软链接可以夸文件系统。如果文件删除了，那么软链接指向的数据就是错误的。</li>\n</ul>\n"},{"title":"由生到死--内核引导和内核崩溃","description":"一个内核，支持多种架构 : osfmk目录包含了架构相关的子目录（如：i386，x86_64）...","_content":"\n## XNU内核的编译\n参考[Building xnu for OS X 10.11 El Capitan][2],但是还没有成功编译通过。。。\n\n## 一个内核，支持多种架构\n- osfmk目录包含了架构相关的子目录（如：i386，x86_64）。\n- pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。\n- i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：\n ![pexpert结构][1]\n\n## 内核代码树\n- 可以使用[FXR浏览工具](http://fxr.watson.org)查看源码。\n- XNU主目录结构：\n\t![XNU主目录结构][3]\n\t\n- BSD目录结构：\n\t![BSD目录结构][4]\n\t\n- OSFMK目录结构：\n\t![OSFMK目录结构][5]\t\n\n## XNU的引导过程\n**XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。**\n\n### 从高层次看XNU的引导过程\n- 整个过程如下图，后面会介绍各个阶段的细节。\n\t![高层次看XNU的引导过程][6]\n- **OSX：vstart**\n\t- 如果是Debug环境初始化串口（pal_serial_init()）。\n\t- 开启NX/XD：防止代码注入。\n\t- 初始化主CPU的[GDT和LDT][7]，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）\n\t- 初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）\n\t- 主从CPU调用相应的i386_init/i386_init_slave。\n\t\n- **iOS：start**\n\n\t这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。\n\n- **[i386|arm]_init**（osfmk/i386/i386_init.c）\n\n\t*主要工作是初始化主CPU为可用状态，然后准备好内核引导。*\n\n- **i386_init_slave()**\n初始化从CPU。\n\n- **machine_startup**\n\n主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。\n\n- **kernel_bootstrap**\n这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：\n\t- **初始化虚拟内存**。\n\t- **IPC（进程间通信）**：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。\n\t- **时钟**：通过时钟实现闹铃、报时功能。 \n\t- **账本**：Mach系统的记账功能。\n\t- **任务**：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。\n\t- **线程**：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。\n其中调用的重要的函数有：\n\t- kernel_bootstrap_thread:他的工作如下\n\t\t1. 主线程开始以`kernel_bootstrap_thread`的身份运行，初始化各个子系统。\n\t\t2. 调用kernel_create_thread()派生辅助线程。第一个创建的线程是**idle线程**（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。\n\t\t3. 下-个创建线程就是**线程调度器**，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。\n\t\t4. OSX的XNU启动`mapping_replenish线程`，在iOS上是`zone_refill_thread线程`。\n\t\t5. 如果内核设置了**SERIAL_KDP**,那么调度器会调用`init_kdp()`初始化调试器。\n\t\t6. 初始化**IOKit**，如果没有**IOKit**，XNU将无法访问硬件设备。\n\t\t7. 启用**中断**。\n\t\t8. 初始化**共享区模块（shared region）**，dyld在加载共享库时会使用这个模块，内核本身的**commpage**也会使用这个模块，**commpage**指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。\n\t\t9. 如果编译时启动了**MAC（Mandatory Access Control）**，则会调用`mac_policy_initmach()`。\n\t\t10. 调用`bsd_init`初始化BSD子系统，这个函数最终会派生出init任务来执行`bin/launchd`，init任务是所有用户态进程的祖先。\n\t\t11. 如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。\n\n## 睡眠和唤醒\n睡眠流程一般如下：\n\n- 除了当前CPU外，停止其他的CPU。\n- 关闭本地的APIC，准备进入睡眠。\n- 输出一条kdebug消息。\n- 在x86_64平台上保留CR3。\n- 调用`acpi_sleep_cpu()`,将CPU设置为睡眠状态。\n- 将控制权交给固件。\n\n唤醒处理程序的工作是：\n\n- 切换回64位模式。\n- 恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。\n- 恢复所有保存的寄存器。\n\n\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\n[7]: http://blog.csdn.net/yleek/article/details/8204393\n","source":"_posts/由生到死--内核引导和内核崩溃.md","raw":"---\ntitle: 由生到死--内核引导和内核崩溃\ndescription: \"一个内核，支持多种架构 : osfmk目录包含了架构相关的子目录（如：i386，x86_64）...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 内核\n---\n\n## XNU内核的编译\n参考[Building xnu for OS X 10.11 El Capitan][2],但是还没有成功编译通过。。。\n\n## 一个内核，支持多种架构\n- osfmk目录包含了架构相关的子目录（如：i386，x86_64）。\n- pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。\n- i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：\n ![pexpert结构][1]\n\n## 内核代码树\n- 可以使用[FXR浏览工具](http://fxr.watson.org)查看源码。\n- XNU主目录结构：\n\t![XNU主目录结构][3]\n\t\n- BSD目录结构：\n\t![BSD目录结构][4]\n\t\n- OSFMK目录结构：\n\t![OSFMK目录结构][5]\t\n\n## XNU的引导过程\n**XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。**\n\n### 从高层次看XNU的引导过程\n- 整个过程如下图，后面会介绍各个阶段的细节。\n\t![高层次看XNU的引导过程][6]\n- **OSX：vstart**\n\t- 如果是Debug环境初始化串口（pal_serial_init()）。\n\t- 开启NX/XD：防止代码注入。\n\t- 初始化主CPU的[GDT和LDT][7]，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）\n\t- 初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）\n\t- 主从CPU调用相应的i386_init/i386_init_slave。\n\t\n- **iOS：start**\n\n\t这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。\n\n- **[i386|arm]_init**（osfmk/i386/i386_init.c）\n\n\t*主要工作是初始化主CPU为可用状态，然后准备好内核引导。*\n\n- **i386_init_slave()**\n初始化从CPU。\n\n- **machine_startup**\n\n主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。\n\n- **kernel_bootstrap**\n这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：\n\t- **初始化虚拟内存**。\n\t- **IPC（进程间通信）**：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。\n\t- **时钟**：通过时钟实现闹铃、报时功能。 \n\t- **账本**：Mach系统的记账功能。\n\t- **任务**：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。\n\t- **线程**：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。\n其中调用的重要的函数有：\n\t- kernel_bootstrap_thread:他的工作如下\n\t\t1. 主线程开始以`kernel_bootstrap_thread`的身份运行，初始化各个子系统。\n\t\t2. 调用kernel_create_thread()派生辅助线程。第一个创建的线程是**idle线程**（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。\n\t\t3. 下-个创建线程就是**线程调度器**，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。\n\t\t4. OSX的XNU启动`mapping_replenish线程`，在iOS上是`zone_refill_thread线程`。\n\t\t5. 如果内核设置了**SERIAL_KDP**,那么调度器会调用`init_kdp()`初始化调试器。\n\t\t6. 初始化**IOKit**，如果没有**IOKit**，XNU将无法访问硬件设备。\n\t\t7. 启用**中断**。\n\t\t8. 初始化**共享区模块（shared region）**，dyld在加载共享库时会使用这个模块，内核本身的**commpage**也会使用这个模块，**commpage**指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。\n\t\t9. 如果编译时启动了**MAC（Mandatory Access Control）**，则会调用`mac_policy_initmach()`。\n\t\t10. 调用`bsd_init`初始化BSD子系统，这个函数最终会派生出init任务来执行`bin/launchd`，init任务是所有用户态进程的祖先。\n\t\t11. 如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。\n\n## 睡眠和唤醒\n睡眠流程一般如下：\n\n- 除了当前CPU外，停止其他的CPU。\n- 关闭本地的APIC，准备进入睡眠。\n- 输出一条kdebug消息。\n- 在x86_64平台上保留CR3。\n- 调用`acpi_sleep_cpu()`,将CPU设置为睡眠状态。\n- 将控制权交给固件。\n\n唤醒处理程序的工作是：\n\n- 切换回64位模式。\n- 恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。\n- 恢复所有保存的寄存器。\n\n\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\n[2]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\n[3]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\n[4]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\n[5]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\n[6]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\n[7]: http://blog.csdn.net/yleek/article/details/8204393\n","slug":"由生到死--内核引导和内核崩溃","published":1,"date":"2016-11-15T09:29:18.000Z","updated":"2016-11-15T09:29:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4m0024givbb4hljdy6","content":"<h2 id=\"XNU内核的编译\"><a href=\"#XNU内核的编译\" class=\"headerlink\" title=\"XNU内核的编译\"></a>XNU内核的编译</h2><p>参考<a href=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>\n<h2 id=\"一个内核，支持多种架构\"><a href=\"#一个内核，支持多种架构\" class=\"headerlink\" title=\"一个内核，支持多种架构\"></a>一个内核，支持多种架构</h2><ul>\n<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>\n<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>\n<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\" alt=\"pexpert结构\"></li>\n</ul>\n<h2 id=\"内核代码树\"><a href=\"#内核代码树\" class=\"headerlink\" title=\"内核代码树\"></a>内核代码树</h2><ul>\n<li>可以使用<a href=\"http://fxr.watson.org\" target=\"_blank\" rel=\"external\">FXR浏览工具</a>查看源码。</li>\n<li><p>XNU主目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\" alt=\"XNU主目录结构\"></p>\n</li>\n<li><p>BSD目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\" alt=\"BSD目录结构\"></p>\n</li>\n<li><p>OSFMK目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\" alt=\"OSFMK目录结构\">    </p>\n</li>\n</ul>\n<h2 id=\"XNU的引导过程\"><a href=\"#XNU的引导过程\" class=\"headerlink\" title=\"XNU的引导过程\"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>\n<h3 id=\"从高层次看XNU的引导过程\"><a href=\"#从高层次看XNU的引导过程\" class=\"headerlink\" title=\"从高层次看XNU的引导过程\"></a>从高层次看XNU的引导过程</h3><ul>\n<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\" alt=\"高层次看XNU的引导过程\"></li>\n<li><p><strong>OSX：vstart</strong></p>\n<ul>\n<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>\n<li>开启NX/XD：防止代码注入。</li>\n<li>初始化主CPU的<a href=\"http://blog.csdn.net/yleek/article/details/8204393\" target=\"_blank\" rel=\"external\">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>\n<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>\n<li>主从CPU调用相应的i386_init/i386_init_slave。</li>\n</ul>\n</li>\n<li><p><strong>iOS：start</strong></p>\n<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>\n</li>\n<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>\n<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>\n</li>\n<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>\n</li>\n<li><p><strong>machine_startup</strong></p>\n</li>\n</ul>\n<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>\n<ul>\n<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>\n<li><strong>初始化虚拟内存</strong>。</li>\n<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>\n<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>\n<li><strong>账本</strong>：Mach系统的记账功能。</li>\n<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>\n<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>\n<li>kernel_bootstrap_thread:他的工作如下<ol>\n<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>\n<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>\n<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>\n<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>\n<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>\n<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>\n<li>启用<strong>中断</strong>。</li>\n<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>\n<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>\n<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>\n<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"睡眠和唤醒\"><a href=\"#睡眠和唤醒\" class=\"headerlink\" title=\"睡眠和唤醒\"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>\n<ul>\n<li>除了当前CPU外，停止其他的CPU。</li>\n<li>关闭本地的APIC，准备进入睡眠。</li>\n<li>输出一条kdebug消息。</li>\n<li>在x86_64平台上保留CR3。</li>\n<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>\n<li>将控制权交给固件。</li>\n</ul>\n<p>唤醒处理程序的工作是：</p>\n<ul>\n<li>切换回64位模式。</li>\n<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>\n<li>恢复所有保存的寄存器。</li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"XNU内核的编译\"><a href=\"#XNU内核的编译\" class=\"headerlink\" title=\"XNU内核的编译\"></a>XNU内核的编译</h2><p>参考<a href=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20%26%20iOS操作系统/Building%20xnu%20for%20OS%20X%2010.11%20El%20Capitan.md\">Building xnu for OS X 10.11 El Capitan</a>,但是还没有成功编译通过。。。</p>\n<h2 id=\"一个内核，支持多种架构\"><a href=\"#一个内核，支持多种架构\" class=\"headerlink\" title=\"一个内核，支持多种架构\"></a>一个内核，支持多种架构</h2><ul>\n<li>osfmk目录包含了架构相关的子目录（如：i386，x86_64）。</li>\n<li>pexpert目录（即，Platform Expert的目录）,规模不大，但很重要，包含了每个架构的个性化函数。</li>\n<li>i386的Platform Expert与EFI紧密结合，而ARM的Platform Expert则跟iBoot紧密结合。pexpert目录的结构如下表：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/platformExpert.png?raw=true\" alt=\"pexpert结构\"></li>\n</ul>\n<h2 id=\"内核代码树\"><a href=\"#内核代码树\" class=\"headerlink\" title=\"内核代码树\"></a>内核代码树</h2><ul>\n<li>可以使用<a href=\"http://fxr.watson.org\">FXR浏览工具</a>查看源码。</li>\n<li><p>XNU主目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_SubDirectory.png?raw=true\" alt=\"XNU主目录结构\"></p>\n</li>\n<li><p>BSD目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/BSD_SubDirectory.png?raw=true\" alt=\"BSD目录结构\"></p>\n</li>\n<li><p>OSFMK目录结构：<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/OSFMK_Subdirectory.png?raw=true\" alt=\"OSFMK目录结构\">    </p>\n</li>\n</ul>\n<h2 id=\"XNU的引导过程\"><a href=\"#XNU的引导过程\" class=\"headerlink\" title=\"XNU的引导过程\"></a>XNU的引导过程</h2><p><strong>XNU是一个Mach-O二进制文件，引导加载器（EFI或iBoot）中包含了解析Mach-O文件的代码，可以通过LC_UNIXTHREAD命令计算出入口点。</strong></p>\n<h3 id=\"从高层次看XNU的引导过程\"><a href=\"#从高层次看XNU的引导过程\" class=\"headerlink\" title=\"从高层次看XNU的引导过程\"></a>从高层次看XNU的引导过程</h3><ul>\n<li>整个过程如下图，后面会介绍各个阶段的细节。<br>  <img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/XNU_hightLevel_boot.png?raw=true\" alt=\"高层次看XNU的引导过程\"></li>\n<li><p><strong>OSX：vstart</strong></p>\n<ul>\n<li>如果是Debug环境初始化串口（pal_serial_init()）。</li>\n<li>开启NX/XD：防止代码注入。</li>\n<li>初始化主CPU的<a href=\"http://blog.csdn.net/yleek/article/details/8204393\">GDT和LDT</a>，然后调用cpu_desc_load(64）加载主CPU和从属CPU的LDT。（cpu_desc_init[64] (osfmk/i386/mp_desc.c)）</li>\n<li>初始化所有CPU的MSR（用户SYSENTER和SYSCALL）以及物理内存映射。（cpu_mode_init()）</li>\n<li>主从CPU调用相应的i386_init/i386_init_slave。</li>\n</ul>\n</li>\n<li><p><strong>iOS：start</strong></p>\n<p>  这个函数主要的工作就是：通过设置ARM控制寄存器，安装ExceptionVectorsBase内核陷阱处理程序，以及其他的一些设置，然后跳转到arm_init。</p>\n</li>\n<li><p><strong>[i386|arm]_init</strong>（osfmk/i386/i386_init.c）</p>\n<p>  <em>主要工作是初始化主CPU为可用状态，然后准备好内核引导。</em></p>\n</li>\n<li><p><strong>i386_init_slave()</strong><br>初始化从CPU。</p>\n</li>\n<li><p><strong>machine_startup</strong></p>\n</li>\n</ul>\n<p>主要负责解析一些命令行参数（通过Platform Expert提供的PE_parse_boot_argn函数），这些参数大部分是用来调试的boot-arg，用于控制引导时的调试。</p>\n<ul>\n<li><strong>kernel_bootstrap</strong><br>这个函数继续初始化Mach内核的的各个子系统，建立起BSD所依赖的必要基础设施。主要工作有：<ul>\n<li><strong>初始化虚拟内存</strong>。</li>\n<li><strong>IPC（进程间通信）</strong>：是Mach构建的根基，IPC要求一些重要的资源，例如：内存、同步对象、Mach接口成成器（MIG）。</li>\n<li><strong>时钟</strong>：通过时钟实现闹铃、报时功能。 </li>\n<li><strong>账本</strong>：Mach系统的记账功能。</li>\n<li><strong>任务</strong>：任务是Mach的容器，类似BSD的进程（Mach的任务和BSD的进程是1:1对应的）。</li>\n<li><strong>线程</strong>：线程是实际执行的单元，任务只不过是资源的容器，真正被调度和执行的是线程。<br>其中调用的重要的函数有：</li>\n<li>kernel_bootstrap_thread:他的工作如下<ol>\n<li>主线程开始以<code>kernel_bootstrap_thread</code>的身份运行，初始化各个子系统。</li>\n<li>调用kernel_create_thread()派生辅助线程。第一个创建的线程是<strong>idle线程</strong>（这个线程是必要的，因为在所有线程都阻塞时，CPU总要有一个线程可以执行）。</li>\n<li>下-个创建线程就是<strong>线程调度器</strong>，其任务是：在特定的时间间隔以及发生中断之后判定下一个要执行的线程是什么。</li>\n<li>OSX的XNU启动<code>mapping_replenish线程</code>，在iOS上是<code>zone_refill_thread线程</code>。</li>\n<li>如果内核设置了<strong>SERIAL_KDP</strong>,那么调度器会调用<code>init_kdp()</code>初始化调试器。</li>\n<li>初始化<strong>IOKit</strong>，如果没有<strong>IOKit</strong>，XNU将无法访问硬件设备。</li>\n<li>启用<strong>中断</strong>。</li>\n<li>初始化<strong>共享区模块（shared region）</strong>，dyld在加载共享库时会使用这个模块，内核本身的<strong>commpage</strong>也会使用这个模块，<strong>commpage</strong>指的是一个从内核直接映射到所有进程的页面，包含一些导出数据和一些函数，这个页面总是驻留在同一个地址，并且所有进程都可以访问。</li>\n<li>如果编译时启动了<strong>MAC（Mandatory Access Control）</strong>，则会调用<code>mac_policy_initmach()</code>。</li>\n<li>调用<code>bsd_init</code>初始化BSD子系统，这个函数最终会派生出init任务来执行<code>bin/launchd</code>，init任务是所有用户态进程的祖先。</li>\n<li>如果内核启动时传入了serial参数，那么会创建一个专用的控制台监听线程，用来启动控制台。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"睡眠和唤醒\"><a href=\"#睡眠和唤醒\" class=\"headerlink\" title=\"睡眠和唤醒\"></a>睡眠和唤醒</h2><p>睡眠流程一般如下：</p>\n<ul>\n<li>除了当前CPU外，停止其他的CPU。</li>\n<li>关闭本地的APIC，准备进入睡眠。</li>\n<li>输出一条kdebug消息。</li>\n<li>在x86_64平台上保留CR3。</li>\n<li>调用<code>acpi_sleep_cpu()</code>,将CPU设置为睡眠状态。</li>\n<li>将控制权交给固件。</li>\n</ul>\n<p>唤醒处理程序的工作是：</p>\n<ul>\n<li>切换回64位模式。</li>\n<li>恢复内核的GDT、CR0、LDT、IDT以及任务寄存器。</li>\n<li>恢复所有保存的寄存器。</li>\n</ul>\n<hr>\n"},{"title":"简约的iOS音乐播放UI控件","date":"2016-05-24T10:46:59.000Z","description":"该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在Github上，并支持cocoapods安装...","_content":"\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","source":"_posts/简约的iOS音乐播放UI控件.md","raw":"---\ntitle: 简约的iOS音乐播放UI控件\ndate: 2016-05-24 18:46:59\ndescription: \"该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在Github上，并支持cocoapods安装...\"\ncategories: \n - Apple Development\n - iOS开发笔记\ntags:\n\n---\n\n## 这是一个什么样的控件\n该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在[Github](https://github.com/Easence/EAMiniAudioPlayerView)上，并支持cocoapods安装。\n![效果图][1]\n\n## 主要功能介绍以及使用\n- **支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。**\n  > 可以通过设置`EAMiniAudioPlayerStyleConfig`的`playerStyle`属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：\n\n\t```\n\t\ttypedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) {\n\t\tEAMiniPlayerNormal = 1 << 0,   //Has play button,sound icon\n\t\tEAMiniPlayerHidePlayButton = 1 << 1, //Hide play button\n\t\tEAMiniPlayerHideSoundIcon = 1 << 2, //Hide sound icon\n\t\tEAMiniPlayerHideText = 1 << 3, //Hide text label\n\t\t};\n\t\t EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];\n\t\t config.playerStyle |= EAMiniPlayerHidePlayButton;\n\t```\n- **支持下载进度展示。**\n实时的设置`EAMiniAudioPlayerView`的`downloadProgress`属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当`downloadProgress`的值达到1的时候会有调用`void(^downloadCompleted)(void)`这个block。\n\n- **支持播放进度展示。**\n设置`EAMiniAudioPlayerView`的`playProgress`属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当`playProgress`的值达到1的时候会有调用`void(^playCompleted)(void)`这个block。\n\n- **其他**\n自定义圆角、内容的偏移、自定义颜色等。\n\n## 怎么使用\n- **使用cocoapods安装：**\n\n\t```\n\tpod install EAMiniAudioPlayerView\n\t```\n## 结尾\n这是一个纯粹的UI控件，查看完成的demo可以移步到[这里](https://github.com/Easence/EAMiniAudioPlayerView)。\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true","slug":"简约的iOS音乐播放UI控件","published":1,"updated":"2016-11-15T09:29:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4n0028givbt4ru9dcp","content":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n","excerpt":"","more":"<h2 id=\"这是一个什么样的控件\"><a href=\"#这是一个什么样的控件\" class=\"headerlink\" title=\"这是一个什么样的控件\"></a>这是一个什么样的控件</h2><p>该控件不包含音乐播放的逻辑，单纯的只是UI层面的展示。但可以结合下载、音乐播放逻辑，拼接成一个简易的播放器。代码托管在<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">Github</a>上，并支持cocoapods安装。<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Apple/iOS%20Development/OC/images/EAMiniAudioPlayer/1.gif?raw=true\" alt=\"效果图\"></p>\n<h2 id=\"主要功能介绍以及使用\"><a href=\"#主要功能介绍以及使用\" class=\"headerlink\" title=\"主要功能介绍以及使用\"></a>主要功能介绍以及使用</h2><ul>\n<li><p><strong>支持隐藏播放按钮、隐藏声音的波浪图标、以及隐藏文字。</strong></p>\n<blockquote>\n<p>可以通过设置<code>EAMiniAudioPlayerStyleConfig</code>的<code>playerStyle</code>属性来实现只展示某部分元素, EAMiniPlayerStyle是一个枚举：</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSUInteger, EAMiniPlayerStyle) &#123;</div><div class=\"line\">EAMiniPlayerNormal = 1 &lt;&lt; 0,   //Has play button,sound icon</div><div class=\"line\">EAMiniPlayerHidePlayButton = 1 &lt;&lt; 1, //Hide play button</div><div class=\"line\">EAMiniPlayerHideSoundIcon = 1 &lt;&lt; 2, //Hide sound icon</div><div class=\"line\">EAMiniPlayerHideText = 1 &lt;&lt; 3, //Hide text label</div><div class=\"line\">&#125;;</div><div class=\"line\"> EAMiniAudioPlayerStyleConfig *config = [EAMiniAudioPlayerStyleConfig defaultConfig];</div><div class=\"line\"> config.playerStyle |= EAMiniPlayerHidePlayButton;</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持下载进度展示。</strong><br>实时的设置<code>EAMiniAudioPlayerView</code>的<code>downloadProgress</code>属性（取值在0和1之间）可以改变下载进度展示，结合下载逻辑可以实现音乐下载的效果。当<code>downloadProgress</code>的值达到1的时候会有调用<code>void(^downloadCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>支持播放进度展示。</strong><br>设置<code>EAMiniAudioPlayerView</code>的<code>playProgress</code>属性（取值在0和1之间）可以改变播放进度展示，结合音乐播放逻辑可以实现音乐播放的效果。当<code>playProgress</code>的值达到1的时候会有调用<code>void(^playCompleted)(void)</code>这个block。</p>\n</li>\n<li><p><strong>其他</strong><br>自定义圆角、内容的偏移、自定义颜色等。</p>\n</li>\n</ul>\n<h2 id=\"怎么使用\"><a href=\"#怎么使用\" class=\"headerlink\" title=\"怎么使用\"></a>怎么使用</h2><ul>\n<li><p><strong>使用cocoapods安装：</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install EAMiniAudioPlayerView</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这是一个纯粹的UI控件，查看完成的demo可以移步到<a href=\"https://github.com/Easence/EAMiniAudioPlayerView\">这里</a>。</p>\n<hr>\n"},{"title":"经典排序算法","date":"2016-11-28T09:21:09.000Z","_content":"\n\n## 一、归并排序（复杂度O(N*logN)）\n### 一轮合并操作\n1. 存在两个**有序**的数组A、B合并到一个新的数组C，并让新的数组C有序。\n2. 取出A的第一个元素与B的第一元素比较，取出小的放入数组C中。\n3. 重复步骤2，直到A、B数组至少一个为空，如果A为空，则拷贝B剩余元素到C中；B为空，则拷贝A剩余元素到C中。\n\n### 归并排序\n采用了分治的思想，递归的将需要排序的数组对半的分成两个子数组，并对这两个数组进行合并。**当被拆分的数组的元素个数小于等于1个的时候，那么这个两个子数组内部就一定是有序的，因此合并起来的数组也是有序的**。接下来就是重复以上提到的“一轮合并操作”，进行N轮的合并操作。\n### 伪代码\n```\nvoid mergesort(int a[], int first, int last, int temp[])\n{\n\tif (first < last)\n\t{\n\t\tint mid = (first + last) / 2;\n\t\tmergesort(a, first, mid, temp);    //左边有序\n\t\tmergesort(a, mid + 1, last, temp); //右边有序\n\t\tmergearray(a, first, mid, last, temp); //再将二个有序数列合并\n\t}\n}\n```\n\n## 二、快速排序(复杂度O(N*logN))\n\n### 一轮排序操作\n1. 先从数列中取出一个数作为基准数。\n2. 分区过程，将比这个数大的数全挖出来放到它的右边，小于或等于它的数挖出来放到它的左边。（*具体来说，创建两个索引l、r，遍历的过程中，l从左往右移动，r从右往左移动。当左边的元素被挖出来了，则遍历右边，直到发现右边比基准数小的数字，填到左边。当右边的元素被挖出来了，则遍历左边，直到发现左边比基准数小的数字，填到右边。*）\n3. 再对左右区间重复第二步，直到各区间只有一个数。\n\n### 伪代码\n```\nvoid quick_sort1(int s[], int l, int r)\n{\n\tif (l < r)\n    {\n\t\tint i = AdjustArray(s, l, r);//一轮排序操作\n\t\tquick_sort1(s, l, i - 1); // 递归调用 \n\t\tquick_sort1(s, i + 1, r);\n\t}\n}\n```\n\n## 三、堆排序(复杂度O(N*logN))\n二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：\n\n1. 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。\n2. 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。\n\n根据这个特性我们知道**堆顶的元素一定是最大或者最小**。因此堆排序的步骤一般为：\n\n1. 将无序数组A[n-1]构造成一个二叉堆，然后取出堆顶与堆尾交换。\n2. 此时A[n-1]是有序的，A[0...n-2]重复步骤1。\n\n\n### 参考\n[白话经典算法系列之六 快速排序 快速搞定][1]\n\n[白话经典算法系列之五 归并排序的实现][2]\n\n[白话经典算法系列之七 堆与堆排序][3]\n\n[1]: http://blog.csdn.net/morewindows/article/details/6684558\n[2]: http://blog.csdn.net/morewindows/article/details/6678165\n[3]: http://blog.csdn.net/morewindows/article/details/6709644\n\n\n\n","source":"_posts/经典排序算法.md","raw":"---\ntitle: 经典排序算法\ncategories: 算法\ntags: 算法\ndate: 2016-11-28 17:21:09\n---\n\n\n## 一、归并排序（复杂度O(N*logN)）\n### 一轮合并操作\n1. 存在两个**有序**的数组A、B合并到一个新的数组C，并让新的数组C有序。\n2. 取出A的第一个元素与B的第一元素比较，取出小的放入数组C中。\n3. 重复步骤2，直到A、B数组至少一个为空，如果A为空，则拷贝B剩余元素到C中；B为空，则拷贝A剩余元素到C中。\n\n### 归并排序\n采用了分治的思想，递归的将需要排序的数组对半的分成两个子数组，并对这两个数组进行合并。**当被拆分的数组的元素个数小于等于1个的时候，那么这个两个子数组内部就一定是有序的，因此合并起来的数组也是有序的**。接下来就是重复以上提到的“一轮合并操作”，进行N轮的合并操作。\n### 伪代码\n```\nvoid mergesort(int a[], int first, int last, int temp[])\n{\n\tif (first < last)\n\t{\n\t\tint mid = (first + last) / 2;\n\t\tmergesort(a, first, mid, temp);    //左边有序\n\t\tmergesort(a, mid + 1, last, temp); //右边有序\n\t\tmergearray(a, first, mid, last, temp); //再将二个有序数列合并\n\t}\n}\n```\n\n## 二、快速排序(复杂度O(N*logN))\n\n### 一轮排序操作\n1. 先从数列中取出一个数作为基准数。\n2. 分区过程，将比这个数大的数全挖出来放到它的右边，小于或等于它的数挖出来放到它的左边。（*具体来说，创建两个索引l、r，遍历的过程中，l从左往右移动，r从右往左移动。当左边的元素被挖出来了，则遍历右边，直到发现右边比基准数小的数字，填到左边。当右边的元素被挖出来了，则遍历左边，直到发现左边比基准数小的数字，填到右边。*）\n3. 再对左右区间重复第二步，直到各区间只有一个数。\n\n### 伪代码\n```\nvoid quick_sort1(int s[], int l, int r)\n{\n\tif (l < r)\n    {\n\t\tint i = AdjustArray(s, l, r);//一轮排序操作\n\t\tquick_sort1(s, l, i - 1); // 递归调用 \n\t\tquick_sort1(s, i + 1, r);\n\t}\n}\n```\n\n## 三、堆排序(复杂度O(N*logN))\n二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：\n\n1. 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。\n2. 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。\n\n根据这个特性我们知道**堆顶的元素一定是最大或者最小**。因此堆排序的步骤一般为：\n\n1. 将无序数组A[n-1]构造成一个二叉堆，然后取出堆顶与堆尾交换。\n2. 此时A[n-1]是有序的，A[0...n-2]重复步骤1。\n\n\n### 参考\n[白话经典算法系列之六 快速排序 快速搞定][1]\n\n[白话经典算法系列之五 归并排序的实现][2]\n\n[白话经典算法系列之七 堆与堆排序][3]\n\n[1]: http://blog.csdn.net/morewindows/article/details/6684558\n[2]: http://blog.csdn.net/morewindows/article/details/6678165\n[3]: http://blog.csdn.net/morewindows/article/details/6709644\n\n\n\n","slug":"经典排序算法","published":1,"updated":"2017-02-10T07:43:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4o002cgivbl6w8imrs","content":"<h2 id=\"一、归并排序（复杂度O-N-logN-）\"><a href=\"#一、归并排序（复杂度O-N-logN-）\" class=\"headerlink\" title=\"一、归并排序（复杂度O(N*logN)）\"></a>一、归并排序（复杂度O(N*logN)）</h2><h3 id=\"一轮合并操作\"><a href=\"#一轮合并操作\" class=\"headerlink\" title=\"一轮合并操作\"></a>一轮合并操作</h3><ol>\n<li>存在两个<strong>有序</strong>的数组A、B合并到一个新的数组C，并让新的数组C有序。</li>\n<li>取出A的第一个元素与B的第一元素比较，取出小的放入数组C中。</li>\n<li>重复步骤2，直到A、B数组至少一个为空，如果A为空，则拷贝B剩余元素到C中；B为空，则拷贝A剩余元素到C中。</li>\n</ol>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>采用了分治的思想，递归的将需要排序的数组对半的分成两个子数组，并对这两个数组进行合并。<strong>当被拆分的数组的元素个数小于等于1个的时候，那么这个两个子数组内部就一定是有序的，因此合并起来的数组也是有序的</strong>。接下来就是重复以上提到的“一轮合并操作”，进行N轮的合并操作。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mergesort(int a[], int first, int last, int temp[])</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (first &lt; last)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tint mid = (first + last) / 2;</div><div class=\"line\">\t\tmergesort(a, first, mid, temp);    //左边有序</div><div class=\"line\">\t\tmergesort(a, mid + 1, last, temp); //右边有序</div><div class=\"line\">\t\tmergearray(a, first, mid, last, temp); //再将二个有序数列合并</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"二、快速排序-复杂度O-N-logN\"><a href=\"#二、快速排序-复杂度O-N-logN\" class=\"headerlink\" title=\"二、快速排序(复杂度O(N*logN))\"></a>二、快速排序(复杂度O(N*logN))</h2><h3 id=\"一轮排序操作\"><a href=\"#一轮排序操作\" class=\"headerlink\" title=\"一轮排序操作\"></a>一轮排序操作</h3><ol>\n<li>先从数列中取出一个数作为基准数。</li>\n<li>分区过程，将比这个数大的数全挖出来放到它的右边，小于或等于它的数挖出来放到它的左边。（<em>具体来说，创建两个索引l、r，遍历的过程中，l从左往右移动，r从右往左移动。当左边的元素被挖出来了，则遍历右边，直到发现右边比基准数小的数字，填到左边。当右边的元素被挖出来了，则遍历左边，直到发现左边比基准数小的数字，填到右边。</em>）</li>\n<li>再对左右区间重复第二步，直到各区间只有一个数。</li>\n</ol>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">void quick_sort1(int s[], int l, int r)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (l &lt; r)</div><div class=\"line\">    &#123;</div><div class=\"line\">\t\tint i = AdjustArray(s, l, r);//一轮排序操作</div><div class=\"line\">\t\tquick_sort1(s, l, i - 1); // 递归调用 </div><div class=\"line\">\t\tquick_sort1(s, i + 1, r);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"三、堆排序-复杂度O-N-logN\"><a href=\"#三、堆排序-复杂度O-N-logN\" class=\"headerlink\" title=\"三、堆排序(复杂度O(N*logN))\"></a>三、堆排序(复杂度O(N*logN))</h2><p>二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：</p>\n<ol>\n<li>父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>\n<li>每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</li>\n</ol>\n<p>根据这个特性我们知道<strong>堆顶的元素一定是最大或者最小</strong>。因此堆排序的步骤一般为：</p>\n<ol>\n<li>将无序数组A[n-1]构造成一个二叉堆，然后取出堆顶与堆尾交换。</li>\n<li>此时A[n-1]是有序的，A[0…n-2]重复步骤1。</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://blog.csdn.net/morewindows/article/details/6684558\" target=\"_blank\" rel=\"external\">白话经典算法系列之六 快速排序 快速搞定</a></p>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6678165\" target=\"_blank\" rel=\"external\">白话经典算法系列之五 归并排序的实现</a></p>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6709644\" target=\"_blank\" rel=\"external\">白话经典算法系列之七 堆与堆排序</a></p>\n","excerpt":"","more":"<h2 id=\"一、归并排序（复杂度O-N-logN-）\"><a href=\"#一、归并排序（复杂度O-N-logN-）\" class=\"headerlink\" title=\"一、归并排序（复杂度O(N*logN)）\"></a>一、归并排序（复杂度O(N*logN)）</h2><h3 id=\"一轮合并操作\"><a href=\"#一轮合并操作\" class=\"headerlink\" title=\"一轮合并操作\"></a>一轮合并操作</h3><ol>\n<li>存在两个<strong>有序</strong>的数组A、B合并到一个新的数组C，并让新的数组C有序。</li>\n<li>取出A的第一个元素与B的第一元素比较，取出小的放入数组C中。</li>\n<li>重复步骤2，直到A、B数组至少一个为空，如果A为空，则拷贝B剩余元素到C中；B为空，则拷贝A剩余元素到C中。</li>\n</ol>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>采用了分治的思想，递归的将需要排序的数组对半的分成两个子数组，并对这两个数组进行合并。<strong>当被拆分的数组的元素个数小于等于1个的时候，那么这个两个子数组内部就一定是有序的，因此合并起来的数组也是有序的</strong>。接下来就是重复以上提到的“一轮合并操作”，进行N轮的合并操作。</p>\n<h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mergesort(int a[], int first, int last, int temp[])</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (first &lt; last)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tint mid = (first + last) / 2;</div><div class=\"line\">\t\tmergesort(a, first, mid, temp);    //左边有序</div><div class=\"line\">\t\tmergesort(a, mid + 1, last, temp); //右边有序</div><div class=\"line\">\t\tmergearray(a, first, mid, last, temp); //再将二个有序数列合并</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"二、快速排序-复杂度O-N-logN\"><a href=\"#二、快速排序-复杂度O-N-logN\" class=\"headerlink\" title=\"二、快速排序(复杂度O(N*logN))\"></a>二、快速排序(复杂度O(N*logN))</h2><h3 id=\"一轮排序操作\"><a href=\"#一轮排序操作\" class=\"headerlink\" title=\"一轮排序操作\"></a>一轮排序操作</h3><ol>\n<li>先从数列中取出一个数作为基准数。</li>\n<li>分区过程，将比这个数大的数全挖出来放到它的右边，小于或等于它的数挖出来放到它的左边。（<em>具体来说，创建两个索引l、r，遍历的过程中，l从左往右移动，r从右往左移动。当左边的元素被挖出来了，则遍历右边，直到发现右边比基准数小的数字，填到左边。当右边的元素被挖出来了，则遍历左边，直到发现左边比基准数小的数字，填到右边。</em>）</li>\n<li>再对左右区间重复第二步，直到各区间只有一个数。</li>\n</ol>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">void quick_sort1(int s[], int l, int r)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif (l &lt; r)</div><div class=\"line\">    &#123;</div><div class=\"line\">\t\tint i = AdjustArray(s, l, r);//一轮排序操作</div><div class=\"line\">\t\tquick_sort1(s, l, i - 1); // 递归调用 </div><div class=\"line\">\t\tquick_sort1(s, i + 1, r);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"三、堆排序-复杂度O-N-logN\"><a href=\"#三、堆排序-复杂度O-N-logN\" class=\"headerlink\" title=\"三、堆排序(复杂度O(N*logN))\"></a>三、堆排序(复杂度O(N*logN))</h2><p>二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：</p>\n<ol>\n<li>父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>\n<li>每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</li>\n</ol>\n<p>根据这个特性我们知道<strong>堆顶的元素一定是最大或者最小</strong>。因此堆排序的步骤一般为：</p>\n<ol>\n<li>将无序数组A[n-1]构造成一个二叉堆，然后取出堆顶与堆尾交换。</li>\n<li>此时A[n-1]是有序的，A[0…n-2]重复步骤1。</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://blog.csdn.net/morewindows/article/details/6684558\">白话经典算法系列之六 快速排序 快速搞定</a></p>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6678165\">白话经典算法系列之五 归并排序的实现</a></p>\n<p><a href=\"http://blog.csdn.net/morewindows/article/details/6709644\">白话经典算法系列之七 堆与堆排序</a></p>\n"},{"title":"网络七层协议（结合操作系统来了解）","_content":"\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n  \n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n## 硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","source":"_posts/网络七层协议（结合操作系统来了解）.md","raw":"---\ntitle: 网络七层协议（结合操作系统来了解）\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记\ntags:\n - 网络\n---\n\n## 用户态\n### 第7层：应用层\n  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP\n### 第6层：表示层\n  数据的表示形式，如：加密，ASCII等\n### 第5层：会话层\n  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：\n  \n```\nstruct socket {\n    ...\n    void *so_pcb;           //协议控制块\n    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)\n    struct sockbuf {...} so_rcv; //接收队列\n                        so_send; //发送队列\n    ...\n}\n```\n\n## 内核态\n### 第4层：传输层\n  定义在该层的协议：TCP，UDP，SPX\n### 第3层：网络层\n  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)\n### 第2层：数据链路层\n  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)\n## 硬件\n### 第1层：物理层\n  硬件相关\n\n\n\n\n\n","slug":"网络七层协议（结合操作系统来了解）","published":1,"date":"2016-12-28T07:41:22.000Z","updated":"2016-12-28T07:41:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4r002ggivbhzfwpr65","content":"<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n","excerpt":"","more":"<h2 id=\"用户态\"><a href=\"#用户态\" class=\"headerlink\" title=\"用户态\"></a>用户态</h2><h3 id=\"第7层：应用层\"><a href=\"#第7层：应用层\" class=\"headerlink\" title=\"第7层：应用层\"></a>第7层：应用层</h3><p>  定义在该层的协议：TELNET，HTTP,FTP,NFS,SMTP</p>\n<h3 id=\"第6层：表示层\"><a href=\"#第6层：表示层\" class=\"headerlink\" title=\"第6层：表示层\"></a>第6层：表示层</h3><p>  数据的表示形式，如：加密，ASCII等</p>\n<h3 id=\"第5层：会话层\"><a href=\"#第5层：会话层\" class=\"headerlink\" title=\"第5层：会话层\"></a>第5层：会话层</h3><p>  Sockets,socket其实就是一个数据结构，里面包含协议的指针、协议块指针、数据收发的缓冲区等，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct socket &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    void *so_pcb;           //协议控制块</div><div class=\"line\">    struct protosw *so_proto;  //协议指针，如：PF_INET（ipv4套接字）、PF_SYSTEM(本地系统通信套接字)</div><div class=\"line\">    struct sockbuf &#123;...&#125; so_rcv; //接收队列</div><div class=\"line\">                        so_send; //发送队列</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"内核态\"><a href=\"#内核态\" class=\"headerlink\" title=\"内核态\"></a>内核态</h2><h3 id=\"第4层：传输层\"><a href=\"#第4层：传输层\" class=\"headerlink\" title=\"第4层：传输层\"></a>第4层：传输层</h3><p>  定义在该层的协议：TCP，UDP，SPX</p>\n<h3 id=\"第3层：网络层\"><a href=\"#第3层：网络层\" class=\"headerlink\" title=\"第3层：网络层\"></a>第3层：网络层</h3><p>  定义在该层的协议：IP,IPX等。(第3层隧道协议：IPSec、GRE等)</p>\n<h3 id=\"第2层：数据链路层\"><a href=\"#第2层：数据链路层\" class=\"headerlink\" title=\"第2层：数据链路层\"></a>第2层：数据链路层</h3><p>  它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI，MAC等。(第2层隧道协议：PPTP、L2F、L2TP)</p>\n<h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><h3 id=\"第1层：物理层\"><a href=\"#第1层：物理层\" class=\"headerlink\" title=\"第1层：物理层\"></a>第1层：物理层</h3><p>  硬件相关</p>\n"},{"title":"苹果文字系统","date":"2016-11-15T02:33:17.000Z","description":"首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示...","_content":"\n\n## 整体架构\n![文字系统架构][1]\n\n## 文字排版知识\n - 首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：\n![两个字符对应一个字形的例子][8]\n\n- 字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由`NSLayoutManager`来管理的。\n\n- 字形矩阵\n![字形矩阵][9]\n\n- 字距调整\n![kernig][10]\n\n- 一行文字\n![字形][6]\n由上图可见：\n\n- 一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。\n- LineHeight = Ascent + Descent + lineGap\n\n## Text Kit\n\n基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：\n![Text Kit所处位置][11]\n\n### Text Kit中的主要对象\n\n![Text Kit中的主要对象][12]\n\n- **Text container**: 通常是`NSTextContainer`对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。\n\n- **Layout manager**:通常是`NSLayoutManager`对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。\n  - 将字符跟字形进行映射。\n  - 根据NSTextContainer定义的区域来排版字形。\n\n- **Text storage**通常是`NSTextStorage`对象或者其子对象，`NSTextStorage`是`NSMutableAttributedString`的子对象，其包含多个`NSLayoutManager`，当有变动的时候，通知`NSLayoutManager`刷新\n\n- **对应关系**： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。\n\n## 直接绘制文字\n\n### NSString的UIStringDrawing category\n可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。\n\n### CATextLayer\nCATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。\n\n### Core Text\n- 通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。\n\n- Core Text框架综合了Core Foundation以及Core Graphics。\n\n- Core Text包含两个重要的部分：layout engine以及font technology。\n\n#### Layout engine\nCore Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：`CTFramesetterRef`、`CTFrameRef`、`CTTypesetterRef`、`CTLineRef`、`CTRunRef`这几个对象。如下图所示：\n\n![][14]\n\n- CTFramesetterRef\n- CTFrameRef\n- CTTypesetterRef\n- CTLineRef\n- CTRunRef\n\n#### Core Text Font Opaque Types\n通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。\n\n- CTFontRef：对应UIFont\n- CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef\n- CTFontCollectionRef：\n\n## 自定义可与键盘交互的Text View\n最重要的是要实现UIKeyInput协议。可参考apple[官方文档][13]的Simple Text Input章节以及[Custom Views for Data Input][7]。涉及到的对象或协议有：\n\n- UIKeyInput\n- UITextInput\n- UITextPosition\n- UITextRange\n- UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举`UITextGranularity`值来表示。默认的分词器是：`UITextInputStringTokenizer`。\n\n\n## 参考文档：\n[Typographical Concepts][2]\n[Text Attributes][3]\n[Introduction to Text Layout Programming Guide][4]\n[Introduction to Text System Storage Layer Overview][5]\n[Custom Views for Data Input][7]\n[Lower Level Text-Handling Technologies][13]\n\n---\n[1]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\n[2]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\n[3]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\n[4]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\n[5]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\n[6]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\n[7]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\n[8]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\n[9]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\n[10]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\n[11]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\n[12]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\n[13]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\n[14]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\n","source":"_posts/苹果的文字系统.md","raw":"---\ntitle: 苹果文字系统\ncategories: iOS开发笔记\ntags: CoreText\ndate: 2016-11-15 10:33:17\ndescription: \"首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示...\"\n---\n\n\n## 整体架构\n![文字系统架构][1]\n\n## 文字排版知识\n - 首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：\n![两个字符对应一个字形的例子][8]\n\n- 字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由`NSLayoutManager`来管理的。\n\n- 字形矩阵\n![字形矩阵][9]\n\n- 字距调整\n![kernig][10]\n\n- 一行文字\n![字形][6]\n由上图可见：\n\n- 一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。\n- LineHeight = Ascent + Descent + lineGap\n\n## Text Kit\n\n基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：\n![Text Kit所处位置][11]\n\n### Text Kit中的主要对象\n\n![Text Kit中的主要对象][12]\n\n- **Text container**: 通常是`NSTextContainer`对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。\n\n- **Layout manager**:通常是`NSLayoutManager`对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。\n  - 将字符跟字形进行映射。\n  - 根据NSTextContainer定义的区域来排版字形。\n\n- **Text storage**通常是`NSTextStorage`对象或者其子对象，`NSTextStorage`是`NSMutableAttributedString`的子对象，其包含多个`NSLayoutManager`，当有变动的时候，通知`NSLayoutManager`刷新\n\n- **对应关系**： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。\n\n## 直接绘制文字\n\n### NSString的UIStringDrawing category\n可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。\n\n### CATextLayer\nCATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。\n\n### Core Text\n- 通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。\n\n- Core Text框架综合了Core Foundation以及Core Graphics。\n\n- Core Text包含两个重要的部分：layout engine以及font technology。\n\n#### Layout engine\nCore Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：`CTFramesetterRef`、`CTFrameRef`、`CTTypesetterRef`、`CTLineRef`、`CTRunRef`这几个对象。如下图所示：\n\n![][14]\n\n- CTFramesetterRef\n- CTFrameRef\n- CTTypesetterRef\n- CTLineRef\n- CTRunRef\n\n#### Core Text Font Opaque Types\n通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。\n\n- CTFontRef：对应UIFont\n- CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef\n- CTFontCollectionRef：\n\n## 自定义可与键盘交互的Text View\n最重要的是要实现UIKeyInput协议。可参考apple[官方文档][13]的Simple Text Input章节以及[Custom Views for Data Input][7]。涉及到的对象或协议有：\n\n- UIKeyInput\n- UITextInput\n- UITextPosition\n- UITextRange\n- UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举`UITextGranularity`值来表示。默认的分词器是：`UITextInputStringTokenizer`。\n\n\n## 参考文档：\n[Typographical Concepts][2]\n[Text Attributes][3]\n[Introduction to Text Layout Programming Guide][4]\n[Introduction to Text System Storage Layer Overview][5]\n[Custom Views for Data Input][7]\n[Lower Level Text-Handling Technologies][13]\n\n---\n[1]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\n[2]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\n[3]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\n[4]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\n[5]: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\n[6]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\n[7]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\n[8]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\n[9]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\n[10]: https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\n[11]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\n[12]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\n[13]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\n[14]: https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\n","slug":"苹果的文字系统","published":1,"updated":"2016-11-15T09:16:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4s002kgivbshquxynk","content":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\" alt=\"文字系统架构\"></p>\n<h2 id=\"文字排版知识\"><a href=\"#文字排版知识\" class=\"headerlink\" title=\"文字排版知识\"></a>文字排版知识</h2><ul>\n<li>首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\" alt=\"两个字符对应一个字形的例子\"></li>\n</ul>\n<ul>\n<li><p>字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由<code>NSLayoutManager</code>来管理的。</p>\n</li>\n<li><p>字形矩阵<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\" alt=\"字形矩阵\"></p>\n</li>\n<li><p>字距调整<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\" alt=\"kernig\"></p>\n</li>\n<li><p>一行文字<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\" alt=\"字形\"><br>由上图可见：</p>\n</li>\n<li><p>一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。</p>\n</li>\n<li>LineHeight = Ascent + Descent + lineGap</li>\n</ul>\n<h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p>基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\" alt=\"Text Kit所处位置\"></p>\n<h3 id=\"Text-Kit中的主要对象\"><a href=\"#Text-Kit中的主要对象\" class=\"headerlink\" title=\"Text Kit中的主要对象\"></a>Text Kit中的主要对象</h3><p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\" alt=\"Text Kit中的主要对象\"></p>\n<ul>\n<li><p><strong>Text container</strong>: 通常是<code>NSTextContainer</code>对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。</p>\n</li>\n<li><p><strong>Layout manager</strong>:通常是<code>NSLayoutManager</code>对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。</p>\n<ul>\n<li>将字符跟字形进行映射。</li>\n<li>根据NSTextContainer定义的区域来排版字形。</li>\n</ul>\n</li>\n<li><p><strong>Text storage</strong>通常是<code>NSTextStorage</code>对象或者其子对象，<code>NSTextStorage</code>是<code>NSMutableAttributedString</code>的子对象，其包含多个<code>NSLayoutManager</code>，当有变动的时候，通知<code>NSLayoutManager</code>刷新</p>\n</li>\n<li><p><strong>对应关系</strong>： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。</p>\n</li>\n</ul>\n<h2 id=\"直接绘制文字\"><a href=\"#直接绘制文字\" class=\"headerlink\" title=\"直接绘制文字\"></a>直接绘制文字</h2><h3 id=\"NSString的UIStringDrawing-category\"><a href=\"#NSString的UIStringDrawing-category\" class=\"headerlink\" title=\"NSString的UIStringDrawing category\"></a>NSString的UIStringDrawing category</h3><p>可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。</p>\n<h3 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h3><p>CATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。</p>\n<h3 id=\"Core-Text\"><a href=\"#Core-Text\" class=\"headerlink\" title=\"Core Text\"></a>Core Text</h3><ul>\n<li><p>通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。</p>\n</li>\n<li><p>Core Text框架综合了Core Foundation以及Core Graphics。</p>\n</li>\n<li><p>Core Text包含两个重要的部分：layout engine以及font technology。</p>\n</li>\n</ul>\n<h4 id=\"Layout-engine\"><a href=\"#Layout-engine\" class=\"headerlink\" title=\"Layout engine\"></a>Layout engine</h4><p>Core Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：<code>CTFramesetterRef</code>、<code>CTFrameRef</code>、<code>CTTypesetterRef</code>、<code>CTLineRef</code>、<code>CTRunRef</code>这几个对象。如下图所示：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\" alt=\"\"></p>\n<ul>\n<li>CTFramesetterRef</li>\n<li>CTFrameRef</li>\n<li>CTTypesetterRef</li>\n<li>CTLineRef</li>\n<li>CTRunRef</li>\n</ul>\n<h4 id=\"Core-Text-Font-Opaque-Types\"><a href=\"#Core-Text-Font-Opaque-Types\" class=\"headerlink\" title=\"Core Text Font Opaque Types\"></a>Core Text Font Opaque Types</h4><p>通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。</p>\n<ul>\n<li>CTFontRef：对应UIFont</li>\n<li>CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef</li>\n<li>CTFontCollectionRef：</li>\n</ul>\n<h2 id=\"自定义可与键盘交互的Text-View\"><a href=\"#自定义可与键盘交互的Text-View\" class=\"headerlink\" title=\"自定义可与键盘交互的Text View\"></a>自定义可与键盘交互的Text View</h2><p>最重要的是要实现UIKeyInput协议。可参考apple<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\" target=\"_blank\" rel=\"external\">官方文档</a>的Simple Text Input章节以及<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\" target=\"_blank\" rel=\"external\">Custom Views for Data Input</a>。涉及到的对象或协议有：</p>\n<ul>\n<li>UIKeyInput</li>\n<li>UITextInput</li>\n<li>UITextPosition</li>\n<li>UITextRange</li>\n<li>UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举<code>UITextGranularity</code>值来表示。默认的分词器是：<code>UITextInputStringTokenizer</code>。</li>\n</ul>\n<h2 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h2><p><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\" target=\"_blank\" rel=\"external\">Typographical Concepts</a><br><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\" target=\"_blank\" rel=\"external\">Text Attributes</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\" target=\"_blank\" rel=\"external\">Introduction to Text Layout Programming Guide</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\" target=\"_blank\" rel=\"external\">Introduction to Text System Storage Layer Overview</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\" target=\"_blank\" rel=\"external\">Custom Views for Data Input</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\" target=\"_blank\" rel=\"external\">Lower Level Text-Handling Technologies</a></p>\n<hr>\n","excerpt":"","more":"<h2 id=\"整体架构\"><a href=\"#整体架构\" class=\"headerlink\" title=\"整体架构\"></a>整体架构</h2><p><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/text_system_architecture_2x.png\" alt=\"文字系统架构\"></p>\n<h2 id=\"文字排版知识\"><a href=\"#文字排版知识\" class=\"headerlink\" title=\"文字排版知识\"></a>文字排版知识</h2><ul>\n<li>首先我们需要知道的是字符（character）跟字形（glyphs）是有区别的。字符使我们用来交流的，可以通过说话、或者书写来传递，而字形则是字符被展示出来的形态，比如大小写、宋体的样式等。字符跟字形不是一一对应的，有的时候，一个字符可以由多个字形组成。有时候，多个字符可以用一个字形来表示。比如：<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/romanligatures_2x.png\" alt=\"两个字符对应一个字形的例子\"></li>\n</ul>\n<ul>\n<li><p>字符有字符编码（比如：Unicode）,字形也有字形的编码。它们之间的转换是由<code>NSLayoutManager</code>来管理的。</p>\n</li>\n<li><p>字形矩阵<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyphterms_2x.png\" alt=\"字形矩阵\"></p>\n</li>\n<li><p>字距调整<br><img src=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/kerning_2x.png\" alt=\"kernig\"></p>\n</li>\n<li><p>一行文字<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textpg_intro_2x.png\" alt=\"字形\"><br>由上图可见：</p>\n</li>\n<li><p>一行字除去行间距之外，大致会分成上中下三个部分，中间部分是所有字符（character）都会暂用的的部分，上下两部分依字符而定。</p>\n</li>\n<li>LineHeight = Ascent + Descent + lineGap</li>\n</ul>\n<h2 id=\"Text-Kit\"><a href=\"#Text-Kit\" class=\"headerlink\" title=\"Text Kit\"></a>Text Kit</h2><p>基于Core Text实现，所以它的性能跟Core Text差不多。Text Kit框架所处位置如下：<br><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/text_kit_arch_2x.png\" alt=\"Text Kit所处位置\"></p>\n<h3 id=\"Text-Kit中的主要对象\"><a href=\"#Text-Kit中的主要对象\" class=\"headerlink\" title=\"Text Kit中的主要对象\"></a>Text Kit中的主要对象</h3><p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/textkitarchitecture_2x.png\" alt=\"Text Kit中的主要对象\"></p>\n<ul>\n<li><p><strong>Text container</strong>: 通常是<code>NSTextContainer</code>对象或者其子对象，定义文字布局的区域区域，可以使矩形、圆形、也可以结合Bezier paths来设置不需要绘制的区域等。</p>\n</li>\n<li><p><strong>Layout manager</strong>:通常是<code>NSLayoutManager</code>对象或者其子对象，TextView、NSTextContainer、NSTextStorage之间的桥梁。</p>\n<ul>\n<li>将字符跟字形进行映射。</li>\n<li>根据NSTextContainer定义的区域来排版字形。</li>\n</ul>\n</li>\n<li><p><strong>Text storage</strong>通常是<code>NSTextStorage</code>对象或者其子对象，<code>NSTextStorage</code>是<code>NSMutableAttributedString</code>的子对象，其包含多个<code>NSLayoutManager</code>，当有变动的时候，通知<code>NSLayoutManager</code>刷新</p>\n</li>\n<li><p><strong>对应关系</strong>： 一个NSTextStorage对应一个NSLayoutManager，对应N个NSTextContainer。</p>\n</li>\n</ul>\n<h2 id=\"直接绘制文字\"><a href=\"#直接绘制文字\" class=\"headerlink\" title=\"直接绘制文字\"></a>直接绘制文字</h2><h3 id=\"NSString的UIStringDrawing-category\"><a href=\"#NSString的UIStringDrawing-category\" class=\"headerlink\" title=\"NSString的UIStringDrawing category\"></a>NSString的UIStringDrawing category</h3><p>可以通过设置字体、换行模式、baseline调整的参数在指定位置绘制文字，并且可以通过attributeString在不同的区域绘制不一样的样式。</p>\n<h3 id=\"CATextLayer\"><a href=\"#CATextLayer\" class=\"headerlink\" title=\"CATextLayer\"></a>CATextLayer</h3><p>CATextLayer可以通过将string或者attributed string设置成它的content来完成文字的绘制。它的优势在于它是是CALayer的的子类，它知道在何时如何绘制文字，不需要自己显示得编写绘制的代码。</p>\n<h3 id=\"Core-Text\"><a href=\"#Core-Text\" class=\"headerlink\" title=\"Core Text\"></a>Core Text</h3><ul>\n<li><p>通常我们可以使用Text Kit来满足的我们对文字展示的的需求，因为Text Kit是对Core Text封装，拥有跟Core Text一样的性能优势。当需要自定义自己的布局引擎的时候可以使用Core Text，比如，要开发一个文字处理器等。</p>\n</li>\n<li><p>Core Text框架综合了Core Foundation以及Core Graphics。</p>\n</li>\n<li><p>Core Text包含两个重要的部分：layout engine以及font technology。</p>\n</li>\n</ul>\n<h4 id=\"Layout-engine\"><a href=\"#Layout-engine\" class=\"headerlink\" title=\"Layout engine\"></a>Layout engine</h4><p>Core Text接收两个参数：CFAttributedStringRef(定义了字体、颜色的属性)和CGPathRef（定义了文字绘制的区域的形状、大小）。通常布局引擎会包含：<code>CTFramesetterRef</code>、<code>CTFrameRef</code>、<code>CTTypesetterRef</code>、<code>CTLineRef</code>、<code>CTRunRef</code>这几个对象。如下图所示：</p>\n<p><img src=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Art/core_text_arch_2x.png\" alt=\"\"></p>\n<ul>\n<li>CTFramesetterRef</li>\n<li>CTFrameRef</li>\n<li>CTTypesetterRef</li>\n<li>CTLineRef</li>\n<li>CTRunRef</li>\n</ul>\n<h4 id=\"Core-Text-Font-Opaque-Types\"><a href=\"#Core-Text-Font-Opaque-Types\" class=\"headerlink\" title=\"Core Text Font Opaque Types\"></a>Core Text Font Opaque Types</h4><p>通常我们可以在graphics context设置字体，或者可以通过attributed string创建CTLine，并用CTLine的绘制方法来绘制文字。</p>\n<ul>\n<li>CTFontRef：对应UIFont</li>\n<li>CTFontDescriptorRef：可以设置字体样式、字体名称，用来创建CTFontRef</li>\n<li>CTFontCollectionRef：</li>\n</ul>\n<h2 id=\"自定义可与键盘交互的Text-View\"><a href=\"#自定义可与键盘交互的Text-View\" class=\"headerlink\" title=\"自定义可与键盘交互的Text View\"></a>自定义可与键盘交互的Text View</h2><p>最重要的是要实现UIKeyInput协议。可参考apple<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\">官方文档</a>的Simple Text Input章节以及<a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\">Custom Views for Data Input</a>。涉及到的对象或协议有：</p>\n<ul>\n<li>UIKeyInput</li>\n<li>UITextInput</li>\n<li>UITextPosition</li>\n<li>UITextRange</li>\n<li>UITextInputTokenizer: 分词器协议，即用来判断某个位置是否在某个粒度文本内（可以使字符、单词、句子、段落、行、文档等）。这段文字粒度通常采用枚举<code>UITextGranularity</code>值来表示。默认的分词器是：<code>UITextInputStringTokenizer</code>。</li>\n</ul>\n<h2 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h2><p><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TypoFeatures/TextSystemFeatures.html#//apple_ref/doc/uid/TP40009459-CH6-BBCFAEGE\">Typographical Concepts</a><br><a href=\"https://developer.apple.com/library/content/documentation/TextFonts/Conceptual/CocoaTextArchitecture/TextAttributes/AboutTextAttributes.html#//apple_ref/doc/uid/TP40009459-CH10-BBCFEBHA\">Text Attributes</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextLayout/TextLayout.html#//apple_ref/doc/uid/10000158i\">Introduction to Text Layout Programming Guide</a><br><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/TextStorageLayer/TextStorageLayer.html#//apple_ref/doc/uid/10000087i\">Introduction to Text System Storage Layer Overview</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW1\">Custom Views for Data Input</a><br><a href=\"https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/LowerLevelText-HandlingTechnologies/LowerLevelText-HandlingTechnologies.html#//apple_ref/doc/uid/TP40009542-CH15-SW1\">Lower Level Text-Handling Technologies</a></p>\n<hr>\n"},{"title":"贯穿始终-launchd","description":"launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的...","_content":"\n## launchd\nlaunchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。\nlaunchd分为两种类型的后台作业：\n\n- **守护程序**（daemon），不可和用户交互。\n- **代理程序**（agent），特殊的守护程序，可以和用户交互。\n\n## launchd的职责\n\n### 运行定时作业\n指定时间运行指定的命令。\n\n### 启动网络服务\n绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。\n\n### 提供自举服务<servers/bootstrap.h>\n- launchd在启动的时候声明一个端口（**bootstrap_port**）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个**bootstrap_port**来访问自举服务器来查询某个服务，并且匹配服务程序的端口。\n- 如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数`bootstrap_check_in()`来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。\n\n### 事物支持\n`vproc_transaction_begi`n和`vproc_transaction_end`之间的操作称为**未决事物**，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。\n\n### 资源限制和遏制\niOS Jetsam机制，可以强制施行虚拟内存使用率限制。\n\n### Autorun模拟和文件系统观察\n- launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。\n- 通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。\n\n### 整合了I/O Kit\n\n## iOS的launchDeamon\niOS包含的launchDeamon列表如下图所示：\n![launchDeamon][1]\n\n**其中最重要的两个守护进程是lockdownd和SpringBoard**\n\n### lockdownd\nlockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。\n\n### SpringBoard\n- 创建GUI\n- 处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。\n- SpringBoard包含大量的线程，比如：\n\t- 有Web相关的线程（WebCore和WebThread）\n\t- WiFiManager\n\t- CoreAnimation\n- SpringBoard通过launchd注册了很多Mach端口，其中最重要的是`PurpleSystemEventPort`，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。\n\n## XPC\n- XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：\n\n```\nxpc_connection_send_message\n(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.\n```\n```\nxpc_connection_send_barrier\n(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.\n```\n```\nxpc_connection_send_message_with_reply\n(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.\n```\n```\nxpc_object_t\nxpc_connection_send_message_with_reply_sync\n(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value\n```\n- XPC的例子可以参照：苹果官方的[SandboxedFetch][2]\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\n[2]: https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/贯穿始终-launchd.md","raw":"---\ntitle: 贯穿始终-launchd\ndescription: \"launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的...\"\ncategories: \n - Apple Development\n - 深入解析Mac OS X && iOS操作系统笔记 \ntags:\n - launchd \n \n---\n\n## launchd\nlaunchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。\nlaunchd分为两种类型的后台作业：\n\n- **守护程序**（daemon），不可和用户交互。\n- **代理程序**（agent），特殊的守护程序，可以和用户交互。\n\n## launchd的职责\n\n### 运行定时作业\n指定时间运行指定的命令。\n\n### 启动网络服务\n绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。\n\n### 提供自举服务<servers/bootstrap.h>\n- launchd在启动的时候声明一个端口（**bootstrap_port**）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个**bootstrap_port**来访问自举服务器来查询某个服务，并且匹配服务程序的端口。\n- 如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数`bootstrap_check_in()`来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。\n\n### 事物支持\n`vproc_transaction_begi`n和`vproc_transaction_end`之间的操作称为**未决事物**，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。\n\n### 资源限制和遏制\niOS Jetsam机制，可以强制施行虚拟内存使用率限制。\n\n### Autorun模拟和文件系统观察\n- launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。\n- 通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。\n\n### 整合了I/O Kit\n\n## iOS的launchDeamon\niOS包含的launchDeamon列表如下图所示：\n![launchDeamon][1]\n\n**其中最重要的两个守护进程是lockdownd和SpringBoard**\n\n### lockdownd\nlockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。\n\n### SpringBoard\n- 创建GUI\n- 处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。\n- SpringBoard包含大量的线程，比如：\n\t- 有Web相关的线程（WebCore和WebThread）\n\t- WiFiManager\n\t- CoreAnimation\n- SpringBoard通过launchd注册了很多Mach端口，其中最重要的是`PurpleSystemEventPort`，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。\n\n## XPC\n- XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：\n\n```\nxpc_connection_send_message\n(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.\n```\n```\nxpc_connection_send_barrier\n(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.\n```\n```\nxpc_connection_send_message_with_reply\n(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.\n```\n```\nxpc_object_t\nxpc_connection_send_message_with_reply_sync\n(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value\n```\n- XPC的例子可以参照：苹果官方的[SandboxedFetch][2]\n\n\n---\n[1]: https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\n[2]: https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"贯穿始终-launchd","published":1,"date":"2016-11-15T09:28:22.000Z","updated":"2016-11-15T09:28:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4t002ogivbpawtqwgk","content":"<h2 id=\"launchd\"><a href=\"#launchd\" class=\"headerlink\" title=\"launchd\"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>\n<ul>\n<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>\n<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>\n</ul>\n<h2 id=\"launchd的职责\"><a href=\"#launchd的职责\" class=\"headerlink\" title=\"launchd的职责\"></a>launchd的职责</h2><h3 id=\"运行定时作业\"><a href=\"#运行定时作业\" class=\"headerlink\" title=\"运行定时作业\"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>\n<h3 id=\"提供自举服务\"><a href=\"#提供自举服务\" class=\"headerlink\" title=\"提供自举服务\"></a>提供自举服务<servers bootstrap.h=\"\"></servers></h3><ul>\n<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>\n<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers bootstrap.h=\"\">中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</servers></li>\n</ul>\n<h3 id=\"事物支持\"><a href=\"#事物支持\" class=\"headerlink\" title=\"事物支持\"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>\n<h3 id=\"资源限制和遏制\"><a href=\"#资源限制和遏制\" class=\"headerlink\" title=\"资源限制和遏制\"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>\n<h3 id=\"Autorun模拟和文件系统观察\"><a href=\"#Autorun模拟和文件系统观察\" class=\"headerlink\" title=\"Autorun模拟和文件系统观察\"></a>Autorun模拟和文件系统观察</h3><ul>\n<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>\n<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>\n</ul>\n<h3 id=\"整合了I-O-Kit\"><a href=\"#整合了I-O-Kit\" class=\"headerlink\" title=\"整合了I/O Kit\"></a>整合了I/O Kit</h3><h2 id=\"iOS的launchDeamon\"><a href=\"#iOS的launchDeamon\" class=\"headerlink\" title=\"iOS的launchDeamon\"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\" alt=\"launchDeamon\"></p>\n<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>\n<h3 id=\"lockdownd\"><a href=\"#lockdownd\" class=\"headerlink\" title=\"lockdownd\"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>\n<h3 id=\"SpringBoard\"><a href=\"#SpringBoard\" class=\"headerlink\" title=\"SpringBoard\"></a>SpringBoard</h3><ul>\n<li>创建GUI</li>\n<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>\n<li>SpringBoard包含大量的线程，比如：<ul>\n<li>有Web相关的线程（WebCore和WebThread）</li>\n<li>WiFiManager</li>\n<li>CoreAnimation</li>\n</ul>\n</li>\n<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>\n</ul>\n<h2 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h2><ul>\n<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_barrier</div><div class=\"line\">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message_with_reply</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_object_t</div><div class=\"line\">xpc_connection_send_message_with_reply_sync</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>\n<ul>\n<li>XPC的例子可以参照：苹果官方的<a href=\"https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\" target=\"_blank\" rel=\"external\">SandboxedFetch</a></li>\n</ul>\n<hr>\n","excerpt":"","more":"<h2 id=\"launchd\"><a href=\"#launchd\" class=\"headerlink\" title=\"launchd\"></a>launchd</h2><p>launchd（PID 1）有内核直接启动，是用户态的第一个进程，其他进程都是由它直接或者间接的启动的。其他的launchd（比如其他用户远程登录后会对应创建一个launchd）都是由launchd（PID 1）启动的。<br>launchd分为两种类型的后台作业：</p>\n<ul>\n<li><strong>守护程序</strong>（daemon），不可和用户交互。</li>\n<li><strong>代理程序</strong>（agent），特殊的守护程序，可以和用户交互。</li>\n</ul>\n<h2 id=\"launchd的职责\"><a href=\"#launchd的职责\" class=\"headerlink\" title=\"launchd的职责\"></a>launchd的职责</h2><h3 id=\"运行定时作业\"><a href=\"#运行定时作业\" class=\"headerlink\" title=\"运行定时作业\"></a>运行定时作业</h3><p>指定时间运行指定的命令。</p>\n<h3 id=\"启动网络服务\"><a href=\"#启动网络服务\" class=\"headerlink\" title=\"启动网络服务\"></a>启动网络服务</h3><p>绑定一些端口（UDP端口或TCP端口），当网络请求到达的时候，根据需要启动相应的服务程序，并将服务程序的输入输出描述符（stdin、stderr和stdout）连接到对应的套接字。这样可以降低系统的负载。</p>\n<h3 id=\"提供自举服务\"><a href=\"#提供自举服务\" class=\"headerlink\" title=\"提供自举服务\"></a>提供自举服务<servers/bootstrap.h></h3><ul>\n<li>launchd在启动的时候声明一个端口（<strong>bootstrap_port</strong>）,由于所有进程都是launchd的后代，所以所有进程都可以通过这个<strong>bootstrap_port</strong>来访问自举服务器来查询某个服务，并且匹配服务程序的端口。</li>\n<li>如果想要在自举服务器中注册自己端口的服务程序也可以通过<servers/bootstrap.h>中定义的函数<code>bootstrap_check_in()</code>来实现。还可以通过服务程序自己的plist文件来向launcchd注册（可以想象一下Android的Serverice）。</li>\n</ul>\n<h3 id=\"事物支持\"><a href=\"#事物支持\" class=\"headerlink\" title=\"事物支持\"></a>事物支持</h3><p><code>vproc_transaction_begi</code>n和<code>vproc_transaction_end</code>之间的操作称为<strong>未决事物</strong>，当一个launchd有未决事物的时候会在系统关闭、用户退出，或超时被优雅的杀掉，否则强制杀掉。</p>\n<h3 id=\"资源限制和遏制\"><a href=\"#资源限制和遏制\" class=\"headerlink\" title=\"资源限制和遏制\"></a>资源限制和遏制</h3><p>iOS Jetsam机制，可以强制施行虚拟内存使用率限制。</p>\n<h3 id=\"Autorun模拟和文件系统观察\"><a href=\"#Autorun模拟和文件系统观察\" class=\"headerlink\" title=\"Autorun模拟和文件系统观察\"></a>Autorun模拟和文件系统观察</h3><ul>\n<li>launchd提供了startOnMount键，当一个文件系统挂载的时候会自动触发一个守护进程。</li>\n<li>通过WatchPaths或QueueDirectories键，launchd还可以设置一个观察路径，不一定要求是挂载点。</li>\n</ul>\n<h3 id=\"整合了I-O-Kit\"><a href=\"#整合了I-O-Kit\" class=\"headerlink\" title=\"整合了I/O Kit\"></a>整合了I/O Kit</h3><h2 id=\"iOS的launchDeamon\"><a href=\"#iOS的launchDeamon\" class=\"headerlink\" title=\"iOS的launchDeamon\"></a>iOS的launchDeamon</h2><p>iOS包含的launchDeamon列表如下图所示：<br><img src=\"https://github.com/Easence/EADocuments/blob/master/Reading%20Notes/深入解析Mac%20OS%20X%20&amp;%20iOS操作系统/Resources/Images/iOSLaunchDeamon.png?raw=true\" alt=\"launchDeamon\"></p>\n<p><strong>其中最重要的两个守护进程是lockdownd和SpringBoard</strong></p>\n<h3 id=\"lockdownd\"><a href=\"#lockdownd\" class=\"headerlink\" title=\"lockdownd\"></a>lockdownd</h3><p>lockdownd有launchd启动，它负责处理设备激活、备份、崩溃报告、设备同步以及其他的服务。</p>\n<h3 id=\"SpringBoard\"><a href=\"#SpringBoard\" class=\"headerlink\" title=\"SpringBoard\"></a>SpringBoard</h3><ul>\n<li>创建GUI</li>\n<li>处理UI，如果SpringBoard停止了所有UI事件都无法到达相应的应用，只有SpingBoard恢复执行的时候，才会将所有排队的UI事件投递到应用程序。</li>\n<li>SpringBoard包含大量的线程，比如：<ul>\n<li>有Web相关的线程（WebCore和WebThread）</li>\n<li>WiFiManager</li>\n<li>CoreAnimation</li>\n</ul>\n</li>\n<li>SpringBoard通过launchd注册了很多Mach端口，其中最重要的是<code>PurpleSystemEventPort</code>，这个端口通过GSEvent消息的方式处理UI事件。SPringBoard的主线程调用GSEventRun(),GSEventRun()是一个处理UI消息的CFRunloop。</li>\n</ul>\n<h2 id=\"XPC\"><a href=\"#XPC\" class=\"headerlink\" title=\"XPC\"></a>XPC</h2><ul>\n<li>XPC是Lion和iOS5以后引入的轻量级的进程间通信原语。XPC和GCD紧密结合在一起。XPC依赖两个私有的框架：XPCService和XPCObjects。前者负责处理XPC服务运行时相关的事务，后者为XPC对象提供编码和解码服务。iOS还包含一个私有框架：XPCKit。常用函数有：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message asynchronously on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_barrier</div><div class=\"line\">(xpc_connection_t connection, dispatch_block_t barrier); //Execute barrier block after last message is sent on connection.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_connection_send_message_with_reply</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler); //Send message, but also asynchronously execute handler in dispatch queue replyq when a reply is received.</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">xpc_object_t</div><div class=\"line\">xpc_connection_send_message_with_reply_sync</div><div class=\"line\">(xpc_connection_t connection, xpc_object_t message); //Send message, blocking until a reply is received, and return reply as the xpc_ object_t return value</div></pre></td></tr></table></figure>\n<ul>\n<li>XPC的例子可以参照：苹果官方的<a href=\"https://developer.apple.com/library/mac/samplecode/SandboxedFetch/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011117-Intro-DontLinkElementID_2\">SandboxedFetch</a></li>\n</ul>\n<hr>\n"},{"title":"读书笔记之《如何阅读一本书》","description":"阅读的四个层次：基础阅读、检视阅读、分析阅读、主题阅读...","_content":"\n## 阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n## 基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n## 检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","source":"_posts/读书笔记之《如何阅读一本书》.md","raw":"---\ntitle: 读书笔记之《如何阅读一本书》\ndescription: \"阅读的四个层次：基础阅读、检视阅读、分析阅读、主题阅读...\"\ncategories: \n - 方法论\ntags:\n - 学习方法\n---\n\n## 阅读的四个层次\n- 基础阅读\n- 检视阅读\n- 分析阅读\n- 主题阅读\n\n## 基础阅读（四个阶段）\n- 准备阶段\n身体素质方面的准备、包括视力、听力、口齿等方面。\n- 简单识字\n- 用已有的词汇揭示不懂的词汇\n- 明白主题思想\n\n## 检视阅读（如何做）\n- 先看书名\n- 研究目录(包括副标题、纲要等)\n- 如附有索引，简单阅读一下（了解概念性的词汇）\n- 读出版者的介绍（包括前言、序等）\n- 打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）\n- 粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。\n> 检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。\n\n## 阅读过程中尝试提出问题并回答，比如：回答下面几个问题\n- 整体来说，这本书谈什么？\n- 作者细说了什么、怎么说的？\n- 这本说有道理吗？\n- 这本书和你有什么关系？\n\n## 如何让你本书成为你自己的\n- 画重点\n- 标星号，不要过多，要是重中之重。\n- 标序号\n- 在空白处记下关联内容的页码\n- 做笔记\n\n## 书的分类\n- 理论型\n告诉你这是什么\n1. 哲学类（日常、例行、正常的生活经验总结出来的）\n2. 科学类(超乎日常、例行、正常的生活经验，如实验室做实验)\n- 实用型\n告诉你怎么去做\n\n## 分析阅读\n- 将书本分类\n- 一句话总结书在干什么\n- 列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。\n- 发现作者的意图\n\n\n\n\n\n\n\n\n","slug":"读书笔记之《如何阅读一本书》","published":1,"date":"2016-11-15T09:29:36.000Z","updated":"2016-11-15T09:29:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4u002rgivbo85p9p5y","content":"<h2 id=\"阅读的四个层次\"><a href=\"#阅读的四个层次\" class=\"headerlink\" title=\"阅读的四个层次\"></a>阅读的四个层次</h2><ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<h2 id=\"基础阅读（四个阶段）\"><a href=\"#基础阅读（四个阶段）\" class=\"headerlink\" title=\"基础阅读（四个阶段）\"></a>基础阅读（四个阶段）</h2><ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<h2 id=\"检视阅读（如何做）\"><a href=\"#检视阅读（如何做）\" class=\"headerlink\" title=\"检视阅读（如何做）\"></a>检视阅读（如何做）</h2><ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"阅读的四个层次\"><a href=\"#阅读的四个层次\" class=\"headerlink\" title=\"阅读的四个层次\"></a>阅读的四个层次</h2><ul>\n<li>基础阅读</li>\n<li>检视阅读</li>\n<li>分析阅读</li>\n<li>主题阅读</li>\n</ul>\n<h2 id=\"基础阅读（四个阶段）\"><a href=\"#基础阅读（四个阶段）\" class=\"headerlink\" title=\"基础阅读（四个阶段）\"></a>基础阅读（四个阶段）</h2><ul>\n<li>准备阶段<br>身体素质方面的准备、包括视力、听力、口齿等方面。</li>\n<li>简单识字</li>\n<li>用已有的词汇揭示不懂的词汇</li>\n<li>明白主题思想</li>\n</ul>\n<h2 id=\"检视阅读（如何做）\"><a href=\"#检视阅读（如何做）\" class=\"headerlink\" title=\"检视阅读（如何做）\"></a>检视阅读（如何做）</h2><ul>\n<li>先看书名</li>\n<li>研究目录(包括副标题、纲要等)</li>\n<li>如附有索引，简单阅读一下（了解概念性的词汇）</li>\n<li>读出版者的介绍（包括前言、序等）</li>\n<li>打开一本书、东翻翻西翻翻、念一两段，可以是连续几页但不要太多，目的在于将全书翻一遍。（不要忽视了后面几页、如后记等，后记一般是作者的总结）</li>\n<li>粗浅的阅读全书，遇到不懂的地方也要继续往下读，而不是要卡在这个地方，完全搞懂为止。<blockquote>\n<p>检视阅读的目的在于了解整本书的脉络、骨架，然后第二遍的时候再细读。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"><a href=\"#阅读过程中尝试提出问题并回答，比如：回答下面几个问题\" class=\"headerlink\" title=\"阅读过程中尝试提出问题并回答，比如：回答下面几个问题\"></a>阅读过程中尝试提出问题并回答，比如：回答下面几个问题</h2><ul>\n<li>整体来说，这本书谈什么？</li>\n<li>作者细说了什么、怎么说的？</li>\n<li>这本说有道理吗？</li>\n<li>这本书和你有什么关系？</li>\n</ul>\n<h2 id=\"如何让你本书成为你自己的\"><a href=\"#如何让你本书成为你自己的\" class=\"headerlink\" title=\"如何让你本书成为你自己的\"></a>如何让你本书成为你自己的</h2><ul>\n<li>画重点</li>\n<li>标星号，不要过多，要是重中之重。</li>\n<li>标序号</li>\n<li>在空白处记下关联内容的页码</li>\n<li>做笔记</li>\n</ul>\n<h2 id=\"书的分类\"><a href=\"#书的分类\" class=\"headerlink\" title=\"书的分类\"></a>书的分类</h2><ul>\n<li>理论型<br>告诉你这是什么</li>\n</ul>\n<ol>\n<li>哲学类（日常、例行、正常的生活经验总结出来的）</li>\n<li>科学类(超乎日常、例行、正常的生活经验，如实验室做实验)</li>\n</ol>\n<ul>\n<li>实用型<br>告诉你怎么去做</li>\n</ul>\n<h2 id=\"分析阅读\"><a href=\"#分析阅读\" class=\"headerlink\" title=\"分析阅读\"></a>分析阅读</h2><ul>\n<li>将书本分类</li>\n<li>一句话总结书在干什么</li>\n<li>列举重要篇章，说明它们按什么样的顺序、怎么组成一个整体的架构。</li>\n<li>发现作者的意图</li>\n</ul>\n"},{"title":"高效学习法","date":"2016-10-23T09:26:51.000Z","description":"本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤...","_content":"\n\n## 方法来源\n本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。\n\n## 我要学什么\n要学习的主题是什么，比如是摄影，还是iOS开发？\n\n## 筛选出我们想要学习的目标资源\n互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。\n\n## 制定明确的、具体的、无二义性的目标\n请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：\n\n - 目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。\n - 将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。\n\n## 学习任何知识都要先从全局出发\n当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。\n\n## 拆解成小任务\n将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。\n\n## 专注主线知识，不要被分支知识所诱惑\n如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在**遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它**。\n\n## 不只是眼睛读，手还要动\n我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。\n\n\n## 分享\n其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。\n\n## 最后\n这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。\n","source":"_posts/高效学习法.md","raw":"---\ntitle: 高效学习法\ncategories: 方法论\ntags: 学习方法\ndate: 2016-10-23 17:26:51\ndescription: \"本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤...\"\n---\n\n\n## 方法来源\n本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。\n\n## 我要学什么\n要学习的主题是什么，比如是摄影，还是iOS开发？\n\n## 筛选出我们想要学习的目标资源\n互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。\n\n## 制定明确的、具体的、无二义性的目标\n请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：\n\n - 目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。\n - 将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。\n\n## 学习任何知识都要先从全局出发\n当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。\n\n## 拆解成小任务\n将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。\n\n## 专注主线知识，不要被分支知识所诱惑\n如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在**遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它**。\n\n## 不只是眼睛读，手还要动\n我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。\n\n\n## 分享\n其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。\n\n## 最后\n这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。\n","slug":"高效学习法","published":1,"updated":"2016-11-15T09:17:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0brth4x002ugivbrybsgfef","content":"<h2 id=\"方法来源\"><a href=\"#方法来源\" class=\"headerlink\" title=\"方法来源\"></a>方法来源</h2><p>本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。</p>\n<h2 id=\"我要学什么\"><a href=\"#我要学什么\" class=\"headerlink\" title=\"我要学什么\"></a>我要学什么</h2><p>要学习的主题是什么，比如是摄影，还是iOS开发？</p>\n<h2 id=\"筛选出我们想要学习的目标资源\"><a href=\"#筛选出我们想要学习的目标资源\" class=\"headerlink\" title=\"筛选出我们想要学习的目标资源\"></a>筛选出我们想要学习的目标资源</h2><p>互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。</p>\n<h2 id=\"制定明确的、具体的、无二义性的目标\"><a href=\"#制定明确的、具体的、无二义性的目标\" class=\"headerlink\" title=\"制定明确的、具体的、无二义性的目标\"></a>制定明确的、具体的、无二义性的目标</h2><p>请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：</p>\n<ul>\n<li>目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。</li>\n<li>将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。</li>\n</ul>\n<h2 id=\"学习任何知识都要先从全局出发\"><a href=\"#学习任何知识都要先从全局出发\" class=\"headerlink\" title=\"学习任何知识都要先从全局出发\"></a>学习任何知识都要先从全局出发</h2><p>当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。</p>\n<h2 id=\"拆解成小任务\"><a href=\"#拆解成小任务\" class=\"headerlink\" title=\"拆解成小任务\"></a>拆解成小任务</h2><p>将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。</p>\n<h2 id=\"专注主线知识，不要被分支知识所诱惑\"><a href=\"#专注主线知识，不要被分支知识所诱惑\" class=\"headerlink\" title=\"专注主线知识，不要被分支知识所诱惑\"></a>专注主线知识，不要被分支知识所诱惑</h2><p>如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在<strong>遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它</strong>。</p>\n<h2 id=\"不只是眼睛读，手还要动\"><a href=\"#不只是眼睛读，手还要动\" class=\"headerlink\" title=\"不只是眼睛读，手还要动\"></a>不只是眼睛读，手还要动</h2><p>我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。</p>\n<h2 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h2><p>其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。</p>\n","excerpt":"","more":"<h2 id=\"方法来源\"><a href=\"#方法来源\" class=\"headerlink\" title=\"方法来源\"></a>方法来源</h2><p>本文所介绍的学习方法主要的观点来自《如何阅读一本书》、《软技能：代码之外的生存指南》和《把时间当做朋友》。这三本书有些观点是极其相似的，本人将它们综合起来，并且结合了自身的一些体会，提炼出7大步骤。下面就开始介绍这套高效的学习方法。</p>\n<h2 id=\"我要学什么\"><a href=\"#我要学什么\" class=\"headerlink\" title=\"我要学什么\"></a>我要学什么</h2><p>要学习的主题是什么，比如是摄影，还是iOS开发？</p>\n<h2 id=\"筛选出我们想要学习的目标资源\"><a href=\"#筛选出我们想要学习的目标资源\" class=\"headerlink\" title=\"筛选出我们想要学习的目标资源\"></a>筛选出我们想要学习的目标资源</h2><p>互联网时代，我们要学习一项技能、一些概念更容易了，但是同时带来的困扰就是信息泛滥，我们需要甄别哪些知识是更真实的，更适合自己的。如果自己能力足够，阅读官方资料则是最好的学习资源。如果自己所具备的知识还不能比较轻松的学习官方资料，那么一些网络文章，或者书籍则是更为合适的学习资源。对于网络资源，来自比较权威的网站会比普通不知名的网站的资源更有说服力。对于书本，选择多人买、高评价的会更好，当自己无法做出选择的时候，到豆瓣看看这本书的分数也是个很不错的方法。</p>\n<h2 id=\"制定明确的、具体的、无二义性的目标\"><a href=\"#制定明确的、具体的、无二义性的目标\" class=\"headerlink\" title=\"制定明确的、具体的、无二义性的目标\"></a>制定明确的、具体的、无二义性的目标</h2><p>请注意这个目标一定是要具体的，有多具体就有多具体，比如我说“我要学习iOS开发”，就没有“我要学会开发一款iOS音乐播放器”这么具体明确。之所以要制定一个明确的目标，主要有两个作用：</p>\n<ul>\n<li>目标是看得见的，不是模糊的，自己的思维会更清晰，更容易知道自己想做什么，怎么去做。</li>\n<li>将自己学习的范围缩小了，这个目标就更容易实现，也更容易增加自身的积极性。</li>\n</ul>\n<h2 id=\"学习任何知识都要先从全局出发\"><a href=\"#学习任何知识都要先从全局出发\" class=\"headerlink\" title=\"学习任何知识都要先从全局出发\"></a>学习任何知识都要先从全局出发</h2><p>当我们刚买一台空调，我们可能先查阅说明书，说明书就是“全局”。当我们学习一份开源代码，我们可能回查看怎么结构是怎么样的，这个结构就是“全局”。对于一本书来说，目录就是这本书的“全局”，每一章书的开头通常来说也会是这个章节的“全局”。通过全局的把握知识，我们更加清楚的知道自己学习的进度如何，现在没懂的，接下来会不会在其他地方讲到。</p>\n<h2 id=\"拆解成小任务\"><a href=\"#拆解成小任务\" class=\"headerlink\" title=\"拆解成小任务\"></a>拆解成小任务</h2><p>将一个学习计划拆分成一个个的小任务，这样更容易获得成就感，从而有利于提高自己的积极性。</p>\n<h2 id=\"专注主线知识，不要被分支知识所诱惑\"><a href=\"#专注主线知识，不要被分支知识所诱惑\" class=\"headerlink\" title=\"专注主线知识，不要被分支知识所诱惑\"></a>专注主线知识，不要被分支知识所诱惑</h2><p>如同上网冲浪，本来打开C站的只是想看看新闻，结果有个商品的推荐广告吸引了自己，于是跳到了售卖该商品的网站，浏览过程中，又有其他类似商品的推荐，顶不住诱惑又跳到那个商品的页面，浏览了一小个小时，到头来就连今日新闻的标题是什么自己都不清楚。学习的过程中也会如此，途中可能会遇到一些我们不熟悉的概念或者其他的知识，我们这时候可能会本着“打破砂锅问到底”的”诚恳“的学习态度，上网搜索了这个概念的相关资料，没想到这个资料当中又有一些自己不甚了解的知识，反复如是，结果我们想要学习的主题一而再再而三的被拖延了，本来计划一个章节只花一周的学习时间，结果变成了两周或者更长，这多多少少都会打击到自己的积极性。所以我们应该在<strong>遇到不明白的知识点的时候，记录下来，回头单独找时间来学习它</strong>。</p>\n<h2 id=\"不只是眼睛读，手还要动\"><a href=\"#不只是眼睛读，手还要动\" class=\"headerlink\" title=\"不只是眼睛读，手还要动\"></a>不只是眼睛读，手还要动</h2><p>我们学习的目的，相信最终都是想把知识深深的烙印在自己的脑海里。一切不能被自己吸收的知识的学习都是浪费时间。那如何才能做到呢？如果你过目不忘，那么不需要做其他的事情，只是看就行了。但是对于大多数人来说，都是普通人，我就是一个普通得不能再普通得人了，当下觉得记忆很清晰的事物，过一段时间或许就忘记了，所以我们最好是把我们当下学习到的知识以自己理解的方式记录下来。如果是读书，为了不打断思维的连贯性，通常我自己只是把重要的点记录画线标记下来，在我读完这章之后，再花时间把要点整理出来，记录到一个文档里面。如果是编程学习，那么在了解了整个知识架构之后，还需要按模块反复打磨细节，边学习理论，边敲代码。</p>\n<h2 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h2><p>其实这个步骤应该是：传道授惑解惑。在这里对于我自己的现阶段而言，更愿意用”分享“这个词来替换”传道授惑“。因为分享往往意味着以平等甚至更低的姿态转述自己的知识，这样做有利于自己对对方观点的吸收。我还记得电影《一代宗师》里面出现的三个词汇：见自己、见天地、见众生。不知道你对这句话怎么理解的，我的理解就是：自我了解、不断学习、传道受业。学习的自然是可以解惑，那为什么教别人也是可以解惑呢？分享其实是个检验自己所学知识有多扎实的最好途径，因为要想把自己所知道的知识传递给他人，自己的的转述必须是脉络清晰的，这意味着自己能对知识做到真正的系统的了解。如果自己的转述不够清晰，听者这时候可能就会有所质疑，而这些质疑会促使我们再次整理我们的知识，循环渐进，我们的知识将更加牢固。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>这套学习方法，是我自己正在实践的方法，感觉效果不错，因此分享出来，希望能帮到一部分人，哪怕是一小部分。如果真是这样的话，我觉得这些写作的时间是十分值得的。我也希望自己在工作之余能更好更快的学习，最后能真的成为自己想要成为的人。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj0brth380000givbxfz1bo6z","category_id":"cj0brth3g0004givb5una2gxu","_id":"cj0brth3q000egivb1pbn432n"},{"post_id":"cj0brth3p000dgivbfu42y08q","category_id":"cj0brth3w000qgivbiv1fi9t5","_id":"cj0brth440010givboy6l25np"},{"post_id":"cj0brth3e0002givbpsvqatl1","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth480015givbopnvymww"},{"post_id":"cj0brth3e0002givbpsvqatl1","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth490018givbhdpdiifn"},{"post_id":"cj0brth44000zgivb5sepqmlq","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4a001cgivbaouwuyua"},{"post_id":"cj0brth44000zgivb5sepqmlq","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth4c001ggivb3rzkr8mz"},{"post_id":"cj0brth3q000fgivbrhx01zbk","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4d001jgivb2d2zkewd"},{"post_id":"cj0brth3q000fgivbrhx01zbk","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth4e001ngivb8ugqlgut"},{"post_id":"cj0brth470014givbx0h4riqt","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4g001qgivbzopqog7z"},{"post_id":"cj0brth470014givbx0h4riqt","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth4i001ugivbm4xzu093"},{"post_id":"cj0brth480016givb4ot9c18p","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4i001xgivbynn83a66"},{"post_id":"cj0brth480016givb4ot9c18p","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth4k0020givbch6mtrcv"},{"post_id":"cj0brth3t000igivbsfdsq94q","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4l0022givbgrultdaq"},{"post_id":"cj0brth3t000igivbsfdsq94q","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth4n0027givbvk77wsaf"},{"post_id":"cj0brth49001agivbx0d7ujd4","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4o002agivbypqosn2b"},{"post_id":"cj0brth49001agivbx0d7ujd4","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth4r002fgivbap8c8cgv"},{"post_id":"cj0brth4b001dgivbgbcrorfj","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4s002igivbudmbjbwe"},{"post_id":"cj0brth4b001dgivbgbcrorfj","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth4t002ngivbah69vcqt"},{"post_id":"cj0brth3h0006givbtk73eo29","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4t002pgivbpdh4p6oz"},{"post_id":"cj0brth3h0006givbtk73eo29","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth4x002tgivbm6xlnf0k"},{"post_id":"cj0brth4c001igivbh0rcmxb1","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth4y002vgivbm3p3nqbl"},{"post_id":"cj0brth4c001igivbh0rcmxb1","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth50002xgivbfla4djem"},{"post_id":"cj0brth4f001ogivbho55v4xu","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth510030givbjezn6hoj"},{"post_id":"cj0brth4f001ogivbho55v4xu","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth520033givbk6hryzzq"},{"post_id":"cj0brth3t000kgivb5209n7fd","category_id":"cj0brth4e001mgivbbar1gbki","_id":"cj0brth530036givb395bdyjx"},{"post_id":"cj0brth4g001sgivb6m8q7795","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth530038givbhze6xo8a"},{"post_id":"cj0brth4g001sgivb6m8q7795","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth53003bgivb7i9vwtrr"},{"post_id":"cj0brth4i001vgivbmy0dk5f1","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth54003dgivbnuqcrv91"},{"post_id":"cj0brth4i001vgivbmy0dk5f1","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth54003fgivb0rf1922j"},{"post_id":"cj0brth3v000ngivbzj77b4vz","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth54003ggivbd2pcoz9w"},{"post_id":"cj0brth3v000ngivbzj77b4vz","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth55003jgivbciafu6ty"},{"post_id":"cj0brth4j001ygivb9o9bceb9","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth55003kgivbc30nxo2h"},{"post_id":"cj0brth4j001ygivb9o9bceb9","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth55003mgivbue9gc3mo"},{"post_id":"cj0brth4k0021givbxgsgxbvu","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth57003pgivbuzdc1akn"},{"post_id":"cj0brth4k0021givbxgsgxbvu","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth58003sgivbznsw0wya"},{"post_id":"cj0brth3l0009givbz4l5lszt","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth58003vgivbqkywh32z"},{"post_id":"cj0brth3l0009givbz4l5lszt","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth58003xgivbn9pnha9n"},{"post_id":"cj0brth4m0024givbb4hljdy6","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth59003zgivbbyxxzbin"},{"post_id":"cj0brth4m0024givbb4hljdy6","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth590042givbpa59t27r"},{"post_id":"cj0brth4n0028givbt4ru9dcp","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth590043givb0ujeotgt"},{"post_id":"cj0brth4n0028givbt4ru9dcp","category_id":"cj0brth41000vgivbr3bwh4x2","_id":"cj0brth5a0045givb2sxwn30z"},{"post_id":"cj0brth3w000pgivbw8zziifx","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth5a0047givbowtjqa1w"},{"post_id":"cj0brth3w000pgivbw8zziifx","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth5a0049givbiwlopxut"},{"post_id":"cj0brth4r002ggivbhzfwpr65","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth5a004cgivbred4j07w"},{"post_id":"cj0brth4r002ggivbhzfwpr65","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth5a004dgivbcvqrc442"},{"post_id":"cj0brth3x000sgivbg9v91mgn","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth5b004fgivbjvxq8olu"},{"post_id":"cj0brth3x000sgivbg9v91mgn","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth5b004hgivb0meh5d3w"},{"post_id":"cj0brth4t002ogivbpawtqwgk","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth5b004jgivbcfi7y8oe"},{"post_id":"cj0brth4t002ogivbpawtqwgk","category_id":"cj0brth450011givbueqt41zp","_id":"cj0brth5b004lgivbvfk2hmtx"},{"post_id":"cj0brth42000wgivb0gu4kg6y","category_id":"cj0brth4x002sgivb3v8bizjo","_id":"cj0brth5b004ngivbio8zd1cq"},{"post_id":"cj0brth450012givbl4s38lsp","category_id":"cj0brth4x002sgivb3v8bizjo","_id":"cj0brth5b004pgivbz789tobj"},{"post_id":"cj0brth4d001lgivb94saeket","category_id":"cj0brth3n000agivbusfwnolu","_id":"cj0brth5b004qgivbyg6vw2fq"},{"post_id":"cj0brth4d001lgivb94saeket","category_id":"cj0brth520034givbtc75umc6","_id":"cj0brth5c004tgivbjcn9kok8"},{"post_id":"cj0brth4o002cgivbl6w8imrs","category_id":"cj0brth530039givbqa4hmv94","_id":"cj0brth5c004ugivbpo4mq3jc"},{"post_id":"cj0brth4s002kgivbshquxynk","category_id":"cj0brth54003egivbgzda0zi8","_id":"cj0brth5c004xgivbrm12vm8i"},{"post_id":"cj0brth3z000ugivbdtbp01es","category_id":"cj0brth4s002lgivbjxtmpx85","_id":"cj0brth5c004ygivbexh70dy3"},{"post_id":"cj0brth3z000ugivbdtbp01es","category_id":"cj0brth55003igivb6cbuftxu","_id":"cj0brth5c0050givbxf0n5vxr"},{"post_id":"cj0brth4u002rgivbo85p9p5y","category_id":"cj0brth56003ogivb7qc85rb6","_id":"cj0brth5c0052givbdf42vifr"},{"post_id":"cj0brth4x002ugivbrybsgfef","category_id":"cj0brth56003ogivb7qc85rb6","_id":"cj0brth5d0054givbwf1k3xzv"}],"PostTag":[{"post_id":"cj0brth380000givbxfz1bo6z","tag_id":"cj0brth3h0005givbaqekv64h","_id":"cj0brth3o000cgivbtnfbt5l1"},{"post_id":"cj0brth3e0002givbpsvqatl1","tag_id":"cj0brth3n000bgivbtzdnkoo5","_id":"cj0brth3t000jgivbtpdsdi0k"},{"post_id":"cj0brth3h0006givbtk73eo29","tag_id":"cj0brth3r000hgivb2oa2jd81","_id":"cj0brth3v000ogivb2365ao47"},{"post_id":"cj0brth3k0008givbo2veo19k","tag_id":"cj0brth3u000mgivbn25feux2","_id":"cj0brth3z000tgivbfhf4f9x3"},{"post_id":"cj0brth3l0009givbz4l5lszt","tag_id":"cj0brth3x000rgivb7ys90uty","_id":"cj0brth44000ygivbklxxj0wj"},{"post_id":"cj0brth3p000dgivbfu42y08q","tag_id":"cj0brth42000xgivbbbdv8meq","_id":"cj0brth4a001bgivbo6wdfkdf"},{"post_id":"cj0brth3p000dgivbfu42y08q","tag_id":"cj0brth460013givb8c632tq5","_id":"cj0brth4c001fgivb89zbrmtv"},{"post_id":"cj0brth3q000fgivbrhx01zbk","tag_id":"cj0brth490019givbm8x6diqf","_id":"cj0brth4d001kgivbiq1hgyxh"},{"post_id":"cj0brth3t000igivbsfdsq94q","tag_id":"cj0brth4c001hgivb6555ln7k","_id":"cj0brth4g001rgivbdrsfnpj7"},{"post_id":"cj0brth3t000kgivb5209n7fd","tag_id":"cj0brth4f001pgivbm975zeki","_id":"cj0brth4n0026givbmndkqpob"},{"post_id":"cj0brth3t000kgivb5209n7fd","tag_id":"cj0brth4i001wgivbn3383ho3","_id":"cj0brth4o0029givbgc630m7x"},{"post_id":"cj0brth4k0021givbxgsgxbvu","tag_id":"cj0brth4c001hgivb6555ln7k","_id":"cj0brth4r002egivbgmxlzp3t"},{"post_id":"cj0brth3w000pgivbw8zziifx","tag_id":"cj0brth3x000rgivb7ys90uty","_id":"cj0brth4r002hgivb2wb915mn"},{"post_id":"cj0brth3x000sgivbg9v91mgn","tag_id":"cj0brth3x000rgivb7ys90uty","_id":"cj0brth4s002mgivbdd35d744"},{"post_id":"cj0brth3z000ugivbdtbp01es","tag_id":"cj0brth4s002jgivbh4b9sc74","_id":"cj0brth50002ygivbp9g84yss"},{"post_id":"cj0brth3z000ugivbdtbp01es","tag_id":"cj0brth4i001wgivbn3383ho3","_id":"cj0brth510031givb9fdpwohp"},{"post_id":"cj0brth42000wgivb0gu4kg6y","tag_id":"cj0brth50002wgivb3j21hkno","_id":"cj0brth520035givbocbck5se"},{"post_id":"cj0brth44000zgivb5sepqmlq","tag_id":"cj0brth520032givbiuj86v0c","_id":"cj0brth53003agivbwtgsuyl9"},{"post_id":"cj0brth450012givbl4s38lsp","tag_id":"cj0brth50002wgivb3j21hkno","_id":"cj0brth56003ngivbur1rzoib"},{"post_id":"cj0brth450012givbl4s38lsp","tag_id":"cj0brth54003cgivb112iwikr","_id":"cj0brth57003qgivbtu3pp7pa"},{"post_id":"cj0brth450012givbl4s38lsp","tag_id":"cj0brth54003hgivb4jrpqmfm","_id":"cj0brth58003tgivbahdnrva5"},{"post_id":"cj0brth4b001dgivbgbcrorfj","tag_id":"cj0brth55003lgivbv208lu94","_id":"cj0brth59003ygivbyvjpcdyq"},{"post_id":"cj0brth4b001dgivbgbcrorfj","tag_id":"cj0brth58003rgivbfkzw2v06","_id":"cj0brth590040givbg6cd64cb"},{"post_id":"cj0brth4d001lgivb94saeket","tag_id":"cj0brth54003cgivb112iwikr","_id":"cj0brth5a0046givbtmkcjy0v"},{"post_id":"cj0brth4d001lgivb94saeket","tag_id":"cj0brth4i001wgivbn3383ho3","_id":"cj0brth5a0048givbkmkmkk6v"},{"post_id":"cj0brth4f001ogivbho55v4xu","tag_id":"cj0brth5a0044givbcrxx6qpb","_id":"cj0brth5a004bgivb12yp133j"},{"post_id":"cj0brth4g001sgivb6m8q7795","tag_id":"cj0brth5a004agivb7ei681sm","_id":"cj0brth5b004ggivbvmu1o9jw"},{"post_id":"cj0brth4i001vgivbmy0dk5f1","tag_id":"cj0brth5a004egivb9fqxsd83","_id":"cj0brth5b004kgivbqdzzpubr"},{"post_id":"cj0brth4m0024givbb4hljdy6","tag_id":"cj0brth5b004igivbm1iytsn5","_id":"cj0brth5b004ogivbo0o5puux"},{"post_id":"cj0brth4o002cgivbl6w8imrs","tag_id":"cj0brth5b004mgivbgf54bnup","_id":"cj0brth5c004sgivby7nluxox"},{"post_id":"cj0brth4r002ggivbhzfwpr65","tag_id":"cj0brth50002wgivb3j21hkno","_id":"cj0brth5c004wgivb4oawc4uz"},{"post_id":"cj0brth4s002kgivbshquxynk","tag_id":"cj0brth5c004vgivb3ku5ke89","_id":"cj0brth5c0051givbntqtr35c"},{"post_id":"cj0brth4t002ogivbpawtqwgk","tag_id":"cj0brth5c004zgivbaakutybb","_id":"cj0brth5d0055givbi9ulfaim"},{"post_id":"cj0brth4u002rgivbo85p9p5y","tag_id":"cj0brth5c0053givbgbjd5oa3","_id":"cj0brth5d0057givbecca9is5"},{"post_id":"cj0brth4x002ugivbrybsgfef","tag_id":"cj0brth5c0053givbgbjd5oa3","_id":"cj0brth5e0058givbo0ww48uo"}],"Tag":[{"name":"OpenGL","_id":"cj0brth3h0005givbaqekv64h"},{"name":"swift","_id":"cj0brth3n000bgivbtzdnkoo5"},{"name":"UI优化","_id":"cj0brth3r000hgivb2oa2jd81"},{"name":"方法论","_id":"cj0brth3u000mgivbn25feux2"},{"name":"Mach","_id":"cj0brth3x000rgivb7ys90uty"},{"name":"编译","_id":"cj0brth42000xgivbbbdv8meq"},{"name":"汇编","_id":"cj0brth460013givb8c632tq5"},{"name":"XNU","_id":"cj0brth490019givbm8x6diqf"},{"name":"文件系统","_id":"cj0brth4c001hgivb6555ln7k"},{"name":"H5","_id":"cj0brth4f001pgivbm975zeki"},{"name":"JS","_id":"cj0brth4i001wgivbn3383ho3"},{"name":"React","_id":"cj0brth4s002jgivbh4b9sc74"},{"name":"网络","_id":"cj0brth50002wgivb3j21hkno"},{"name":"事件响应链","_id":"cj0brth520032givbiuj86v0c"},{"name":"安全","_id":"cj0brth54003cgivb112iwikr"},{"name":"SSL/TLS","_id":"cj0brth54003hgivb4jrpqmfm"},{"name":"推送","_id":"cj0brth55003lgivbv208lu94"},{"name":"APNs","_id":"cj0brth58003rgivbfkzw2v06"},{"name":"Cocoapods","_id":"cj0brth5a0044givbcrxx6qpb"},{"name":"内核架构","_id":"cj0brth5a004agivb7ei681sm"},{"name":"引导过程","_id":"cj0brth5a004egivb9fqxsd83"},{"name":"内核","_id":"cj0brth5b004igivbm1iytsn5"},{"name":"算法","_id":"cj0brth5b004mgivbgf54bnup"},{"name":"CoreText","_id":"cj0brth5c004vgivb3ku5ke89"},{"name":"launchd","_id":"cj0brth5c004zgivbaakutybb"},{"name":"学习方法","_id":"cj0brth5c0053givbgbjd5oa3"}]}}