---
title: 经典排序算法
categories: 算法
tags: 算法
date: 2016-11-28 17:21:09
---


## 一、归并排序（复杂度O(N*logN)）
### 一轮合并操作
1. 存在两个**有序**的数组A、B合并到一个新的数组C，并让新的数组C有序。
2. 取出A的第一个元素与B的第一元素比较，取出小的放入数组C中。
3. 重复步骤2，直到A、B数组至少一个为空，如果A为空，则拷贝B剩余元素到C中；B为空，则拷贝A剩余元素到C中。

### 归并排序
采用了分治的思想，递归的将需要排序的数组对半的分成两个子数组，并对这两个数组进行合并。**当被拆分的数组的元素个数小于等于1个的时候，那么这个两个子数组内部就一定是有序的，因此合并起来的数组也是有序的**。接下来就是重复以上提到的“一轮合并操作”，进行N轮的合并操作。
### 伪代码
```
void mergesort(int a[], int first, int last, int temp[])
{
	if (first < last)
	{
		int mid = (first + last) / 2;
		mergesort(a, first, mid, temp);    //左边有序
		mergesort(a, mid + 1, last, temp); //右边有序
		mergearray(a, first, mid, last, temp); //再将二个有序数列合并
	}
}
```

## 二、快速排序(复杂度O(N*logN))

### 一轮排序操作
1. 先从数列中取出一个数作为基准数。
2. 分区过程，将比这个数大的数全挖出来放到它的右边，小于或等于它的数挖出来放到它的左边。（*具体来说，创建两个索引l、r，遍历的过程中，l从左往右移动，r从右往左移动。当左边的元素被挖出来了，则遍历右边，直到发现右边比基准数小的数字，填到左边。当右边的元素被挖出来了，则遍历左边，直到发现左边比基准数小的数字，填到右边。*）
3. 再对左右区间重复第二步，直到各区间只有一个数。

### 伪代码
```
void quick_sort1(int s[], int l, int r)
{
	if (l < r)
    {
		int i = AdjustArray(s, l, r);//一轮排序操作
		quick_sort1(s, l, i - 1); // 递归调用 
		quick_sort1(s, i + 1, r);
	}
}
```

## 三、堆排序(复杂度O(N*logN))
二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：

1. 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
2. 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

根据这个特性我们知道**堆顶的元素一定是最大或者最小**。因此堆排序的步骤一般为：

1. 将无序数组A[n-1]构造成一个二叉堆，然后取出堆顶与堆尾交换。
2. 此时A[n-1]是有序的，A[0...n-2]重复步骤1。


### 参考
[白话经典算法系列之六 快速排序 快速搞定][1]

[白话经典算法系列之五 归并排序的实现][2]

[白话经典算法系列之七 堆与堆排序][3]

[1]: http://blog.csdn.net/morewindows/article/details/6684558
[2]: http://blog.csdn.net/morewindows/article/details/6678165
[3]: http://blog.csdn.net/morewindows/article/details/6709644



